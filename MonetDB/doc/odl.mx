@f odmg_odl
@a Peter Boncz
@v 2.0
@d 18/11/1997
@t Monet/ODL Language Reference
@* Introduction
@T
The Monet/ODL is a dialect of ODL based on the 
@[<a href="http://www.odmg.org">ODMG 1.X</a>@ definition. It brings
the new concept of user-defined atomic types, but in all other
aspects it is mostly a subset.

\begin{center}
{\epsfxsize=0.60\textwidth
\epsffile{odmg_odl.eps}
{\em The ODL data modeling language and its place in the Monet/ODMG System}}
\end{center}

More information on the Monet/ODMG system can be found in the following
reference material:
\begin{itemize}
\item The @[<a href="monet.html">Monet Documentation</a>@
for more information on availability,
installing, and a general system overview.
\item See the @[<a href="man/odlp.html">Manual Page</a>@
for the exact calling options of the ODL parser.
\item The @[<a href="stdlib.html">ODMG Standard Library Reference</a>@
defines which standard facilities are present in ODMG, and what is their
exact interface in the ODMG/\{Java, C, C++\} programming environments
respectively.
\item The @[<a href="meta.html">ODMG Meta Model</a>@
shows the ODL schema of the Meta model that is used as Data Dictionary.
\item The @[<a href="Example.html">Example ODL Model</a>@
introduces a simple Customer-Order-Item model and shows how this
can be accessed in the ODMG/C, ODMG/C++ and ODMG/Java environments
through stub classes.
\item The @[<a href="app.html">Example ODMG Application</a>@
uses the same data-model to build a simple application for
internet sales, that demonstrates easily how all system components
work and fit together.
\end{itemize}


@+ Grammar Specification
@T
Some general rules:
\begin{itemize}
\item white-space is ignored.
\item upper- and lower-case {\bf does} matter.
\item the '//' characters initiate comment text; 
      everything up until the next newline character is ignored.
\end{itemize}

For those who are not accustomed to reading yacc style grammars
a few guidelines for interpreting the rules:

\begin{description}
\item[ [ something ] ] indicates zero or one times something.
\item[ \{ something \} ] indicates zero or more times something.
\item[ one \| another ] indicates one thing, or the other.
\item[ $<$IDENT: explanation$>$ ] an identifier, consisting of letters,
digits or underscores (staring with a letter).
\item[ $<$INT: explanation$>$] a positive integer number.
\item[ $<$EMPTY$>$] nothing there.
\end{description}

Language identifiers and characters are printed between single 
quotes in the grammar definitions.

@* The ODL Definition
@T
An ODL file contains at least and most one ODL module, by that same name. 

{\small\bf\begin{verbatim}
ODL ::=
	'module' <IDENT: module name> 
        '{'       { ATOMREF 
		  | ATOMDEF   
                  | INTERFACE_FORWARD 
                  | INTERFACE 
                  | FUNCTION }
	'}' ';' 
\end{verbatim}}

Each module defines a series of atoms, global functions and interfaces.

@+ literal
ODMG literals are the following collection of standard types:
@T
{\small\bf\begin{verbatim}
LITERAL ::= 
        'boolean'
    |   'char'
    |   'short'
    |   'int'
    |   'long'
    |   'float'
    |   'double'
    |   'string'
    |   <IDENT: enum type>
    |   <IDENT: user-defined atomic type>
\end{verbatim}}

The last two lines state that the standard collection of literals is 
supplemented by enumeration types, and user-defined atomic type 
extensions. We will discuss them in turn.
	
@- enumeration types
@T
Enumeration types are like integers that have standard collection
of constant values.

{\small\bf\begin{verbatim}
ENUM ::=
	'enum' <IDENT: enum name> '{' <IDENT> { ',' <IDENT> } '}' ';'
\end{verbatim}}

The {\tt boolean} type could have been defined like
{\tt enum boolean \{ FALSE, TRUE \};}.

@- user-defined atomic types	
@T
The Monet/ODMG system is implemented on top of the extensible database
system Monet. Each atom in Monet can be imported as an atom in ODMG.
This is symbolized by the ATOMREF clause. You can just name atoms that
are present in Monet, and you will be able to use them in Monet/ODMG 
as well. You first have to define these types in Monet (see the
@[<a href="mel.body.html#mod_2_3_0">MEL Reference Manual</a>@).

{\small\bf\begin{verbatim}
ATOMREF ::=
        'atom' <IDENT: atom name> ';'

ATOMDEF ::=
        'atom' <IDENT: atom name> '[' ATOM_SIZE_SPECS ']' '{' 
		{ ATOM_ATTRIBUTE | FUNCTION | CONSTRUCTOR } 
	'}' ';'

ATOM_SIZE_SPECS ::=
        <INT: fixed size in bytes> [ ',' <INT: byte-alignment> ] 

ATOM_ATTRIBUTE ::=
	'attribute' LITERAL <IDENT: attribute name> ';'
\end{verbatim}}

The other way around is also possible: by defining an atom in ODL,
you can automatically let MONET/ODMG generate a Monet type-extension.
You can do this for simple atoms that are a {\tt struct} of simple
literal values. The Monet extension module automatically generated 
with the @[<a href="man/odlp.html">odl parser</a>@ will add them to
the system for you. Methods on these atoms need to be implemented  
in C or C++ by the application programmer.

@+ interfaces
@T
An interface in Monet/ODL is like a traditional object-oriented 'class'; 
it has attribute members, special 'relationship' attribute members that 
refer to instances of other interfaces, and methods. 

We follow the ODMG1.X interpretation of an interface: it is a 
data definition of what would be a 'class' in C++ (ODMG2.0 replaces this 
with 'class' and introduces 'interface' for defining a collection
of methods that describes common behavior -- the Java model).

{\small\bf\begin{verbatim}
INTERFACE ::=
	'interface' <IDENT: class name> { ':' INTERFACE_REF }
		  [ '(' [ <IDENT: extent name> ] ')' ]
        '{' 
		{ ATTRIBUTE | RELATION | METHOD } 
	'}' ';'

INTERFACE_REF ::=
        [ <IDENT: module name> '::' ] <IDENT: super class> }
\end{verbatim}}

When an interface is referenced before it is defined, a syntax error
will occur. You can do forward declarations to prevent this from happening.

Interfaces can be derived from each other using inheritance.

All instances of a certain interface will end up in a system-generated
collection of objects that is called the 'extent'. You can give the
extents a name, so your programs will later be able to look the collection
up by providing this name as a string to the 
@[<a href="stdlib.body.html#mod_1_8_0">Database.lookup()</a>@ method. 

{\small\bf\begin{verbatim}
INTERFACE_FORWARD ::=
	'interface' <IDENT: class name> ';'
\end{verbatim}}

The INTERFACE_FORWARD definition allows to reference interfaces
that are defined in external modules. These modules are implicitly 
looked up by the @[<a href="man/odlp.html">odl parser</a>@  (e.g. 
'test.odl' is implied to define the 'my_class' interface if you 
reference it as 'test::my_class'). 

@+ interface members
@T
So-called 'normal' attributes contain literal (i.e. non-object) values. 
Since we limit the COLLECTION kinds for the time being to 'Set', and do 
not allow nested sets, an attribute value is either a literal or a set of 
literals. 

{\small\bf\begin{verbatim}
METHOD ::=
        [ 'virtual' ] FUNCTION

ATTRIBUTE ::=
	[ 'readonly' ] 'attribute' ODL_TYPE <IDENT: attribute name> ';'

ODL_TYPE ::=
        SINGLE_TYPE 
    |   COLLECTION '<' SINGLE_TYPE '>'  

SINGLE_TYPE ::=
	INTERFACE_REF
    |   LITERAL

COLLECTION ::=
	'Set'
\end{verbatim}}

When an attribute references another object, it is called a 'relationship'.
 
{\small\bf\begin{verbatim}
RELATION ::=
	'relationship' INTERFACE_TYPE <IDENT: attribute name> [ INVERSE ] ';'

INTERFACE_TYPE ::=
        INTERFACE_REF 
    |   COLLECTION '<' INTERFACE_REF '>'  

INVERSE ::=
	'inverse' [ INTERFACE_REF '::'] <IDENT: attribute name> 
	
\end{verbatim}}

Relationships have the special property that one can define them to have
an 'inverse'. Consider for instant a {\tt Person} class with inverse 
relationship members {\tt Set$<$Person$>$ children} and 
{\tt Set$<$Person$>$ parents}. They in fact store the same links between 
persons. An update to each of them, will be implicitly reflected in the other.

@+ functions
@T
The definition of methods and global functions share the same grammar.
Methods are related to an interface, and can access the internal state 
of the object from which it was called during call-time. 

For each method/function the Monet/ODMG system will generate a new
algebraic command in Monet. These will be packaged in  the extension
module that is automatically generated by the 
@[<a href="man/odlp,html">odl parser</a>@. Functions have to be implemented
by the application programmer either with the ODMG/C or ODMG/C++ binding.
 
{\small\bf\begin{verbatim}
FUNCTION ::=
	OP_TYPE <IDENT: function name> '(' [ PARAM { ',' PARAM } ] ')' ';'

CONSTRUCTOR ::=
        'constructor' '('  [ PARAM { ',' PARAM } ] ')' ';'

PARAM ::=
	'in' OP_TYPE <IDENT: parameter name> 

OP_TYPE ::=
	'void'
    |   ODL_TYPE
\end{verbatim}}

Note that we ignore the 'out' and 'inout' parameter passing schemes.
Parameters are only passed inwards. This does not mean that that a method
is read-only: it can modify the state of the objects passed into it
and indeed of the entire database, as the implementer can do what
[s]he wants in the supplied ODMG/C or ODMG/C++ implementation. 

@+ Unsupported  ODL Features
@T
The following ODL 1.X standard features are not supported in Monet/ODL:

\begin{description}
\item[collection types]
for the time being we just support sets. Nested set types are not
supported, however. Sets have a {\bf unique} property that lets them be used
at the  as if they were Bags (see the section on Sets in the 
@[<a href="stdlib.body.html#mod_1_4_0">ODMG Standard Library Reference</a>@). 
Arrays and lists are not supported, nor is the 'order by' clause 
related to them.
\item[interface definitions]
The 'key' and 'keys' declaration is ignored  for the time being.
All interfaces are persistent, always ('transient' declaration ignored).
\item[methods]
The 'oneway' keyword for specifying that a method has no result, is ignored.
\item[struct types]
are not supported. Must be emulated either with multiple attributes
or using additional interface definitions. 
\item[exceptions]
are not supported. Very limited exceptions on methods are provided in ODMG/Java.
\item[constants]
are not supported.
\end{description}

In the following grammar specification we will ignore the unsupported
bits and just describe the subset of the ODL grammar that does
Monet/ODL work with. 
Note that the @[<a href="man/odlp.html">ODMG/odl parser</a>@ accepts
the full ODMG1.2 definition, but it simply ignores the
unsupported features for which it reverts to default values.

