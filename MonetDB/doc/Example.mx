@f Example
@a Peter Boncz, Fred Kwakkel, Menzo Windhouwer
@v 3.1
@d 24/06/1998
@t Example Monet/ODL Model and Language Mappings
@* Introduction
@T
The reference text shows how an Monet/ODL data model specification is 
mapped onto the ODMG/C, ODMG/C++ and ODMG/Java programming environments.

\begin{center}
{\epsfxsize=0.60\textwidth
\epsffile{odmg_example.eps}
{\em Generated Stub Classes in the Monet/ODMG System}}
\end{center}

More information on the Monet/ODMG system can be found in the following
reference material:
\begin{itemize}
\item The @[<a href="monet.html">Monet Documentation</a>@
for more information on availability,
installing, and a general system overview.
\item The @[<a href="odl.html">ODL Reference Manual</a>@
for an exact definition of Monet/ODL. It was derived from the ODMG1.X
definition and introduces atomic extensibility but lacks some other features.
It differs widely from ODMG2.0.
\item See the @[<a href="man/odlp.html">Manual Page</a>@
for the exact calling options of the ODL parser.
\item The @[<a href="stdlib.html">ODMG Standard Library Reference</a>@
defines which standard facilities are present in ODMG, and what is their
exact interface in the ODMG/\{Java, C, C++\} programming environments
respectively.
\item The @[<a href="meta.html">ODMG Meta Model</a>@
shows the ODL schema of the Meta model that is used as Data Dictionary.
\item The @[<a href="app.html">Example ODMG Application</a>@
uses the same data-model to build a simple application for
internet sales, that demonstrates easily how all system components
work and fit together.
\end{itemize}

@f Example
@* ODL specification
@T
As an example we now introduce a simple Customer-Order-Product-Price-Item
datamodel. 

\begin{center}
{\epsfxsize=0.60\textwidth
\epsffile{model.eps}
{\em Relationships in the Example Model}}
\end{center}

The model administers a the {\em products} of a company that have 
{\em prices} that fluctuate over time. Old prices are retained, so one
product may have multiple prices. {\em Customers} can place {\em orders}
that consist of a collection of {\em items}. Items are quantities of
ordered products, and orders have a date, and derived from it, a total 
price. Each Price may have a discount Price that is a certain percentage 
lower, which some preferred Customers may get access to. The relationship 
between Customers and Discounts hence is the only n-m relation in the scheme.

@odl
module Example {
  
  atom date { // date 
    constructor ( in int year, in int month, in int day);
    int year();
    int month();
    int day();
    attribute int storage; // implemented as a 4-byte integer 
  };
  
  interface Order;
  interface Price;
  interface Item;
  interface Discount;
  interface Product;
  
  interface Customer (extent Customers key id) { 
    attribute int id;
    attribute string name;    // Customer name
    attribute string address; //  Address for delivery of good
    attribute string city;
    attribute string state;
    attribute string zip;
    attribute string area;
    attribute string phone;
    attribute char gender;
    attribute float creditLimit;
    attribute string comments;
  
    relationship Set<Order> orders inverse Order::customer;
    relationship Set<Discount> discounts inverse Discount::customers;

    Order buy(in Set<Item> items, in date when);
  };
 
  Customer customerId(in string name, in string address, 
                  in string city, in string state);  
  
  interface Product(extent Products keys id) {
    attribute int id;
    attribute string description; 
  
    relationship Set<Price> prices inverse Price::product;
    relationship Set<Item> ordered_items inverse Item::product; 
  };
  
  interface Price(extent Prices keys prodId, startDate) { 
    attribute int prodId; 
    attribute float stdPrice;
    attribute float minPrice; 
    attribute date startDate;
    attribute date endDate; 
  
    relationship Product product inverse Product::prices; 
  };
  
  interface Discount : Price (extent Discounts) {
    attribute float discountPerc;
    relationship Set<Customer> customers inverse Customer::discounts;
  };
  
  interface Order(extent Orders key id) { 
    attribute int id;              // Unique order number 
    attribute date orderDate;      // Date of order
    attribute char commisionPlan;  // Commision plan? 
    attribute date shipDate;       // Ship Date 
    attribute float total;         // Total price to be paid for this order 
  
    relationship Customer customer inverse Customer::orders; 
    relationship Set<Item> items inverse Item::order;
  };
  
  interface Item(extent Items keys orderId, itemNr) { 
    attribute int itemNr;     // Item Nr
    attribute int orderId;    // Order Id 
    attribute int productId;  // Product Id 
    attribute float price;    // Actual price for which the product is sold 
    attribute int quantity;   // Number of products 
    attribute float total;    // Total price of item
  
    relationship Product product inverse Product::ordered_items; 
    relationship Order order inverse Order::items; 
  }; 
};
@ 
We introduced a new atom of size 4-bytes, that will be used to
store dates. It will have to be implemented either in C or C++.
The Java binding will map to this implementation, but you might
overload operations on it in Java code itself.

This document just discusses how the mapping works; implementation
issues of atoms and methods are discussed in the
@[<a hef="app.html">Sample Application Document</a>@. 

@f Example.odl
@* ODMG/C Binding
Binding the object-oriented datamodel from ODL to the abjectly
un-object-oriented C language might sound like a crazy idea, and 
there may be some truth to this.
On the other hand, such a binding provides convenience; programs that
were written in the past in C, or programmers that were educated in the
past, might still be used without modification.
 
@- forward declarations 
@h
@{
#ifndef _Example_H_
#define _Example_H_
@}
#ifdef __cplusplus
extern "C" {
#endif

#include "odmg.h"

@{
typedef struct odExampleMap_t {
        odAttribute Customer_Extent;
        oid  Customer_ClassId[GDKMAXDB];
        struct {
                odAttribute id;
                odAttribute name;
                odAttribute address;
                odAttribute city;
                odAttribute state;
                odAttribute zip;
                odAttribute area;
                odAttribute phone;
                odAttribute gender;
                odAttribute creditLimit;
                odAttribute comments;
                odAttribute orders;
                odAttribute discounts;
        } Customer;
        odAttribute Product_Extent;
        oid  Product_ClassId[GDKMAXDB];
        struct {
                odAttribute id;
                odAttribute description;
                odAttribute prices;
                odAttribute ordered_items;
        } Product;
        odAttribute Price_Extent;
        oid  Price_ClassId[GDKMAXDB];
        struct {
                odAttribute prodId;
                odAttribute stdPrice;
                odAttribute minPrice;
                odAttribute startDate;
                odAttribute endDate;
                odAttribute product;
        } Price;
        odAttribute Discount_Extent;
        oid  Discount_ClassId[GDKMAXDB];
        struct {
                odAttribute discountPerc;
                odAttribute customers;
        } Discount;
        odAttribute Order_Extent;
        oid  Order_ClassId[GDKMAXDB];
        struct {
                odAttribute id;
                odAttribute orderDate;
                odAttribute commisionPlan;
                odAttribute shipDate;
                odAttribute total;
                odAttribute customer;
                odAttribute items;
        } Order;
        odAttribute Item_Extent;
        oid  Item_ClassId[GDKMAXDB];
        struct {
                odAttribute itemNr;
                odAttribute orderId;
                odAttribute productId;
                odAttribute price;
                odAttribute quantity;
                odAttribute total;
                odAttribute product;
                odAttribute order;
        } Item;
} odExampleMap;
odExampleMap odExample_map;
#define getMap() ((odExampleMap*)TMgetMap())
@} 

#define odExampleOrder     odObject
#define odExamplePrice     odObject
#define odExampleItem      odObject
#define odExampleDiscount  odObject
#define odExampleProduct   odObject
#define odExampleCustomer  odObject

@+ date atom
Simple fixed-size atome are generated automatically from ODL.
Internally, Monet will be extended with a new Monet atom by that same name.
It will all happen automatically. But, in order to be able to actually do 
something with the atom, you probably will define some methods on it. 
These you have to implement yourself.
@h
#ifndef __cplusplus
typedef struct {
        int storage;
} date;

extern date  new_date(int *year, int *month, int *day); /* user implemented */
extern int   date_year(date *obj); /* user implemented */
extern int   date_month(date *obj); /* user implemented */
extern int   date_day(date *obj); /* user implemented */
#endif
@
The translator just maps the atom to a flat struct. Methods are
translated to a function call 'atom_method' with a call by reference 
parameter to the atom, followed by any other specified parameters.
Constructors are mapped to a function 'new_atom' that return
a new atomic instance.

@+ Customer interface
@T
ODL interfaces instances are all represented as Pobject in the C binding.
Methods just map to C functions with as a first extra parameter a reference 
to a Pobject. Clashes between function names are avoided by working
with name conventions.

The programmer is supposed to know which kind of Pobject (s)he is 
manipulating, and choose the right generated function calls to call on 
an object. The choice for a method (i.e. function) is explicit, and
consequently {\bf method overloading is broken}. This is a pity, but hardly 
surprising, given that C is not an object-oriented language anyway.

@- Customer creation, destruction 
@T
The first method creates a single new {\tt Customer}, the second
destroys an existing {\tt Customer}.
@h
INLINE odExampleCustomer  odExampleCustomerNEW(odDatabase *d);
INLINE void               odExampleCustomerDESTROY(odExampleCustomer *o);
INLINE odExampleCustomer  odExampleCustomerRENEW(oid obj);
       odSet              odExampleCustomerSET(bool unique);

@- methods
@T
The name Convention of a method 'Method' on an ODL interface 'Interface'
in 'Module' in ODMG/C is the routine 
{\bf ModuleInterface\_Method(Pobject, .. params)}.
@h
extern odExampleOrder odExampleCustomer_buy(odExampleCustomer *obj, odSet * items, date* when);

@T
The above is in ODMG/C what in ODL would simple be notated as: 
\begin{verbatim}
               Example.Customer.buy(items,when)
\end{verbatim}

@- Simulated Inheritance
@T
A {\tt Customer} is a {\tt Pobject}, so we redefine the inherited
method OID() using a \#define.  
@h
#define odExampleCustomerOID(obj) odOID(obj)
#define odExampleCustomerOBJ(obj) odOBJ(obj)

@- Customer attribute accessor functions 
@T
Each attribute is protected by Monet/ODMG by {\bf get() : value}
and {\bf set(value)} accessor functions. This protection ensures
that the logical appearance and physical implementation of the database
are independent, and can be optimized.

The name convention for the generated accessor functions is
{\bf odModuleInterfaceGETattribute}. The first parameter is
always a reference to a {\tt Pobject}.

The GET-function retrieves an attribute value of an object,
whereas the {\bf SET}-functions changes the attribute-value. 
@h
INLINE int  odExampleCustomerGETid(odExampleCustomer* o);
INLINE void odExampleCustomerSETid(odExampleCustomer* o, int* newval);

INLINE str  odExampleCustomerGETname(odExampleCustomer* o);
INLINE void odExampleCustomerSETname(odExampleCustomer* o, str newval);

INLINE str  odExampleCustomerGETaddress(odExampleCustomer* o);
INLINE void odExampleCustomerSETaddress(odExampleCustomer* o, str newval);

INLINE str  odExampleCustomerGETcity(odExampleCustomer* o);
INLINE void odExampleCustomerSETcity(odExampleCustomer* o, str newval);

INLINE str  odExampleCustomerGETstate(odExampleCustomer* o);
INLINE void odExampleCustomerSETstate(odExampleCustomer* o, str newval);

INLINE str  odExampleCustomerGETzip(odExampleCustomer* o);
INLINE void odExampleCustomerSETzip(odExampleCustomer* o, str newval);

INLINE str  odExampleCustomerGETarea(odExampleCustomer* o);
INLINE void odExampleCustomerSETarea(odExampleCustomer* o, str newval);

INLINE str  odExampleCustomerGETphone(odExampleCustomer* o);
INLINE void odExampleCustomerSETphone(odExampleCustomer* o, str newval);

INLINE chr  odExampleCustomerGETgender(odExampleCustomer* o);
INLINE void odExampleCustomerSETgender(odExampleCustomer* o, chr* newval);

INLINE flt  odExampleCustomerGETcreditLimit(odExampleCustomer* o);
INLINE void odExampleCustomerSETcreditLimit(odExampleCustomer* o, flt* newval);

INLINE str  odExampleCustomerGETcomments(odExampleCustomer* o);
INLINE void odExampleCustomerSETcomments(odExampleCustomer* o, str newval);

INLINE odSet  odExampleCustomerGETorders(odExampleCustomer* o);

INLINE odSet  odExampleCustomerGETdiscounts(odExampleCustomer* o);

@T
The Monet/ODMG system uses {\bf by-reference} passing for {\tt odSet}
values. This means that the Set returned by a GET-function can be
modified with the normal update functions of the {\tt odSet} interface (see the 
{\tt @[<a href="stdlib.body.html#mod_1_4_0">Standard Library Reference</a>@). 
{\bf Such updates will change the set-valued attribute in the database 
implicitly.} For this reason, a SET function would be superflluous, 
so it is not generated.

@- Global Function
@h
extern odExampleCustomer odExample_customerId(str name, str address, str city, str state);

@+ Price interface
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_3_2_0" target="_self">Customer Interface</a>@.

@T
As all this code is generated with the @[<a href="odlp.html">ODL parser</a>@,
the mapping of {\tt Price} is very similar to {\tt Customer}.  
The only novelty in this interface is {\bf inheritace}, since Discount
inherits from Price. To see how this is handles in ODMG/C, you might take 
a look at the @[<a href="#mod_3_4_2" target="_self">Discount Interface</a>@
which inherits from {\tt Price}.

@- Price creation, destruction 
@h
INLINE odExamplePrice odExamplePriceNEW(odDatabase *d);
INLINE void           odExamplePriceDESTROY(odExamplePrice *o);
INLINE odExamplePrice odExamplePriceRENEW(oid obj);
       odSet          odExamplePriceSET(bool unique);

@- Simulated Inheritance
@h
#define odExamplePriceOID(obj) odOID(obj)
#define odExamplePriceOBJ(obj) odOBJ(obj)

@- Price attribute accessor functions 
@h
INLINE int  odExamplePriceGETprodId(odExamplePrice* o);
INLINE void odExamplePriceSETprodId(odExamplePrice* o, int* newval);

INLINE flt  odExamplePriceGETstdPrice(odExamplePrice* o);
INLINE void odExamplePriceSETstdPrice(odExamplePrice* o, flt* newval);

INLINE flt  odExamplePriceGETminPrice(odExamplePrice* o);
INLINE void odExamplePriceSETminPrice(odExamplePrice* o, flt* newval);

INLINE date odExamplePriceGETstartDate(odExamplePrice* o);
INLINE void odExamplePriceSETstartDate(odExamplePrice* o, date* newval);

INLINE date odExamplePriceGETendDate(odExamplePrice* o);
INLINE void odExamplePriceSETendDate(odExamplePrice* o, date* newval);

INLINE odExampleProduct
            odExamplePriceGETproduct(odExamplePrice* o);
INLINE void odExamplePriceSETproduct(odExamplePrice* o, odExampleProduct* newval);

@+ Discount interface
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_3_2_0" target="_self">Customer Interface</a>@,
though you might look at the 
@[<a href="#mod_3_4_2" target="_self">subsection on inheritance</a>@,
as Discount inherits from Price.

@- Discount creation, destruction 
@h
INLINE odExampleDiscount odExampleDiscountNEW(odDatabase *d);
INLINE void              odExampleDiscountDESTROY(odExampleDiscount *o);
INLINE odExampleDiscount odExampleDiscountRENEW(oid obj);
       odSet             odExampleDiscountSET(bool unique);

@- Simulated Inheritance
@T
As a {\tt Discount} is a {\tt Price}, the system generates 
defines that make all accessor functions on {\tt Price} available under
the {\tt Discount} names as well.
@h
#define odExampleDiscountOID(obj) odOID(obj)
#define odExampleDiscountOBJ(obj) odOBJ(obj)

#define odExampleDiscountGETprodId    odExamplePriceGETprodId
#define odExampleDiscountSETprodId    odExamplePriceSETprodId
#define odExampleDiscountGETstdPrice  odExamplePriceGETstdPrice
#define odExampleDiscountSETstdPrice  odExamplePriceSETstdPrice
#define odExampleDiscountGETminPrice  odExamplePriceGETminPrice
#define odExampleDiscountSETminPrice  odExamplePriceSETminPrice
#define odExampleDiscountGETstartDate odExamplePriceGETstartDate
#define odExampleDiscountSETstartDate odExamplePriceSETstartDate
#define odExampleDiscountGETendDate   odExamplePriceGETendDate
#define odExampleDiscountSETendDate   odExamplePriceSETendDate
#define odExampleDiscountGETproduct   odExamplePriceGETproduct
#define odExampleDiscountSETproduct   odExamplePriceSETproduct

@- Discount attribute accessor functions 
@h
INLINE flt  odExampleDiscountGETdiscountPerc(odExampleDiscount* o);
INLINE void odExampleDiscountSETdiscountPerc(odExampleDiscount* o, flt* newval);

INLINE odSet  odExampleDiscountGETcustomers(odExampleDiscount* o);

@+ Product interface
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_3_2_0" target="_self">Customer Interface</a>@.

@- Product creation, destruction 
@h
INLINE odExampleProduct  odExampleProductNEW(odDatabase *d);
INLINE void              odExampleProductDESTROY(odExampleProduct *o);
INLINE odExampleProduct  odExampleProductRENEW(oid obj);
       odSet             odExampleProductSET(bool unique);

@- Simulated Inheritance
@h
#define odExampleProductOID(obj) odOID(obj)
#define odExampleProductOBJ(obj) odOBJ(obj)

@- Product attribute accessor functions
@h
INLINE int   odExampleProductGETid(odExampleProduct* o);
INLINE void  odExampleProductSETid(odExampleProduct* o, int* newval);

INLINE str   odExampleProductGETdescription(odExampleProduct* o);
INLINE void  odExampleProductSETdescription(odExampleProduct* o, str newval);

INLINE odSet odExampleProductGETprices(odExampleProduct* o);

INLINE odSet odExampleProductGETordered_items(odExampleProduct* o);

@+ Order Interface
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_3_2_0" target="_self">Customer Interface</a>@.

@- Order creation, destruction 
@h
INLINE odExampleOrder odExampleOrderNEW(odDatabase *d);
INLINE void           odExampleOrderDESTROY(odExampleOrder *o);
INLINE odExampleOrder odExampleOrderRENEW(oid obj);
       odSet          odExampleOrderSET(bool unique);

@- Simulated Inheritance
@h
#define odExampleOrderOID(obj) odOID(obj)
#define odExampleOrderOBJ(obj) odOBJ(obj)

@- Order attribute accessor functions 
@h
INLINE int   odExampleOrderGETid(odExampleOrder* o);
INLINE void  odExampleOrderSETid(odExampleOrder* o, int* newval);

INLINE date  odExampleOrderGETorderDate(odExampleOrder* o);
INLINE void  odExampleOrderSETorderDate(odExampleOrder* o, date* newval);

INLINE chr   odExampleOrderGETcommisionPlan(odExampleOrder* o);
INLINE void  odExampleOrderSETcommisionPlan(odExampleOrder* o, chr* newval);

INLINE date  odExampleOrderGETshipDate(odExampleOrder* o);
INLINE void  odExampleOrderSETshipDate(odExampleOrder* o, date* newval);

INLINE flt   odExampleOrderGETtotal(odExampleOrder* o);
INLINE void  odExampleOrderSETtotal(odExampleOrder* o, flt* newval);

INLINE odExampleCustomer
             odExampleOrderGETcustomer(odExampleOrder* o);
INLINE void  odExampleOrderSETcustomer(odExampleOrder* o, odExampleCustomer* newval);

INLINE odSet odExampleOrderGETitems(odExampleOrder* o);

@+ Item interface
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_3_2_0" target="_self">Customer Interface</a>@.

@- Item creation, destruction
@h
INLINE odExampleItem odExampleItemNEW(odDatabase *d);
INLINE void          odExampleItemDESTROY(odExampleItem *o);
INLINE odExampleItem odExampleItemRENEW(oid obj);
       odSet         odExampleItemSET(bool unique);

@- Simulated Inheritance
@h
#define odExampleItemOID(obj) odOID(obj)
#define odExampleItemOBJ(obj) odOBJ(obj)

@- Item attribute accessor functions 
@h
INLINE int  odExampleItemGETitemNr(odExampleItem* o);
INLINE void odExampleItemSETitemNr(odExampleItem* o, int* newval);

INLINE int  odExampleItemGETorderId(odExampleItem* o);
INLINE void odExampleItemSETorderId(odExampleItem* o, int* newval);

INLINE int  odExampleItemGETproductId(odExampleItem* o);
INLINE void odExampleItemSETproductId(odExampleItem* o, int* newval);

INLINE flt  odExampleItemGETprice(odExampleItem* o);
INLINE void odExampleItemSETprice(odExampleItem* o, flt* newval);

INLINE int  odExampleItemGETquantity(odExampleItem* o);
INLINE void odExampleItemSETquantity(odExampleItem* o, int* newval);

INLINE flt  odExampleItemGETtotal(odExampleItem* o);
INLINE void odExampleItemSETtotal(odExampleItem* o, flt* newval);

INLINE odExampleProduct
            odExampleItemGETproduct(odExampleItem* o);
INLINE void odExampleItemSETproduct(odExampleItem* o, odExampleProduct* newval);

INLINE odExampleOrder 
            odExampleItemGETorder(odExampleItem* o);
INLINE void odExampleItemSETorder(odExampleItem* o, odExampleOrder* newval);

@{
extern int odInitExample(int *dbp);
@}
#ifdef __cplusplus
}
#endif
@{
#endif
@} 

@f Example
@* C implementation

The external declared functions for the atom and the ODL methods should be
implemented in C code.

@c

#include "Example_odl.h"

typedef struct MT {
	unsigned short ym; /* 12b-year, 4b-month, */
	unsigned short dhm; /* 5b-day, 5b-hour, 6b-min */
} MonetTime;

#define MAKEYEAR(year, month) ((year<<4)+month)
#define MAKEDAY(day, hour, min) ((((day<<5)+hour)<<6)+min)

#define GETYEAR(mt)	((mt).ym>>4)
#define GETMONTH(mt)	((mt).ym&0xF)
#define GETDAY(mt)	(((mt).dhm>>11)&0x1F)

static int nodays[]={ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

date new_date(int *year, int *month, int *day) {

   MonetTime theVal;
   date theDate;

   int left = 0;
   if (*day > nodays[*month-1]) {
      left = *day / nodays[*month-1];
      *day = *day % nodays[*month-1];
   }
   *month = *month + left;
   left = 0;
   if (*month > 12) {
      left = *month / 12;
      *month = *month % 12;
   }
   *year = *year + left;

   theVal.ym = MAKEYEAR(*year, *month);
   theVal.dhm = MAKEDAY(*day, 0, 0 );

   theDate.storage = *(int*)&theVal;   

   return theDate;
	
}

int date_year(date *obj) {

   return GETYEAR(*(MonetTime*)&(obj->storage));

}

int date_month(date *obj) {

   return  GETMONTH(*(MonetTime*)&(obj->storage));

}

int date_day(date *obj) {

   return GETDAY(*(MonetTime*)&(obj->storage));

}

odExampleCustomer odExample_customerId(str name, str address, str city, str state) {

	odDatabase *database = &odDB;

	odSet customers = odDatabaseLOOKUP(database,"Customers");

	odExampleCustomer f;
	odExampleCustomer c;
	int found = FALSE;
	int maxId = 0;

	odIterator it = odSetITERATOR(&customers,TRUE);
	while(odIteratorNEXTOBJ(&it,&c)) {

		if (odExampleCustomerGETid(&c) > maxId)
			maxId = odExampleCustomerGETid(&c);

		if (strcmp("",name)!=0)
			if (strcmp(odExampleCustomerGETname(&c),name)!=0)
				continue;

		if (strcmp("",address)!=0)
			if (strcmp(odExampleCustomerGETaddress(&c),address)!=0)
				continue;

		if (strcmp("",city)!=0)
			if (strcmp(odExampleCustomerGETcity(&c),city)!=0)
				continue;

		if (strcmp("",state)!=0)
			if (strcmp(odExampleCustomerGETstate(&c),state)!=0)
				continue;

		f = c;
		found = TRUE;
		break;

	}
	odIteratorCLOSE(&it);

	maxId++;
	
	if (!found) {
		f = odExampleCustomerNEW(database);
		odExampleCustomerSETid(&f,&maxId);
		odExampleCustomerSETname(&f,name);
		odExampleCustomerSETaddress(&f,address);
		odExampleCustomerSETcity(&f,city);
		odExampleCustomerSETstate(&f,state);
	}
	
	return f;

}

odExampleOrder odExampleCustomer_buy(odExampleCustomer *obj, odSet * items, date* when) {

	odDatabase *database = &odDB;

	odExampleOrder o;
	odExampleItem i;
	odSet oItems;

	odSet orders = odDatabaseLOOKUP(database,"Orders");

	int maxId = 0;

	odIterator it = odSetITERATOR(&orders,TRUE);
	while(odIteratorNEXTOBJ(&it,&o)) {

		if (odExampleOrderGETid(&o) > maxId) {
			maxId = odExampleOrderGETid(&o);
		}

	}
	odIteratorCLOSE(&it);

	maxId++;

	o = odExampleOrderNEW(database);
	odExampleOrderSETid(&o,&maxId);
	odExampleOrderSETcustomer(&o,obj);
	odExampleOrderSETorderDate(&o,when);
	oItems = odExampleOrderGETitems(&o);

	it = odSetITERATOR(items,FALSE);
	while(odIteratorNEXTOBJ(&it,&i)) {

		odExampleItemSETorderId(&i,&maxId);
		odSetINSERT(&oItems,&i);

	}
	odIteratorCLOSE(&it);

	return o;

}

@f Example
@* ODMG/C++ Language Mapping 

C++ is an object-oriented language to which the ODMG model can be
mapped neatly. It has objects, inheritance, methods, and even provides
templates. In many cases, a simple 1-1 mapping between Monet/ODMG and 
C++ was possible. ODMG interfaces map on classes. Attributes are
handles throug accessor methods, ODMG methods are just class methods.
Interface inheritance in ODL maps to class inheritance in C++, and even
templates are used for collection types (e.g. Set<Type>).

@- forward definitions
The Monet/ODMG C++ implementation is internally based on the C 
implementation. The C++ specific parts are protected with 
defines.

@h
@{
#ifndef _CC_Example_H_
#define _CC_Example_H_
@}

#ifdef __cplusplus
#include "CC_odmg.h"

class Order;
class Price;
class Item;
class Discount;
class Product;
class Customer;

@+ date atom
Automatically generated atomic types in C++ map to a class rather
than a C struct. The mapping of the methods and constructor from
ODL to C++ is just natural. But of course, the user still has to 
implement these methods by hand..
@h
class date{
    public:
	date(const int  year, const int  month, const int  day);
	virtual int  year();
	virtual int  month();
	virtual int  day();
int  storage;
};

@+ Customer interface
@T
New {\tt Customer} objects can be created using a C++ constructor.
Two {\bf accessor-methods}  for reading and writing attribute values
are generated for each attribute. Only Set-valued attributes have only
the get-methods; as the sets are passed by reference and can be modified 
with the {\tt Set} interface (see the 
@[<a href="stdlib.body.html#mod_1_4_0">Standard Library Reference</a>@). 
These modifications of {\tt Set} values, hence can
cause implicit modifications to the stored database.
@h
class Customer : public  Pobject{
    public:
	Customer(){}
	Customer( odObject od );

	void *operator new( size_t size );
	void *operator new( size_t size, Database &db );
	virtual void destroy();
	virtual Pobject     *clone( odObject odVal ) const;
	virtual odlAttribute extent();
	virtual oid          *classid();
	static odlAttribute Extent();
	static oid          *Classid();
	static Set<Customer>        Customers();
	void id( const int  value);
	int  id() const;
	static odlAttribute _id();

	void name( const str value);
	str name() const;
	static odlAttribute _name();

	void address( const str value);
	str address() const;
	static odlAttribute _address();

	void city( const str value);
	str city() const;
	static odlAttribute _city();

	void state( const str value);
	str state() const;
	static odlAttribute _state();

	void zip( const str value);
	str zip() const;
	static odlAttribute _zip();

	void area( const str value);
	str area() const;
	static odlAttribute _area();

	void phone( const str value);
	str phone() const;
	static odlAttribute _phone();

	void gender( const char  value);
	char  gender() const;
	static odlAttribute _gender();

	void creditLimit( const float  value);
	float  creditLimit() const;
	static odlAttribute _creditLimit();

	void comments( const str value);
	str comments() const;
	static odlAttribute _comments();

	Set<Order>& orders() const;
	static odlAttribute _orders();

	Set<Discount>& discounts() const;
	static odlAttribute _discounts();

	virtual Order  buy(const Set<Item> &items, const date  &when);
};

@- Global Method
Global methods are just like C/C++ routines. Just like methods, they
should be implemented by the user.
@h
Customer  customerId(const str name, const str address, const str city, const str state);

@+ Price interface
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_4_2_0" target="_self">Customer Interface</a>@.

@h
class Price : public  Pobject{
    public:
	Price(){}
	Price( odObject od );

	void *operator new( size_t size );
	void *operator new( size_t size, Database &db );
	virtual void destroy();
	virtual Pobject     *clone( odObject odVal ) const;
	virtual odlAttribute extent();
	virtual oid          *classid();
	static odlAttribute Extent();
	static oid          *Classid();
	static Set<Price>        Price();
	void prodId( const int  value);
	int  prodId() const;
	static odlAttribute _prodId();

	void stdPrice( const float  value);
	float  stdPrice() const;
	static odlAttribute _stdPrice();

	void minPrice( const float  value);
	float  minPrice() const;
	static odlAttribute _minPrice();

	void startDate( const date & value);
	date & startDate() const;
	static odlAttribute _startDate();

	void endDate( const date & value);
	date & endDate() const;
	static odlAttribute _endDate();

	void product( const Product & value);
	Product & product() const;
	static odlAttribute _product();

};
@+ Discount interface
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_4_2_0" target="_self">Customer Interface</a>@.

@h
class Discount : public Price{
    public:
	Discount(){}
	Discount( odObject od );

	void *operator new( size_t size );
	void *operator new( size_t size, Database &db );
	virtual void destroy();
	virtual Pobject     *clone( odObject odVal ) const;
	virtual odlAttribute extent();
	virtual oid          *classid();
	static odlAttribute Extent();
	static oid          *Classid();
	static Set<Discount>        Discounts();
	void discountPerc( const float  value);
	float  discountPerc() const;
	static odlAttribute _discountPerc();

	Set<Customer>& customers() const;
	static odlAttribute _customers();

};
@+ Product interface
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_4_2_0" target="_self">Customer Interface</a>@.

@h
class Product : public  Pobject{
    public:
	Product(){}
	Product( odObject od );

	void *operator new( size_t size );
	void *operator new( size_t size, Database &db );
	virtual void destroy();
	virtual Pobject     *clone( odObject odVal ) const;
	virtual odlAttribute extent();
	virtual oid          *classid();
	static odlAttribute Extent();
	static oid          *Classid();
	static Set<Product>        Products();
	void id( const int  value);
	int  id() const;
	static odlAttribute _id();

	void description( const str value);
	str description() const;
	static odlAttribute _description();

	Set<Price>& prices() const;
	static odlAttribute _prices();

	Set<Item>& ordered_items() const;
	static odlAttribute _ordered_items();

};

@+ Order interface
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_4_2_0" target="_self">Customer Interface</a>@.

@h
class Order : public  Pobject{
    public:
	Order(){}
	Order( odObject od );

	void *operator new( size_t size );
	void *operator new( size_t size, Database &db );
	virtual void destroy();
	virtual Pobject     *clone( odObject odVal ) const;
	virtual odlAttribute extent();
	virtual oid          *classid();
	static odlAttribute Extent();
	static oid          *Classid();
	static Set<Order>        Orders();
	void id( const int  value);
	int  id() const;
	static odlAttribute _id();

	void orderDate( const date & value);
	date & orderDate() const;
	static odlAttribute _orderDate();

	void commisionPlan( const char  value);
	char  commisionPlan() const;
	static odlAttribute _commisionPlan();

	void shipDate( const date & value);
	date & shipDate() const;
	static odlAttribute _shipDate();

	void total( const float  value);
	float  total() const;
	static odlAttribute _total();

	void customer( const Customer & value);
	Customer & customer() const;
	static odlAttribute _customer();

	Set<Item>& items() const;
	static odlAttribute _items();

};

@+ Item interface
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_4_2_0" target="_self">Customer Interface</a>@.

@h
class Item : public  Pobject{
    public:
	Item(){}
	Item( odObject od );

	void *operator new( size_t size );
	void *operator new( size_t size, Database &db );
	virtual void destroy();
	virtual Pobject     *clone( odObject odVal ) const;
	virtual odlAttribute extent();
	virtual oid          *classid();
	static odlAttribute Extent();
	static oid          *Classid();
	static Set<Item>        Items();
	void itemNr( const int  value);
	int  itemNr() const;
	static odlAttribute _itemNr();

	void orderId( const int  value);
	int  orderId() const;
	static odlAttribute _orderId();

	void productId( const int  value);
	int  productId() const;
	static odlAttribute _productId();

	void price( const float  value);
	float  price() const;
	static odlAttribute _price();

	void quantity( const int  value);
	int  quantity() const;
	static odlAttribute _quantity();

	void total( const float  value);
	float  total() const;
	static odlAttribute _total();

	void product( const Product & value);
	Product & product() const;
	static odlAttribute _product();

	void order( const Order & value);
	Order & order() const;
	static odlAttribute _order();

};

@{
extern "C" {
extern void CCodInitExample(int *db );

}
#endif
#endif //_CC_Example_H_
@} 

@f Example
@* C++ implementation

The virtual declared functions for the atom and the ODL methods should be
implemented in C++ code.

@

#include "Example_odl.h"

struct MonetTime {
	unsigned short ym; // 12b-year, 4b-month, 
	unsigned short dhm; // 5b-day, 5b-hour, 6b-min
};

#define MAKEYEAR(year, month) ((year<<4)+month)
#define MAKEDAY(day, hour, min) ((((day<<5)+hour)<<6)+min)

#define GETYEAR(mt)	((mt).ym>>4)
#define GETMONTH(mt)	((mt).ym&0xF)
#define GETDAY(mt)	(((mt).dhm>>11)&0x1F)

static int nodays[]={ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

date::date(const int year, const int month, const int day) {

   MonetTime theVal;

   int _year = year;
   int _month = month;
   int _day = day;

   int left = 0;
   if (_day > nodays[_month-1]) {
      left = _day / nodays[_month-1];
      _day = _day % nodays[_month-1];
   }
   _month = _month + left;
   left = 0;
   if (_month > 12) {
      left = _month / 12;
      _month = _month % 12;
   }
   _year = _year + left;

   theVal.ym = MAKEYEAR(_year, _month);
   theVal.dhm = MAKEDAY(_day, 0, 0 );

   storage = *(int*)&theVal;   
	
};

int date::year() {

   return GETYEAR(*(MonetTime*)&storage);

};

int date::month() {

   return  GETMONTH(*(MonetTime*)&storage);

};

int date::day() {

   return GETDAY(*(MonetTime*)&storage);

};

Customer &customerId(const str name,const str address,const str city,const str state) {

	Set<Customer> customers;

	database->lookup(customers, "Customers");
   
	Ref<Customer> c;
	int found = FALSE;
	int maxId = 0;

	Iterator<Customer> &it = customers.iterator(TRUE);
	while(it.next(c)) {

		if (c->id() > maxId)
			maxId = c->id();

		if (strcmp(name,"")!=0)
			if (strcmp(c->name(),name)!=0)
				continue;

      		if (strcmp(address,"")!=0)
			if (strcmp(c->address(),address)!=0)
			  continue;

      		if (strcmp(city,"")!=0)
			if (strcmp(c->city(),city)!=0)
	  			continue;

      		if (strcmp(state,"")!=0)
			if (strcmp(c->state(),state)!=0)
				continue;

		found = TRUE;
		break;

	}
	delete &it;

	maxId++;

	if (!found) {
		c = new (*database) Customer;
		c->id(maxId);
		c->name(name);
		c->address(address);
		c->city(city);
		c->state(state);
	}
	
	return c.getValue();

};

Order &Customer::buy(const Set<Item> &items, const date  &when) {

	Ref<Order> o;
	Ref<Item> i;

	Set<Order> orders;
	Set<Item> oItems;

	int maxId = 0;

	database->lookup(orders, "Orders");

	Iterator<Order> &it1 = orders.iterator(TRUE);
	while(it1.next(o)) {
      
		if (o->id() > maxId)
			maxId = o->id();

	}
	delete &it1;

	maxId++;

	o = new (*database) Order();
	o->id(maxId);
	o->customer(*this);
	o->orderDate(when);
	oItems = o->items();

	Iterator<Item> &it2 = oItems.iterator(TRUE);
	while(it2.next(i)) {

		i->orderId(maxId);
		oItems.insert(*i);

	}
	delete &it2;

	return o.getValue();
}

@* ODMG/Java Binding
@T
The ODMG1.X  binding supports the concept of multiple-inheritance between 
interfaces and Monet/ODMG supports this feauture as well. Maybe the most 
natural way to map an interface directly would have been to map it to a 
Java Class.  The problem is that Java does not support multiple inheritance 
between classes.

The general solution to this, also applied e.g. in 
@[<a href="http://www.omg.org">CORBA/Java</a>@, is to use interfaces, as multiple 
inheritance {\bf is} supported for Java interfaces. 
Interfaces in Java define a set of methods; a common behaviour between
objects. Objects -- that is, instances of a class -- can implement
multiple such interfaces.

Thus, we map Monet/ODMG interfaces 1-1 onto Java interfaces. 
As all attributes in Monet/ODMG are protected by two {\bf attribute-accessor} 
methods, Monet/ODMG interfaces in fact only have methods
(i.e. no real value-attributes) so this mapping is possible.

Besides the interface-hierarchy, the @[<a href="man/odlp.html">ODL parser</a>@
generates for each interface an {\bf implementation class} with which
specific object instances can be generated. They are are named
{\tt interfaceImp} and are just used when a new object has to be created,
for instance:
\begin{verbatim}
                new CustomerImp(); 
\end{verbatim}

Note that Java wants each interface and class in a specific file, so 
the @[<a href="man/odlp.html">ODL parser</a>@ generates multiple output files. 
We will now discuss them in turn.

@f Module
@+ Example Module 
@T
All generated java files belonging to some ODL module, will lead
to a java package 'module'. One central class {\bf moduleModule} is 
generated that is used in the Monet/ODMG system for administration and
initialisation purposes. 

This module also serves to capture any defined global methods in the
ODL module, which otherwise would have no place in any other java class.
@f Example/Module
@java
package Example;
@{
import java.io.*;
@}

public class Module implements odmg.Module {
@{
	public final static String modName = "Example";

	public final static odmg.Pobject classes[] = {
		new CustomerImp(0, false, false),
		new ProductImp(0, false, false),
		new PriceImp(0, false, false),
		new DiscountImp(0, false, false),
		new OrderImp(0, false, false),
		new ItemImp(0, false, false)
	};

	public final static odmg.Atom atoms[] = {
		new dateAtom()
	};

	public String getModName() {
		return modName;
	}

	public odmg.Pobject[] getClasses() {
		return classes;
	}

	public odmg.Atom[] getAtoms() {
		return atoms;
	} @}

	public Customer customerId(odmg.StringValue name, odmg.StringValue address, odmg.StringValue city, odmg.StringValue state) throws odmg.RpcException 
	//IMPLEMENTATION OMITTED @{ { 
		odmg.ParamList _p = new odmg.ParamList();
		_p.add(name);
		_p.add(address);
		_p.add(city);
		_p.add(state);
		return (Customer)odmg.Database.getDb().rpc("customerId", _p, CustomerImp.classID, false);
	} @}
};

@f Example/dateAtom
@+ Atom date
@T
New atomic types can be added on the fly to the Monet/ODMG system.
These Atoms are captured in a generic way in ODMG/Java in the 
@[<a href="jOdmg/odmg.Atom.html">odmg.Atom</a>@ class.
This class treats atoms just as blobs (byte-arrays). It does not
know any of its semantics. It also provides handy operations
to extract standard types from substrings of the byte-array.

For each new atom the @[<a href="man/odlp.html">ODL parser</a>@ generates 
a subclass of Atom, that is named {\tt atomAtom}, like below for 'date':
@f Example/dateAtom
@java
package Example;
@{
import java.io.*;
@}

public class dateAtom extends odmg.FixedAtom {

	public static byte classID = 0; @{

	public dateAtom() {
		super(4);
	}

	public dateAtom(byte[] bytes) {
		super(bytes);
	}

	public dateAtom(odmg.Atom a, int offset, int size) {
		super(a,offset,size);
	}

	public void setClassID(byte classID) {
		this.classID = classID;
	}

	public byte getClassID() {
		return classID;
	}

	public odmg.Atom newInstance(odmg.Atom a, int offset) {
		return new dateAtom(a,offset,4);
	} @}

	public dateAtom (odmg.IntValue year, odmg.IntValue month, odmg.IntValue day) throws odmg.RpcException @{ {
		super(1);
		odmg.ParamList _p = new odmg.ParamList();
		_p.add(year);
		_p.add(month);
		_p.add(day);
		dateAtom obj = (dateAtom)db.rpc("date_new", _p, dateAtom.classID, false );
		data = obj.data;
	} @}

	public odmg.IntValue year() throws odmg.RpcException @{ { 
		odmg.ParamList _p = new odmg.ParamList();
		_p.add(this);
		return (odmg.IntValue)db.rpc("date_year", _p, odmg.IntValue.classID, false);
	} @}

	public odmg.IntValue month() throws odmg.RpcException @{ { 
		odmg.ParamList _p = new odmg.ParamList();
		_p.add(this);
		return (odmg.IntValue)db.rpc("date_month", _p, odmg.IntValue.classID, false);
	} @}

	public odmg.IntValue day() throws odmg.RpcException @{ { 
		odmg.ParamList _p = new odmg.ParamList();
		_p.add(this);
		return (odmg.IntValue)db.rpc("date_day", _p, odmg.IntValue.classID, false);
	} @}
}
@T
Atoms have an inner state that can only accessed by methods. The 
implementation of these methods leans on either the ODMG/C or the ODMG/C++ 
implementation that you must also provide. As the ODMG/Java operates
in a distributed setting, this means that whenever you invoke a method
on an atom, it is first transported back to the central Monet server,
there the ODMG/C or ODMG/C++  method is invoked on it, and you get back 
a result. 

You might want to optimize this, by refining the {\bf dateAtom} class 
with {\bf date} subclass, and reimplementing (some) methods in this
subclass in Java. This technique is discussed in detail in
the @[<a href="app.html">Example Application Document</a>.  
This translation must be done by hand, since only the application programmer 
knows the semantics of his methods.


@f Example/Customer
@+ Customer 
@T
The Customer interface just decribes which operations are valid on a Customer.
Multiple inheritance between interfaces is possible, so ODMG inheritance
naturally maps onto Java interface inheritance.

Note that the {\bf accessor-methods} generated for each ODMG interface 
attribute are part of this Java interface.
@f Example/Customer
@java
package Example;
@{
import java.io.*;
@}

public interface Customer  extends odmg.Value {

	public void destroy();

	public void invalidate();
	// Data member accessors

	int  id();
	void id(int  value);

	String  name();
	void name(String  value);

	String  address();
	void address(String  value);

	String  city();
	void city(String  value);

	String  state();
	void state(String  value);

	String  zip();
	void zip(String  value);

	String  area();
	void area(String  value);

	String  phone();
	void phone(String  value);

	char  gender();
	void gender(char  value);

	float  creditLimit();
	void creditLimit(float  value);

	String  comments();
	void comments(String  value);

	odmg.OidSet orders();

	odmg.OidSet discounts();

@T
Just like in ODMG/C and ODMG/C++, set-valued attributes do not need
a put-methods, as you can retrieve set-values with the get-method.
Because sets are passed {\bf by-reference}, you can use the set update
functions from the {\tt Set} interface (see the 
{\tt @[<a href="stdlib.body.html#mod_1_4_0">Standard Library Reference</a>@) 
to modify such values.

@- method
@T
This method leans on an ODMG/C or ODMG/C++ implementation
(it does a RPC with the Monet server).
That means that you must run the ODL model through the
parser either with @[<a href="man/odlp.html">odl -c</a>@  or
@[<a href="man/odlp.html">odl -C</a>@ and implement the method
in ODMG/C resp. ODMG/C++. Both implementation and generated parts 
must then be compiled and linked into a shared object {\bf module.so}
that is placed in the MONETHOME/lib directory. 
This process is described in the @[<a href="man/odlp.html">ODL Parser Manual Page</a>@
and in the @[<a href="app.html">Example Application Document</a>@.

All this will add an extension module to the Monet server, which has to 
be running with the module loaded. Only then will the ODMG/Java methods work. 
If not, the system will throw an {\tt odmg.RpcException} in your face. 
@f Example/Customer
@java
	public Order buy(odmg.OidSet items, dateAtom when) throws odmg.RpcException;
}
@

@f Example/CustomerImp
@- Implementation Class
@T
The {\em implementation-class} named {\tt CustomerImp} serves
to create specific Customer objects that implement the 
{\tt Customer} interface. They only come into play when
a new instance of an object has to be created, so we show
only the constructor method.

The implementation of all methods of the {\tt Customer}
interface has been omitted for readability.

@f Example/CustomerImp
@java
public class CustomerImp extends odmg.Pobject implements Customer {

	//IMPLEMENTATION OMITTED @{

	public static byte classID = 0;

	static odmg.ClassCache	cache;

	static odmg.Extent		extent;

	/**
	 * Create a new CustomerImp object. The (generated) oid will be 
	 * send to the database during commit
	 */
	public CustomerImp() {
		this(db.newOid(), true, true);
	}

	public CustomerImp(int oid) {
		this(oid, true, true);
	}

	/**
	 * Not available to the user of the odmg package
	 */
	CustomerImp(int oid, boolean dirty, boolean inExtent) {
		super(oid);
		if (inExtent){
			CustomerImp.extent.put(this, dirty);
		}
	}

	public void destroy() {
		CustomerImp.extent.remove(this);
		cache.remove(this);
	}

	/**
	 * 'newInstance' is used to create new Objects from oids in the cache 
	 * These objects will not be sendto the server during a commit
	 */
	public odmg.Pobject newInstance(int oid) {
		odmg.Pobject result;

		if ((result = extent.get(oid)) == null)
		    result = new CustomerImp(oid, false, true);

		return result;
	}

	public void invalidate() {
		cache.remove(this);
	}

	public void setClassID(byte classID) {
		this.classID = classID;
	}

	public byte getClassID() {
		return classID;
	}

	public static odmg.OidSet createSet() {
		return new odmg.OidSet(classID);
	}

	public void id(Integer  value) {
		Hash_id.change(this,new odmg.IntValue(value));
		db.writeThrough( cmd + "(" + value + ")"  );
	}

	public Integer  id(){
		odmg.IntValue result = (odmg.IntValue)Hash_id.get(OID);

		if (result == null) {
			db.fetch(Attr_id, OID);
			result = (odmg.IntValue)Hash_id.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_id;
	static odmg.Attribute	Attr_id;

	public void name(String  value) {
		Hash_name.change(this,new odmg.StringValue(value));
	}

	public String  name(){
		odmg.StringValue result = (odmg.StringValue)Hash_name.get(OID);

		if (result == null) {
			db.fetch(Attr_name, OID);
			result = (odmg.StringValue)Hash_name.get(OID);
		}
		return (result.isNil() ? null : result.stringValue());
	}


	static odmg.HashTab		Hash_name;
	static odmg.Attribute	Attr_name;

	public void address(String  value) {
		Hash_address.change(this,new odmg.StringValue(value));
	}

	public String  address(){
		odmg.StringValue result = (odmg.StringValue)Hash_address.get(OID);

		if (result == null) {
			db.fetch(Attr_address, OID);
			result = (odmg.StringValue)Hash_address.get(OID);
		}
		return (result.isNil() ? null : result.stringValue());
	}


	static odmg.HashTab		Hash_address;
	static odmg.Attribute	Attr_address;

	public void city(String  value) {
		Hash_city.change(this,new odmg.StringValue(value));
	}

	public String  city(){
		odmg.StringValue result = (odmg.StringValue)Hash_city.get(OID);

		if (result == null) {
			db.fetch(Attr_city, OID);
			result = (odmg.StringValue)Hash_city.get(OID);
		}
		return (result.isNil() ? null : result.stringValue());
	}


	static odmg.HashTab		Hash_city;
	static odmg.Attribute	Attr_city;

	public void state(String  value) {
		Hash_state.change(this,new odmg.StringValue(value));
	}

	public String  state(){
		odmg.StringValue result = (odmg.StringValue)Hash_state.get(OID);

		if (result == null) {
			db.fetch(Attr_state, OID);
			result = (odmg.StringValue)Hash_state.get(OID);
		}
		return (result.isNil() ? null : result.stringValue());
	}


	static odmg.HashTab		Hash_state;
	static odmg.Attribute	Attr_state;

	public void zip(String  value) {
		Hash_zip.change(this,new odmg.StringValue(value));
	}

	public String  zip(){
		odmg.StringValue result = (odmg.StringValue)Hash_zip.get(OID);

		if (result == null) {
			db.fetch(Attr_zip, OID);
			result = (odmg.StringValue)Hash_zip.get(OID);
		}
		return (result.isNil() ? null : result.stringValue());
	}


	static odmg.HashTab		Hash_zip;
	static odmg.Attribute	Attr_zip;

	public void area(String  value) {
		Hash_area.change(this,new odmg.StringValue(value));
	}

	public String  area(){
		odmg.StringValue result = (odmg.StringValue)Hash_area.get(OID);

		if (result == null) {
			db.fetch(Attr_area, OID);
			result = (odmg.StringValue)Hash_area.get(OID);
		}
		return (result.isNil() ? null : result.stringValue());
	}


	static odmg.HashTab		Hash_area;
	static odmg.Attribute	Attr_area;

	public void phone(String  value) {
		Hash_phone.change(this,new odmg.StringValue(value));
	}

	public String  phone(){
		odmg.StringValue result = (odmg.StringValue)Hash_phone.get(OID);

		if (result == null) {
			db.fetch(Attr_phone, OID);
			result = (odmg.StringValue)Hash_phone.get(OID);
		}
		return (result.isNil() ? null : result.stringValue());
	}


	static odmg.HashTab		Hash_phone;
	static odmg.Attribute	Attr_phone;

	public void gender(Integer  value) {
		Hash_gender.change(this,new odmg.CharValue(value));
	}

	public Integer  gender(){
		odmg.CharValue result = (odmg.CharValue)Hash_gender.get(OID);

		if (result == null) {
			db.fetch(Attr_gender, OID);
			result = (odmg.CharValue)Hash_gender.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_gender;
	static odmg.Attribute	Attr_gender;

	public void creditLimit(Float  value) {
		Hash_creditLimit.change(this,new odmg.FloatValue(value));
	}

	public Float  creditLimit(){
		odmg.FloatValue result = (odmg.FloatValue)Hash_creditLimit.get(OID);

		if (result == null) {
			db.fetch(Attr_creditLimit, OID);
			result = (odmg.FloatValue)Hash_creditLimit.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_creditLimit;
	static odmg.Attribute	Attr_creditLimit;

	public void comments(String  value) {
		Hash_comments.change(this,new odmg.StringValue(value));
	}

	public String  comments(){
		odmg.StringValue result = (odmg.StringValue)Hash_comments.get(OID);

		if (result == null) {
			db.fetch(Attr_comments, OID);
			result = (odmg.StringValue)Hash_comments.get(OID);
		}
		return (result.isNil() ? null : result.stringValue());
	}


	static odmg.HashTab		Hash_comments;
	static odmg.Attribute	Attr_comments;
	public odmg.OidSet orders(){
		odmg.OidSet result = (odmg.OidSet)Hash_orders.get(OID);

		if (result == null || !result.isFetched()) {
			db.fetch(Attr_orders, OID);
			result = (odmg.OidSet)Hash_orders.get(OID);
		}
		result.setOwner(this);
		return (result.isNil() ? null : result);
	}


	static odmg.SetHash		Hash_orders;
	static odmg.Attribute	Attr_orders;
	public odmg.OidSet discounts(){
		odmg.OidSet result = (odmg.OidSet)Hash_discounts.get(OID);

		if (result == null || !result.isFetched()) {
			db.fetch(Attr_discounts, OID);
			result = (odmg.OidSet)Hash_discounts.get(OID);
		}
		result.setOwner(this);
		return (result.isNil() ? null : result);
	}


	static odmg.SetHash		Hash_discounts;
	static odmg.Attribute	Attr_discounts;

	public Order buy(odmg.OidSet items, dateAtom when) throws odmg.RpcException { 
		odmg.ParamList _p = new odmg.ParamList();
		_p.add(this);
		_p.add(items);
		_p.add(when);
		return (Order)db.rpc("Customer_buy", _p, OrderImp.classID, false);
	}

	public String toString() {
		return new String("Customer(" + OID + ")");
	}

	public void init() {
		extent	= new odmg.Extent( new CustomerImp(0, false, false));
		cache	= db.extentInsert("Example", "Customer", extent);

		Attr_id	= cache.attrInsert(
				"id",
				odmg.IntValue.classID,
				(Hash_id	= new odmg.HashTab()) );

		Attr_name	= cache.attrInsert(
				"name",
				odmg.StringValue.classID,
				(Hash_name	= new odmg.HashTab()) );

		Attr_address	= cache.attrInsert(
				"address",
				odmg.StringValue.classID,
				(Hash_address	= new odmg.HashTab()) );

		Attr_city	= cache.attrInsert(
				"city",
				odmg.StringValue.classID,
				(Hash_city	= new odmg.HashTab()) );

		Attr_state	= cache.attrInsert(
				"state",
				odmg.StringValue.classID,
				(Hash_state	= new odmg.HashTab()) );

		Attr_zip	= cache.attrInsert(
				"zip",
				odmg.StringValue.classID,
				(Hash_zip	= new odmg.HashTab()) );

		Attr_area	= cache.attrInsert(
				"area",
				odmg.StringValue.classID,
				(Hash_area	= new odmg.HashTab()) );

		Attr_phone	= cache.attrInsert(
				"phone",
				odmg.StringValue.classID,
				(Hash_phone	= new odmg.HashTab()) );

		Attr_gender	= cache.attrInsert(
				"gender",
				odmg.CharValue.classID,
				(Hash_gender	= new odmg.HashTab()) );

		Attr_creditLimit	= cache.attrInsert(
				"creditLimit",
				odmg.FloatValue.classID,
				(Hash_creditLimit	= new odmg.HashTab()) );

		Attr_comments	= cache.attrInsert(
				"comments",
				odmg.StringValue.classID,
				(Hash_comments	= new odmg.HashTab()) );

		Attr_orders	= cache.attrInsert(
				"orders",
				OrderImp.classID,
				(Hash_orders	= new odmg.SetHash()) );
		if (db.extentLookup("Example", "Order") != null) {
			db.registerInverse(Attr_orders,
				OrderImp.Attr_customer);
		}

		Attr_discounts	= cache.attrInsert(
				"discounts",
				DiscountImp.classID,
				(Hash_discounts	= new odmg.SetHash()) );
		if (db.extentLookup("Example", "Discount") != null) {
			db.registerInverse(Attr_discounts,
				DiscountImp.Attr_customers);
		}

	} @}
}
@f Example/Price
@+ Price
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_5_3_0" target="_self">Customer Interface</a>@.

@f Example/Price
@java
package Example;
@{
import java.io.*;
@}

public interface Price extends odmg.Value {

	public void destroy();

	public void invalidate();
	// Data member accessors

	Integer  prodId();
	void prodId(Integer  value);

	Float  stdPrice();
	void stdPrice(Float  value);

	Float  minPrice();
	void minPrice(Float  value);

	dateAtom startDate();
	void startDate(dateAtom value);

	dateAtom endDate();
	void endDate(dateAtom value);

	Product product();
	void product(Product value);

}

@f Example/PriceImp
@- Implementation Class
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_5_3_2" target="_self">CustomerImp Class</a>@.

@f Example/PriceImp
@java
package Example;

import java.io.*;

public class PriceImp extends odmg.Pobject implements Price {

	//IMPLEMENTATION OMITTED @{

	public static byte classID = 0;

	static odmg.ClassCache	cache;

	static odmg.Extent		extent;

	/**
	 * Create a new PriceImp object. The (generated) oid will be 
	 * send to the database during commit
	 */
	public PriceImp() {
		this(db.newOid(), true, true);
	}

	public PriceImp(int oid) {
		this(oid, true, true);
	}

	/**
	 * Not available to the user of the odmg package
	 */
	PriceImp(int oid, boolean dirty, boolean inExtent) {
		super(oid);
		if (inExtent){
			PriceImp.extent.put(this, dirty);
		}
	}

	public void destroy() {
		PriceImp.extent.remove(this);
		cache.remove(this);
	}

	/**
	 * 'newInstance' is used to create new Objects from oids in the cache 
	 * These objects will not be sendto the server during a commit
	 */
	public odmg.Pobject newInstance(int oid) {
		odmg.Pobject result;

		if ((result = extent.get(oid)) == null)
		    result = new PriceImp(oid, false, true);

		return result;
	}

	public void invalidate() {
		cache.remove(this);
	}

	public void setClassID(byte classID) {
		this.classID = classID;
	}

	public byte getClassID() {
		return classID;
	}

	public static odmg.OidSet createSet() {
		return new odmg.OidSet(classID);
	}

	public void prodId(Integer  value) {
		Hash_prodId.change(this,new odmg.IntValue(value));
	}

	public Integer  prodId(){
		odmg.IntValue result = (odmg.IntValue)Hash_prodId.get(OID);

		if (result == null) {
			db.fetch(Attr_prodId, OID);
			result = (odmg.IntValue)Hash_prodId.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_prodId;
	static odmg.Attribute	Attr_prodId;

	public void stdPrice(Float  value) {
		Hash_stdPrice.change(this,new odmg.FloatValue(value));
	}

	public Float  stdPrice(){
		odmg.FloatValue result = (odmg.FloatValue)Hash_stdPrice.get(OID);

		if (result == null) {
			db.fetch(Attr_stdPrice, OID);
			result = (odmg.FloatValue)Hash_stdPrice.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_stdPrice;
	static odmg.Attribute	Attr_stdPrice;

	public void minPrice(Float  value) {
		Hash_minPrice.change(this,new odmg.FloatValue(value));
	}

	public Float  minPrice(){
		odmg.FloatValue result = (odmg.FloatValue)Hash_minPrice.get(OID);

		if (result == null) {
			db.fetch(Attr_minPrice, OID);
			result = (odmg.FloatValue)Hash_minPrice.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_minPrice;
	static odmg.Attribute	Attr_minPrice;

	public void startDate(dateAtom value) {
		Hash_startDate.change(this,value);
	}

	public dateAtom startDate(){
		dateAtom result = (dateAtom)Hash_startDate.get(OID);

		if (result == null) {
			db.fetch(Attr_startDate, OID);
			result = (dateAtom)Hash_startDate.get(OID);
		}
		return (result.isNil() ? null : result);
	}


	static odmg.HashTab		Hash_startDate;
	static odmg.Attribute	Attr_startDate;

	public void endDate(dateAtom value) {
		Hash_endDate.change(this,value);
	}

	public dateAtom endDate(){
		dateAtom result = (dateAtom)Hash_endDate.get(OID);

		if (result == null) {
			db.fetch(Attr_endDate, OID);
			result = (dateAtom)Hash_endDate.get(OID);
		}
		return (result.isNil() ? null : result);
	}


	static odmg.HashTab		Hash_endDate;
	static odmg.Attribute	Attr_endDate;

	public void product(Product value) {
		Hash_product.change(this,value);
	}

	public Product product(){
		Product result = (Product)Hash_product.get(OID);

		if (result == null) {
			db.fetch(Attr_product, OID);
			result = (Product)Hash_product.get(OID);
		}
		return (result.isNil() ? null : result);
	}


	static odmg.HashTab		Hash_product;
	static odmg.Attribute	Attr_product;

	public String toString() {
		return new String("Price(" + OID + ")");
	}

	public void init() {
		extent	= new odmg.Extent( new PriceImp(0, false, false));
		cache	= db.extentInsert("Example", "Price", extent);

		Attr_prodId	= cache.attrInsert(
				"prodId",
				odmg.IntValue.classID,
				(Hash_prodId	= new odmg.HashTab()) );

		Attr_stdPrice	= cache.attrInsert(
				"stdPrice",
				odmg.FloatValue.classID,
				(Hash_stdPrice	= new odmg.HashTab()) );

		Attr_minPrice	= cache.attrInsert(
				"minPrice",
				odmg.FloatValue.classID,
				(Hash_minPrice	= new odmg.HashTab()) );

		Attr_startDate	= cache.attrInsert(
				"startDate",
				dateAtom.classID,
				(Hash_startDate	= new odmg.HashTab()) );

		Attr_endDate	= cache.attrInsert(
				"endDate",
				dateAtom.classID,
				(Hash_endDate	= new odmg.HashTab()) );

		Attr_product	= cache.attrInsert(
				"product",
				ProductImp.classID,
				(Hash_product	= new odmg.HashTab()) );
		if (db.extentLookup("Example", "Product") != null) {
			db.registerInverse(Attr_product,
				ProductImp.Attr_prices);
		}

	} @}
}
@f Example/Discount
@+ Discount
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_5_3_0" target="_self">Customer Interface</a>@.

@f Example/Discount
@java
package Example;
@{
import java.io.*;
@}

public interface Discount extends Price {

	public void destroy();

	public void invalidate();
	// Data member accessors

	Float  discountPerc();
	void discountPerc(Float  value);

	odmg.OidSet customers();

}
@f Example/DiscountImp
@- Implementation Class
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_5_3_2" target="_self">CustomerImp Class</a>@.

@f Example/DiscountImp
@java
package Example;
@{
import java.io.*;
@}

public class DiscountImp extends odmg.Pobject implements Discount {

	//IMPLEMENTATION OMITTED @{

	public static byte classID = 0;

	static odmg.ClassCache	cache;

	static odmg.Extent		extent;

	/**
	 * Create a new DiscountImp object. The (generated) oid will be 
	 * send to the database during commit
	 */
	public DiscountImp() {
		this(db.newOid(), true, true);
	}

	public DiscountImp(int oid) {
		this(oid, true, true);
	}

	/**
	 * Not available to the user of the odmg package
	 */
	DiscountImp(int oid, boolean dirty, boolean inExtent) {
		super(oid);
		if (inExtent){
			DiscountImp.extent.put(this, dirty);
			PriceImp.extent.put(this, dirty);
		}
	}

	public void destroy() {
		DiscountImp.extent.remove(this);
		PriceImp.extent.remove(this);
		cache.remove(this);
	}

	/**
	 * 'newInstance' is used to create new Objects from oids in the cache 
	 * These objects will not be sendto the server during a commit
	 */
	public odmg.Pobject newInstance(int oid) {
		odmg.Pobject result;

		if ((result = extent.get(oid)) == null)
		    result = new DiscountImp(oid, false, true);

		return result;
	}

	public void invalidate() {
		cache.remove(this);
	}

	public void setClassID(byte classID) {
		this.classID = classID;
	}

	public byte getClassID() {
		return classID;
	}

	public static odmg.OidSet createSet() {
		return new odmg.OidSet(classID);
	}

	public void discountPerc(Float  value) {
		Hash_discountPerc.change(this,new odmg.FloatValue(value));
	}

	public Float  discountPerc(){
		odmg.FloatValue result = (odmg.FloatValue)Hash_discountPerc.get(OID);

		if (result == null) {
			db.fetch(Attr_discountPerc, OID);
			result = (odmg.FloatValue)Hash_discountPerc.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_discountPerc;
	static odmg.Attribute	Attr_discountPerc;
	public odmg.OidSet customers(){
		odmg.OidSet result = (odmg.OidSet)Hash_customers.get(OID);

		if (result == null || !result.isFetched()) {
			db.fetch(Attr_customers, OID);
			result = (odmg.OidSet)Hash_customers.get(OID);
		}
		result.setOwner(this);
		return (result.isNil() ? null : result);
	}


	static odmg.SetHash		Hash_customers;
	static odmg.Attribute	Attr_customers;

	public void prodId(Integer  value) {
		Hash_prodId.change(this,new odmg.IntValue(value));
	}

	public Integer  prodId(){
		odmg.IntValue result = (odmg.IntValue)Hash_prodId.get(OID);

		if (result == null) {
			db.fetch(Attr_prodId, OID);
			result = (odmg.IntValue)Hash_prodId.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_prodId;
	static odmg.Attribute	Attr_prodId;

	public void stdPrice(Float  value) {
		Hash_stdPrice.change(this,new odmg.FloatValue(value));
	}

	public Float  stdPrice(){
		odmg.FloatValue result = (odmg.FloatValue)Hash_stdPrice.get(OID);

		if (result == null) {
			db.fetch(Attr_stdPrice, OID);
			result = (odmg.FloatValue)Hash_stdPrice.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_stdPrice;
	static odmg.Attribute	Attr_stdPrice;

	public void minPrice(Float  value) {
		Hash_minPrice.change(this,new odmg.FloatValue(value));
	}

	public Float  minPrice(){
		odmg.FloatValue result = (odmg.FloatValue)Hash_minPrice.get(OID);

		if (result == null) {
			db.fetch(Attr_minPrice, OID);
			result = (odmg.FloatValue)Hash_minPrice.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_minPrice;
	static odmg.Attribute	Attr_minPrice;

	public void startDate(dateAtom value) {
		Hash_startDate.change(this,value);
	}

	public dateAtom startDate(){
		dateAtom result = (dateAtom)Hash_startDate.get(OID);

		if (result == null) {
			db.fetch(Attr_startDate, OID);
			result = (dateAtom)Hash_startDate.get(OID);
		}
		return (result.isNil() ? null : result);
	}


	static odmg.HashTab		Hash_startDate;
	static odmg.Attribute	Attr_startDate;

	public void endDate(dateAtom value) {
		Hash_endDate.change(this,value);
	}

	public dateAtom endDate(){
		dateAtom result = (dateAtom)Hash_endDate.get(OID);

		if (result == null) {
			db.fetch(Attr_endDate, OID);
			result = (dateAtom)Hash_endDate.get(OID);
		}
		return (result.isNil() ? null : result);
	}


	static odmg.HashTab		Hash_endDate;
	static odmg.Attribute	Attr_endDate;

	public void product(Product value) {
		Hash_product.change(this,value);
	}

	public Product product(){
		Product result = (Product)Hash_product.get(OID);

		if (result == null) {
			db.fetch(Attr_product, OID);
			result = (Product)Hash_product.get(OID);
		}
		return (result.isNil() ? null : result);
	}


	static odmg.HashTab		Hash_product;
	static odmg.Attribute	Attr_product;

	public String toString() {
		return new String("Discount(" + OID + ")");
	}

	public void init() {
		extent	= new odmg.Extent( new DiscountImp(0, false, false));
		cache	= db.extentInsert("Example", "Discount", extent);

		Attr_discountPerc	= cache.attrInsert(
				"discountPerc",
				odmg.FloatValue.classID,
				(Hash_discountPerc	= new odmg.HashTab()) );

		Attr_customers	= cache.attrInsert(
				"customers",
				CustomerImp.classID,
				(Hash_customers	= new odmg.SetHash()) );
		if (db.extentLookup("Example", "Customer") != null) {
			db.registerInverse(Attr_customers,
				CustomerImp.Attr_discounts);
		}

		Attr_prodId	= PriceImp.Attr_prodId;
		Hash_prodId	= PriceImp.Hash_prodId;

		Attr_stdPrice	= PriceImp.Attr_stdPrice;
		Hash_stdPrice	= PriceImp.Hash_stdPrice;

		Attr_minPrice	= PriceImp.Attr_minPrice;
		Hash_minPrice	= PriceImp.Hash_minPrice;

		Attr_startDate	= PriceImp.Attr_startDate;
		Hash_startDate	= PriceImp.Hash_startDate;

		Attr_endDate	= PriceImp.Attr_endDate;
		Hash_endDate	= PriceImp.Hash_endDate;

		Attr_product	= PriceImp.Attr_product;
		Hash_product	= PriceImp.Hash_product;

	} @}
}
@f Example/Product
@+ Product 
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_5_3_0" target="_self">Customer Interface</a>@.

@f Example/Product
@java
package Example;
@{
import java.io.*;
@}

public interface Product  extends odmg.Value {

	public void destroy();

	public void invalidate();
	// Data member accessors

	Integer  id();
	void id(Integer  value);

	String  description();
	void description(String  value);

	odmg.OidSet prices();

	odmg.OidSet ordered_items();

}
@f Example/ProductImp
@- Implementation Class
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_5_3_2" target="_self">CustomerImp Class</a>@.

@f Example/ProductImp
@java
package Example;
@{
import java.io.*;
@}

public class ProductImp extends odmg.Pobject implements Product {

	//IMPLEMENTATION OMITTED @{

	public static byte classID = 0;

	static odmg.ClassCache	cache;

	static odmg.Extent		extent;

	/**
	 * Create a new ProductImp object. The (generated) oid will be 
	 * send to the database during commit
	 */
	public ProductImp() {
		this(db.newOid(), true, true);
	}

	public ProductImp(int oid) {
		this(oid, true, true);
	}

	/**
	 * Not available to the user of the odmg package
	 */
	ProductImp(int oid, boolean dirty, boolean inExtent) {
		super(oid);
		if (inExtent){
			ProductImp.extent.put(this, dirty);
		}
	}

	public void destroy() {
		ProductImp.extent.remove(this);
		cache.remove(this);
	}

	/**
	 * 'newInstance' is used to create new Objects from oids in the cache 
	 * These objects will not be sendto the server during a commit
	 */
	public odmg.Pobject newInstance(int oid) {
		odmg.Pobject result;

		if ((result = extent.get(oid)) == null)
		    result = new ProductImp(oid, false, true);

		return result;
	}

	public void invalidate() {
		cache.remove(this);
	}

	public void setClassID(byte classID) {
		this.classID = classID;
	}

	public byte getClassID() {
		return classID;
	}

	public static odmg.OidSet createSet() {
		return new odmg.OidSet(classID);
	}

	public void id(Integer  value) {
		Hash_id.change(this,new odmg.IntValue(value));
	}

	public Integer  id(){
		odmg.IntValue result = (odmg.IntValue)Hash_id.get(OID);

		if (result == null) {
			db.fetch(Attr_id, OID);
			result = (odmg.IntValue)Hash_id.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_id;
	static odmg.Attribute	Attr_id;

	public void description(String  value) {
		Hash_description.change(this,new odmg.StringValue(value));
	}

	public String  description(){
		odmg.StringValue result = (odmg.StringValue)Hash_description.get(OID);

		if (result == null) {
			db.fetch(Attr_description, OID);
			result = (odmg.StringValue)Hash_description.get(OID);
		}
		return (result.isNil() ? null : result.stringValue());
	}


	static odmg.HashTab		Hash_description;
	static odmg.Attribute	Attr_description;
	public odmg.OidSet prices(){
		odmg.OidSet result = (odmg.OidSet)Hash_prices.get(OID);

		if (result == null || !result.isFetched()) {
			db.fetch(Attr_prices, OID);
			result = (odmg.OidSet)Hash_prices.get(OID);
		}
		result.setOwner(this);
		return (result.isNil() ? null : result);
	}


	static odmg.SetHash		Hash_prices;
	static odmg.Attribute	Attr_prices;
	public odmg.OidSet ordered_items(){
		odmg.OidSet result = (odmg.OidSet)Hash_ordered_items.get(OID);

		if (result == null || !result.isFetched()) {
			db.fetch(Attr_ordered_items, OID);
			result = (odmg.OidSet)Hash_ordered_items.get(OID);
		}
		result.setOwner(this);
		return (result.isNil() ? null : result);
	}


	static odmg.SetHash		Hash_ordered_items;
	static odmg.Attribute	Attr_ordered_items;

	public String toString() {
		return new String("Product(" + OID + ")");
	}

	public void init() {
		extent	= new odmg.Extent( new ProductImp(0, false, false));
		cache	= db.extentInsert("Example", "Product", extent);

		Attr_id	= cache.attrInsert(
				"id",
				odmg.IntValue.classID,
				(Hash_id	= new odmg.HashTab()) );

		Attr_description	= cache.attrInsert(
				"description",
				odmg.StringValue.classID,
				(Hash_description	= new odmg.HashTab()) );

		Attr_prices	= cache.attrInsert(
				"prices",
				PriceImp.classID,
				(Hash_prices	= new odmg.SetHash()) );
		if (db.extentLookup("Example", "Price") != null) {
			db.registerInverse(Attr_prices,
				PriceImp.Attr_product);
		}

		Attr_ordered_items	= cache.attrInsert(
				"ordered_items",
				ItemImp.classID,
				(Hash_ordered_items	= new odmg.SetHash()) );
		if (db.extentLookup("Example", "Item") != null) {
			db.registerInverse(Attr_ordered_items,
				ItemImp.Attr_product);
		}

	} @}
}
@f Example/Order
@+ Order
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_5_3_0" target="_self">Customer Interface</a>@.

@f Example/Order
@java
package Example;
@{
import java.io.*;
@}

public interface Order  extends odmg.Value {

	public void destroy();

	public void invalidate();
	// Data member accessors

	Integer  id();
	void id(Integer  value);

	dateAtom orderDate();
	void orderDate(dateAtom value);

	Integer  commisionPlan();
	void commisionPlan(Integer  value);

	dateAtom shipDate();
	void shipDate(dateAtom value);

	Float  total();
	void total(Float  value);

	Customer customer();
	void customer(Customer value);

	odmg.OidSet items();

}
@f Example/OrderImp
@- Implementation Class
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_5_3_2" target="_self">CustomerImp Class</a>@.

@f Example/OrderImp
@java
package Example;
@{
import java.io.*;
@}

public class OrderImp extends odmg.Pobject implements Order {

	//IMPLEMENTATION OMITTED @{

	public static byte classID = 0;

	static odmg.ClassCache	cache;

	static odmg.Extent		extent;

	/**
	 * Create a new OrderImp object. The (generated) oid will be 
	 * send to the database during commit
	 */
	public OrderImp() {
		this(db.newOid(), true, true);
	}

	public OrderImp(int oid) {
		this(oid, true, true);
	}

	/**
	 * Not available to the user of the odmg package
	 */
	OrderImp(int oid, boolean dirty, boolean inExtent) {
		super(oid);
		if (inExtent){
			OrderImp.extent.put(this, dirty);
		}
	}

	public void destroy() {
		OrderImp.extent.remove(this);
		cache.remove(this);
	}

	/**
	 * 'newInstance' is used to create new Objects from oids in the cache 
	 * These objects will not be sendto the server during a commit
	 */
	public odmg.Pobject newInstance(int oid) {
		odmg.Pobject result;

		if ((result = extent.get(oid)) == null)
		    result = new OrderImp(oid, false, true);

		return result;
	}

	public void invalidate() {
		cache.remove(this);
	}

	public void setClassID(byte classID) {
		this.classID = classID;
	}

	public byte getClassID() {
		return classID;
	}

	public static odmg.OidSet createSet() {
		return new odmg.OidSet(classID);
	}

	public void id(Integer  value) {
		Hash_id.change(this,new odmg.IntValue(value));
	}

	public Integer  id(){
		odmg.IntValue result = (odmg.IntValue)Hash_id.get(OID);

		if (result == null) {
			db.fetch(Attr_id, OID);
			result = (odmg.IntValue)Hash_id.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_id;
	static odmg.Attribute	Attr_id;

	public void orderDate(dateAtom value) {
		Hash_orderDate.change(this,value);
	}

	public dateAtom orderDate(){
		dateAtom result = (dateAtom)Hash_orderDate.get(OID);

		if (result == null) {
			db.fetch(Attr_orderDate, OID);
			result = (dateAtom)Hash_orderDate.get(OID);
		}
		return (result.isNil() ? null : result);
	}


	static odmg.HashTab		Hash_orderDate;
	static odmg.Attribute	Attr_orderDate;

	public void commisionPlan(Integer  value) {
		Hash_commisionPlan.change(this,new odmg.CharValue(value));
	}

	public Integer  commisionPlan(){
		odmg.CharValue result = (odmg.CharValue)Hash_commisionPlan.get(OID);

		if (result == null) {
			db.fetch(Attr_commisionPlan, OID);
			result = (odmg.CharValue)Hash_commisionPlan.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_commisionPlan;
	static odmg.Attribute	Attr_commisionPlan;

	public void shipDate(dateAtom value) {
		Hash_shipDate.change(this,value);
	}

	public dateAtom shipDate(){
		dateAtom result = (dateAtom)Hash_shipDate.get(OID);

		if (result == null) {
			db.fetch(Attr_shipDate, OID);
			result = (dateAtom)Hash_shipDate.get(OID);
		}
		return (result.isNil() ? null : result);
	}


	static odmg.HashTab		Hash_shipDate;
	static odmg.Attribute	Attr_shipDate;

	public void total(Float  value) {
		Hash_total.change(this,new odmg.FloatValue(value));
	}

	public Float  total(){
		odmg.FloatValue result = (odmg.FloatValue)Hash_total.get(OID);

		if (result == null) {
			db.fetch(Attr_total, OID);
			result = (odmg.FloatValue)Hash_total.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_total;
	static odmg.Attribute	Attr_total;

	public void customer(Customer value) {
		Hash_customer.change(this,value);
	}

	public Customer customer(){
		Customer result = (Customer)Hash_customer.get(OID);

		if (result == null) {
			db.fetch(Attr_customer, OID);
			result = (Customer)Hash_customer.get(OID);
		}
		return (result.isNil() ? null : result);
	}


	static odmg.HashTab		Hash_customer;
	static odmg.Attribute	Attr_customer;
	public odmg.OidSet items(){
		odmg.OidSet result = (odmg.OidSet)Hash_items.get(OID);

		if (result == null || !result.isFetched()) {
			db.fetch(Attr_items, OID);
			result = (odmg.OidSet)Hash_items.get(OID);
		}
		result.setOwner(this);
		return (result.isNil() ? null : result);
	}


	static odmg.SetHash		Hash_items;
	static odmg.Attribute	Attr_items;

	public String toString() {
		return new String("Order(" + OID + ")");
	}

	public void init() {
		extent	= new odmg.Extent( new OrderImp(0, false, false));
		cache	= db.extentInsert("Example", "Order", extent);

		Attr_id	= cache.attrInsert(
				"id",
				odmg.IntValue.classID,
				(Hash_id	= new odmg.HashTab()) );

		Attr_orderDate	= cache.attrInsert(
				"orderDate",
				dateAtom.classID,
				(Hash_orderDate	= new odmg.HashTab()) );

		Attr_commisionPlan	= cache.attrInsert(
				"commisionPlan",
				odmg.CharValue.classID,
				(Hash_commisionPlan	= new odmg.HashTab()) );

		Attr_shipDate	= cache.attrInsert(
				"shipDate",
				dateAtom.classID,
				(Hash_shipDate	= new odmg.HashTab()) );

		Attr_total	= cache.attrInsert(
				"total",
				odmg.FloatValue.classID,
				(Hash_total	= new odmg.HashTab()) );

		Attr_customer	= cache.attrInsert(
				"customer",
				CustomerImp.classID,
				(Hash_customer	= new odmg.HashTab()) );
		if (db.extentLookup("Example", "Customer") != null) {
			db.registerInverse(Attr_customer,
				CustomerImp.Attr_orders);
		}

		Attr_items	= cache.attrInsert(
				"items",
				ItemImp.classID,
				(Hash_items	= new odmg.SetHash()) );
		if (db.extentLookup("Example", "Item") != null) {
			db.registerInverse(Attr_items,
				ItemImp.Attr_order);
		}

	} @}

}
@f Example/Item
@+ Item
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_5_3_0" target="_self">Customer Interface</a>@.

@f Example/Item
@java
package Example;
@{
import java.io.*;
@}

public interface Item  extends odmg.Value {

	public void destroy();

	public void invalidate();
	// Data member accessors

	Integer  itemNr();
	void itemNr(Integer  value);

	Integer  orderId();
	void orderId(Integer  value);

	Integer  productId();
	void productId(Integer  value);

	Float  price();
	void price(Float  value);

	Integer  quantity();
	void quantity(Integer  value);

	Float  total();
	void total(Float  value);

	Product product();
	void product(Product value);

	Order order();
	void order(Order value);

}
@f Example/ItemImp
@- Implementation Class
This mapping from ODL follows the same logic as described in the section on the @[<a href="#mod_5_3_2" target="_self">CustomerImp Class</a>@.

@f Example/ItemImp
@java
package Example;
@{
import java.io.*;
@}

public class ItemImp extends odmg.Pobject implements Item {

	//IMPLEMENTATION OMITTED @{

	public static byte classID = 0;

	static odmg.ClassCache	cache;

	static odmg.Extent		extent;

	/**
	 * Create a new ItemImp object. The (generated) oid will be 
	 * send to the database during commit
	 */
	public ItemImp() {
		this(db.newOid(), true, true);
	}

	public ItemImp(int oid) {
		this(oid, true, true);
	}

	/**
	 * Not available to the user of the odmg package
	 */
	ItemImp(int oid, boolean dirty, boolean inExtent) {
		super(oid);
		if (inExtent){
			ItemImp.extent.put(this, dirty);
		}
	}

	public void destroy() {
		ItemImp.extent.remove(this);
		cache.remove(this);
	}

	/**
	 * 'newInstance' is used to create new Objects from oids in the cache 
	 * These objects will not be sendto the server during a commit
	 */
	public odmg.Pobject newInstance(int oid) {
		odmg.Pobject result;

		if ((result = extent.get(oid)) == null)
		    result = new ItemImp(oid, false, true);

		return result;
	}

	public void invalidate() {
		cache.remove(this);
	}

	public void setClassID(byte classID) {
		this.classID = classID;
	}

	public byte getClassID() {
		return classID;
	}

	public static odmg.OidSet createSet() {
		return new odmg.OidSet(classID);
	}

	public void itemNr(Integer  value) {
		Hash_itemNr.change(this,new odmg.IntValue(value));
	}

	public Integer  itemNr(){
		odmg.IntValue result = (odmg.IntValue)Hash_itemNr.get(OID);

		if (result == null) {
			db.fetch(Attr_itemNr, OID);
			result = (odmg.IntValue)Hash_itemNr.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_itemNr;
	static odmg.Attribute	Attr_itemNr;

	public void orderId(Integer  value) {
		Hash_orderId.change(this,new odmg.IntValue(value));
	}

	public Integer  orderId(){
		odmg.IntValue result = (odmg.IntValue)Hash_orderId.get(OID);

		if (result == null) {
			db.fetch(Attr_orderId, OID);
			result = (odmg.IntValue)Hash_orderId.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_orderId;
	static odmg.Attribute	Attr_orderId;

	public void productId(Integer  value) {
		Hash_productId.change(this,new odmg.IntValue(value));
	}

	public Integer  productId(){
		odmg.IntValue result = (odmg.IntValue)Hash_productId.get(OID);

		if (result == null) {
			db.fetch(Attr_productId, OID);
			result = (odmg.IntValue)Hash_productId.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_productId;
	static odmg.Attribute	Attr_productId;

	public void price(Float  value) {
		Hash_price.change(this,new odmg.FloatValue(value));
	}

	public Float  price(){
		odmg.FloatValue result = (odmg.FloatValue)Hash_price.get(OID);

		if (result == null) {
			db.fetch(Attr_price, OID);
			result = (odmg.FloatValue)Hash_price.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_price;
	static odmg.Attribute	Attr_price;

	public void quantity(Integer  value) {
		Hash_quantity.change(this,new odmg.IntValue(value));
	}

	public Integer  quantity(){
		odmg.IntValue result = (odmg.IntValue)Hash_quantity.get(OID);

		if (result == null) {
			db.fetch(Attr_quantity, OID);
			result = (odmg.IntValue)Hash_quantity.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_quantity;
	static odmg.Attribute	Attr_quantity;

	public void total(Float  value) {
		Hash_total.change(this,new odmg.FloatValue(value));
	}

	public Float  total(){
		odmg.FloatValue result = (odmg.FloatValue)Hash_total.get(OID);

		if (result == null) {
			db.fetch(Attr_total, OID);
			result = (odmg.FloatValue)Hash_total.get(OID);
		}
		return (result.isNil() ? null : result.Value());
	}


	static odmg.HashTab		Hash_total;
	static odmg.Attribute	Attr_total;

	public void product(Product value) {
		Hash_product.change(this,value);
	}

	public Product product(){
		Product result = (Product)Hash_product.get(OID);

		if (result == null) {
			db.fetch(Attr_product, OID);
			result = (Product)Hash_product.get(OID);
		}
		return (result.isNil() ? null : result);
	}


	static odmg.HashTab		Hash_product;
	static odmg.Attribute	Attr_product;

	public void order(Order value) {
		Hash_order.change(this,value);
	}

	public Order order(){
		Order result = (Order)Hash_order.get(OID);

		if (result == null) {
			db.fetch(Attr_order, OID);
			result = (Order)Hash_order.get(OID);
		}
		return (result.isNil() ? null : result);
	}


	static odmg.HashTab		Hash_order;
	static odmg.Attribute	Attr_order;

	public String toString() {
		return new String("Item(" + OID + ")");
	}

	public void init() {
		extent	= new odmg.Extent( new ItemImp(0, false, false));
		cache	= db.extentInsert("Example", "Item", extent);

		Attr_itemNr	= cache.attrInsert(
				"itemNr",
				odmg.IntValue.classID,
				(Hash_itemNr	= new odmg.HashTab()) );

		Attr_orderId	= cache.attrInsert(
				"orderId",
				odmg.IntValue.classID,
				(Hash_orderId	= new odmg.HashTab()) );

		Attr_productId	= cache.attrInsert(
				"productId",
				odmg.IntValue.classID,
				(Hash_productId	= new odmg.HashTab()) );

		Attr_price	= cache.attrInsert(
				"price",
				odmg.FloatValue.classID,
				(Hash_price	= new odmg.HashTab()) );

		Attr_quantity	= cache.attrInsert(
				"quantity",
				odmg.IntValue.classID,
				(Hash_quantity	= new odmg.HashTab()) );

		Attr_total	= cache.attrInsert(
				"total",
				odmg.FloatValue.classID,
				(Hash_total	= new odmg.HashTab()) );

		Attr_product	= cache.attrInsert(
				"product",
				ProductImp.classID,
				(Hash_product	= new odmg.HashTab()) );
		if (db.extentLookup("Example", "Product") != null) {
			db.registerInverse(Attr_product,
				ProductImp.Attr_ordered_items);
		}

		Attr_order	= cache.attrInsert(
				"order",
				OrderImp.classID,
				(Hash_order	= new odmg.HashTab()) );
		if (db.extentLookup("Example", "Order") != null) {
			db.registerInverse(Attr_order,
				OrderImp.Attr_items);
		}

	} @}

}

@* How to make this all work?

This section explains what you should do to get this example running.

@+ Monet installation

When you are using the ODMG interface to Monet you don't need access for
hacking in the Monet kernel, you only need a running @#Mserver@. Both the
University of Amsterdam and CWI have a @#monet@ account where a 
up-to-date/stable version of Monet is available. If this isn't the case
you will have to install Monet locally, follow the instructions for
the @[<a href="monet.html">binary/source distribution</a>@. 
In the rest of this section we will refer to this distribution as
@#<global_monethome>@, a typical value for this would be @#/home/monet/monet@.
After you have access to a running @#Mserver@ you can make you local development
environment.

@+ Environment settings

To make Monet run for the @#Mdevelop@ script, you need a least the following
environment settings:

@T
\begin{verbatim}
setenv PREFIX 		`uname``uname -r`
setenv MONETHOME 	<global_monethome>
setenv MONET_MOD_PATH 	$MONETHOME/$PREFIX/lib
setenv LD_LIBRARY_PATH 	$LD_LIBRARY_PATH':'$MONET_MOD_PATH
setenv PATH		$PATH':'$MONETHOME/$PREFIX/bin
\end{verbatim}
@

@+ Mdevelop environment

The Mdevelop environment is used for developing modules, which can be loaded
in Monet. Do the following to make your local environment:
@-
@#Mdevelop <global_monethome> <local_monethome>@
@-
Where @#<local_monethome>@ stands for your local monet environment, e.g.
@#/home/claude/monet@. This local directory doesn't have to exist, @#Mdevelop@
will create it for you. After this the following directory structure will
be in your @#<local_monethome>@:
@T
\begin{description}
\item[homes] this file describes which Monet databases you have and where they are;
\item[dbfarm] this is where your Monet databases are;
\item[scripts] link to the {\texttt <global_monethome>} scripts directory, 
needed to create new databases;
\item{kernel} link to the {\texttt <global_monethome>} directory, needed to
find the makefiles, libraries and modules;
\item[modules] the directory where you can create your own modules, there
is already an example (template) in it;
\item[<OS_prefix>] these directories will contain compilations for specific
platforms.
\end{description}
@

You need an @#<OS_prefix>@ directory for every platform and version of an
Operating System you want to work on with Monet. You can do this by running
the @#Mdevelop@ script with the same arguments on each platform/version.


After this you need to change your environment settings to:
@T
\begin{verbatim}
setenv PREFIX 		`uname``uname -r`
setenv MONETHOME 	<local_monethome>
setenv MONET_MOD_PATH 	$MONETHOME/$PREFIX/lib:$MONETHOME/kernel/$PREFIX/lib
setenv LD_LIBRARY_PATH 	$LD_LIBRARY_PATH':'$MONET_MOD_PATH
setenv PATH		$PATH':'$MONETHOME/kernel/$PREFIX/bin
\end{verbatim}
@

@+ Example Module

@T
You can now compile this module, by creating an Example directory in the
modules director of your Mdevelop environment. Copy this mx file into the
directory and extract the Makefile as described below..

The following {\em Makefile} can be used to regenerate and compile the ODL
specification and C/C++ implementation of this Example. To switch between
the C and C++ implementation change the {\em ODL_BINDING} to c 
(C implementation) or C (C++ implementation). And remove the \@c line in
the C implementation section in this file, and add a \@C line in the
C++ implementation section.

As Mx doesn't support extracting of this {\em Makefile} use copy and paste to
get your own copy!. Or use the {\em Mx -x tcl} command to extract 
{\em Makefile.tcl} and rename that to {\em Makefile}.

@f Makefile
@tcl
###########################################################################
# any targets in this makefiles?

TARGETS=MOD
MONETDIST=$(MONETHOME)/kernel

###########################################################################
# files

MODULES=  	Example	
MXFILES=        $(MODULES:%=%.mx)

###########################################################################
# ok, NOW, let's get top-level settings

ODL_BINDING = c

include $(MONETDIST)/Makefile

###########################################################################

ifndef JAVAC
all:
else

PACKAGE=	Example

JAVADIR=	$(MONETHOME)/java
DIRS +=		$(JAVADIR)
DIRS += 	$(JAVADIR)/$(PACKAGE)

CLASSPATH=	.:$(LIBDIR)/odmg.jar:$(LIBDIR)/Meta.jar:$(JAVADIR)
export CLASSPATH

ODLFILE = 	$(JAVADIR)/$(PACKAGE)/$(PACKAGE).odl

all: $(LIBMODS) $(ODLFILE)
	echo CLASSPATH = $(CLASSPATH)
	$(ODLP) $(INCLUDES) -java $(ODLFILE) \
		> $(JAVADIR)/$(PACKAGE)/$(PACKAGE)Java.mx
	$(MX) -R$(JAVADIR)/$(PACKAGE) -c $(JAVADIR)/$(PACKAGE)/$(PACKAGE)Java.mx
	$(JAVAC) -d $(JAVADIR) $(JAVADIR)/$(PACKAGE)/*.java
	( cd $(JAVADIR);\
	  $(JAR) cf $(PACKAGE).jar $(PACKAGE)/*.class; )

$(ODLFILE): $(PACKAGE).mx
	$(MX) -R$(JAVADIR)/$(PACKAGE) -x odl $(PACKAGE).mx

endif

###########################################################################
# Extra include
INCLUDES += \
	-I$(MONETDIST)/$(PREFIX)/modules/CC_odmg \
	-I$(MONETDIST)/$(PREFIX)/modules/odmg \
	-I$(MONETDIST)/$(PREFIX)/include \
	-I.

#eof

