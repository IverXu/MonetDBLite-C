@f stdlib
@d 04/11/1997
@a Peter Boncz
@v 2.0
@t ODMG Standard Library Reference
@* Introduction
@T
Apart from its own generated classes, each ODMG application
heavily leans on standard system services provided by Monet/ODMG.
These standard services mainly consist of the {\bf ODMG Standard Library},
which are defined in this document as the built-in 
@[<a href="odl.html">Monet/ODL</a>@ module by the name of {\bf stdlib}.

\begin{center}
{\epsfxsize=0.60\textwidth
\epsffile{odmg_stdlib.eps}
{\em The Standard Library and its place in the Monet/ODMG System}}
\end{center}

More information on the Monet/ODMG system can be found in the following
reference material:
\begin{itemize}
\item The @[<a href="monet.html">Monet Documentation</a>@
for more information on availability,
installing, and a general system overview.
\item The @[<a href="odl.html">ODL Reference Manual</a>@
for an exact definition of Monet/ODL. It was derived from the ODMG1.X
definition and introduces atomic extensibility but lacks some other features.
It differs widely from ODMG2.0.
\item See the @[<a href="man/odlp.html">Manual Page</a>@
for the exact calling options of the ODL parser.
\item The @[<a href="meta.html">ODMG Meta Model</a>@
shows the ODL schema of the Meta model that is used as Data Dictionary.
\item The @[<a href="Example.html">Example ODL Model</a>@
introduces a simple Customer-Order-Item model and shows how this
can be accessed in the ODMG/C, ODMG/C++ and ODMG/Java environments
through stub classes.
\item The @[<a href="app.html">Example ODMG Application</a>@
uses the same data-model to build a simple application for
internet sales, that demonstrates easily how all system components
work and fit together.
\end{itemize}

@- overview

We will discuss in turn all interfaces contained in the standard library
and explain which methods are available and what they do. 
We provide references to language bindings for C, C++ and Java. These 
references discuss details and peculiarities for each language 
environments, which cannot be found in this general document.

@+ Values
@T
Values are instances of some type of the ODL system. There are two kinds:
\begin{itemize}
\item {\em atomic values} are self-contained.
\item {\em object values} refer by means of an OID to a 
persistent structure in the Monet/ODMG database.
\end{itemize}
A value always is an instatiation of some type, be it an object type or an 
atomic type.  Values can hence be of different types, that is a {\tt string} 
behaves differently than a {\tt integer} and a {\tt Person} persistent object.

There are however some common behavior and properties that values have:
\begin{itemize}
\item {\em nil value}: each type has one special value in in the domain that
is called the 'nil'. It is used for instance as a value for 
uninstantiated fields or variables.
\item {\em equality}: each pair of values of the same type can be compared
with each other for equality. Equality of atomic values depends purely on 
their content, whereas object values are equal if and only if they refer to 
the same object. 
\item {\em comparison}: each pair of values of the same type can be compared
with each other yielding 'left smaller than right' (-1), 'left equal to right' 
(0) or 'left greater than right' (1). This ordering depends for atomic
values on the atomic type, and for objects is done on OID value.
\end{itemize}

@- Interface References 
The following language-specific reference documents exist for this interface:
@T
\begin{itemize}
\item 
The @[<a href="CC_odmg/CC_Value.html">ODMG/C++ Value Class</a>@ and 
\item 
@[<a href="odmg/Value.html">C Value Interface</a>@ define a
value just as an anonymous pointer.
\item
The @[<a href="jOdmg/odmg.Value.html">ODMG/Java Value</a> class is the top of the 
ODMG hierarchy.
\end{itemize}

@+ Atoms
@T
Monet/ODMG currently support the following atomic types: 
@odl
module stdlib {

       enum boolean { FALSE, TRUE }; 
       atom char;         // single ASCII character values.
       atom short;        // 2-byte integers. 
       atom int;          // signed integers (currently four-byte).
       atom ptr;          // transient memory pointers 
       atom float;        // floating point values (currently four-byte).
       atom double;       // double sized floats. 
       atom long;         // double sized integers.
       atom string;       // strings of characters.
@T
As explained in the @[<a href="odmg_odl.html">ODL Reference Manual</a>@, 
these can be extended with new atomic values. For instance, if
one has implemented an {\tt image} atom in Monet, one can easily
add it as an ODL atom as well.    

@- Interface Reference 
The following language-specific reference documents exist for this interface:
@T
\begin{itemize}
\item in {\bf ODMG/C} and {\bf ODMG/C++}
the Monet/ODMG standard atoms directly map onto their obvious
C and C++ counterparts. Extension atoms in ODMG are mapped 1-1
to extension atoms in Monet (see the
@[<a href="../scw/gdk/gdk.html/mod_1_5_0">Atoms Section of the GDK Document</a>@). Programming guidelines for extending Monet with
new atoms can be found in the @[<a href="mel.html">MEL Reference Manual</a>@.
\item {\bf ODMG/Java} defines the standard atom classes
@[<a href="jOdmg/odmg.BooleanValue.html">BooleanValue</a>@,
@[<a href="jOdmg/odmg.CharValue.html">CharValue</a>@,
@[<a href="jOdmg/odmg.ShortValue.html">ShortValue</a>@,
@[<a href="jOdmg/odmg.IntValue.html">IntValue</a>@,
@[<a href="jOdmg/odmg.FloatValue.html">FloatValue</a>@,
@[<a href="jOdmg/odmg.DoubleValue.html">DoubleValue</a>@,
@[<a href="jOdmg/odmg.LongValue.html">LongValue</a>@, and
@[<a href="jOdmg/odmg.StringValue.html">StringValue</a>@.
Extension atoms are derived from the generic
@[<a href="jOdmg/odmg.Atom.html">Atom</a>@ class.
\end{itemize}

@+ Persistent Objects
The object lifetime model of Monet/ODMG is simpler than the official ODMG
definition in that each object is by default persistent. 
@T
Another distinguishing feature of the Monet/ODMG system is that it 
clearly separates the logical model from the physical model.
In Monet/ODMG, an object is therefore not mapped to any particular
structure in any of the language bindings. Objects are internally 
represented by object-identifiers (OIDs), and access to their 
attributes is provided by {\bf accessor-methods}. That is, attributes
are not materialized, but protected with methods.

@odl
        interface Attribute; // identifies an attribute of some class
        atom oid;            // object identifiers
@
Attribute values of an @%Pobject@ can be requested and updated with the
@%Pobject.attr@ methods. Attributes are identified by so-called
'attribute-identifiers', that can be requested from the @%MonetDatabase@
class (see @[<a href="//mod_2_9_0" target="_self">section 2.9</a>@) or via the 
@[<a href="meta.html">Meta model</a>@. 
@T
Normally, the programmer need not manipulate Attribute-identifiers and the 
Pobject interface, as in the generated language binding specific attribute
accessor functions will be generated automatically.

These 'attr' methods are thus of interest only for applications
that do not know the database scheme at compile time or want
dynamic access to methods. 
@odl
        interface Pobject {
		static int classID; // structure ID 

                oid oid();
                void destroy ();
        
                boolean equal(Pobject); // equal iff OIDs are equal
                int compare(Pobject);   // ordering on OID value
        
                Value attr(Attribute a); // retrieve an attribute value
                void  attr(Attribute a, Value v); // change an attribute value
        
                void dump (FILE *fp);
        };
@T
The 'destroy' marks  the object for destruction. After a commit, 
it will disappear entirely from the database.

The 'dump(fp)' method prints the objects, and all its
attribute values on a file pointer, and carries out a
consistency check on that object.

@- bugs
Actually, I did not want to have the concept of OIDs surface in
the model. It seems that our current applications cannot do
without.

@- Interface Reference 
The following language-specific reference documents exist for this interface:
@T
\begin{itemize}
\item The @[<a href="odmg/Pobject.html">ODMG/C Pobject</a>@ 
and @[<a href="odmg/Attribute.html">ODMG/C Attribute</a>@ interfaces.
\item The @[<a href="CC_odmg/CC_Pobject.html">ODMG/C++ Pobject</a>@ 
and @[<a href="CC_odmg/CC_Attribute.html">ODMG/C++ Attribute</a>@ classes.
\item The @[<a href="jOdmg/odmg.Pobject.html">ODMG/Java Pobject</a>@
and @[<a href="jOdmg/odmg.Attribute.html">ODMG/Java Attribute</a>@ classes.
\end{itemize}

@+ Sets
@T
The Monet/ODMG system has a simplified collection scheme in the sense
that only sets and bags are supported. Actually, sets are bags
that may or may not have the {\bf unique} property set. Monet/ODMG sets 
violate a second rule in that they have some concept of order in which
the set elements are stored. This turns up when we iterate over all
items in a Set; when the Set is marked 'sorted', they will then appear 
in ordered fashion. The ordering of the elemnts ion a set is not stable 
under updates. 

Monet/ODMG does not implement {\bf sets of sets}. You might work around 
them by introducing a new object that contains a set-valued attribute.
In the method definitions of the Set interface you will also see overloaded
methods with Set-parameters having different semantics than Value-parameters
(i.e. you cannot store Sets as values in a Set).
@odl
        interface Iterator; 

        interface Set<Value> : Pobject { 
                destroy();

                boolean unique(); // return TRUE => set, FALSE => bag
                unique(boolean);  // modify semantics (bag => set removes doubles) 

                Set<Value> copy();
                Set<Value> sort(); // returns sorted copy

                boolean sorted();
                int cardinality(); // returns number of elements  
                boolean empty();
                boolean operator "!=" (Set);
                boolean operator "==" (Set); 
@
sets are equal if a 1-1 mapping between elements exist that combines
elements that are equal.
@odl 
                void insert(Value);
                void delete(Value);
                void insert(Set);
                void delete(Set);

                Iterator<Value> iterator(boolean);

                boolean contains (Value)
                Value any (); // does not remove it! returns nil if set empty.
        }

@- set updates
Sets can be updated one-value-at-a-time or set-at-a-time. Note that a
Set is an Object and hence a value. The overloaded set-at-a-time definition
of the update function then prevails (as stated before, sets-of-sets are 
broken, so the interpretation of a Set as a Value will never occur in 
Monet/ODMG).

@- set iterating
@T
One can iterate over all elements in a Set by creating an 
@[<a href="#mod_1_6_0" target="_self">Iterator</a>@ 
object. Iterators also allow you to delete or replace the current value 
of a Set. Concurrent updating has to be explictly protected by the programmer
using the @[<a href="#mod_1_7_0" target="_self">transaction mechanism</a>@. 

However, you must not only be protected from the effects of updates by
others, but also from update effects caused by yourself:
\begin{itemize}
\item you may not use the insert/delete methods on a set which one is 
         iterating over at that same moment.
\item if you are iterating over a set that is a set-valued attribute value of
            some persistent object, you may not even update any other object
        on that same attribute (both sets are stored in the same Monet table)!
\item if you are iterating over an 'extent' set of some class, then any object 
        creation or destruction in that class causes an implicit update of 
        the extent-set! You must realize that an extent-set contains all valid 
        objects of some class that exist at current moment.
\end{itemize}
These restrictions can be overcome at the cost of making copy of the
set before starting to iterate over it. For this purpose the Iterator creation 
function has one extra boolean parameter 'stable'.
With this parameter one can specify whether one expects updates to happen while iterating. Setting 'stable' to TRUE must hence be seen as a performance 
optimization in cases that you are very sure you are not performing any updates.

@- bugs
As said before, lack of an orthogonal approach to mapping ODL structures to
Monet causes the fact that Set<Set<T>> is unsupported. We also should
reorganize Sets in a hierarchy of Collection with Bag and List as 
additional interfaces.

@- Interface Reference 
The following language-specific reference documents exist for this interface:
@T
\begin{itemize}
\item The @[<a href="odmg/Set.html">ODMG/C Set</a>@ interface 
contains object Set manipulations as well.
\item The @[<a href="CC_odmg/CC_Set.html">ODMG/C++ Set</a>@ class
contains object Set manipulations as well.
\item The @[<a href="jOdmg/odmg.Set.html">ODMG/Java Set</a>@ class.
\end{itemize}

@+ Object-sets
@T
We can define special operations on Sets that contain Pobjects.
These operations manipulate attribute values of the Pobjects. The language 
bindings only allow homogeneous sets (two elements must be of the same class 
or one must be a superclass of the other). Attributes of the highest common 
subclass can be used in these operations. Passing illegal Attribute-identifiers
will lead to run-time errors.
@odl
        interface Set<Pobject> : Set<Value> { 
                Set<Pobject> sort(Attribute);

                Pobject find (Value, Attribute); // find an object with a certain attribute value 
                Pobject find (Set, Attribute);   // set-valued attribute 'find'

                Set<Pobject> select (Value low, Value high, Attribute);
                boolean exists (Value low, Value high, Attribute);

                Set<Value> follow(Attribute);
        };

@- sorting
You can sort a set/bag of objects also according to an attribute value
(instead of the implicit OID order) by passing an attribute-identifier.

@- simple queries
@T
We support the 'find' method that allows 
to find an object that has some attribute value.
A specific version is present for set-valued attributes. {\bf BUG}: it actually
returns any object that has a attribute-value that is a {\bf superset} of 
the search-value}.

The 'select' method selects all objects that have an attribute value 
in [low..high]. You can use the nil Value of the respective type to
denote (minus) infinity. The 'exists' method is contraction of
'select(..).empty()'.

@- navigation
The @%follow@ operation retrieves all attribute values of a set/bag of
Pobjects into a new bag. 

@- Interface Reference 
The following language-specific reference documents exist for this interface:
@T
\begin{itemize}
\item The @[<a href="odmg/Set.html">ODMG/C Set</a>@ interface.
\item The @[<a href="CC_odmg/CC_Set.html">ODMG/C++ Set</a>@ class.
\item The @[<a href="jOdmg/odmg.OidSet.html">ODMG/Java OidSet</a>@ class.
\end{itemize}

@+ Iterators
@T
Iterators allow for iterating one by one over the elements of a set.

The iterator maintains
the abstraction of a 'current' element. At the start, this 'current' is
undefined. A call to the 'next()' method will set this 'current' to a 
previously unvisited value of the set (if any). It then returns TRUE. 
If there are no more elements to visit, 
it returns FALSE and the current pointer is inconsistent again.

@odl
        interface Iterator<Value> {
                boolean next();
                Value retrieve();

                int getpos();
                void setpos(int);

                void replace(Value);
                void remove();

                void reset();
                void close();
        };
@T
The 'retrieve' operation retrieves the current value. If the current 
pointer is inconsistent, it returns a nil value.
You are expected to use the iterator 'it' like:
{\tt\small while(it.next()) \{ Value v = it.retrieve(); \}}

@- positional access
Internally, some ordering exist on the elements of a set with N elements, 
so we could number them from element 0 till N-1. We can inquire about
it with 'getpos' and set it with 'nextpos'.
When the 'current' is inconsistent, the return values of 'getpos' will
also be inconsistent. 

@- updates while iterating
@T
The current value can be replaced with 'replace'. It can also be removed
with 'remove'. This leaves the 'current' pointer in inconsistent state
till the next call to 'next()'. 

Take also good notice of the restrictions on how you can update Sets while 
iterating over them at the same time, as described in the Set section.
@
The 'reset' method lets the iterator start from the beginning again.
The 'close' is a destructor of the iterator. All updates made while
iterating are committed.

@- Interface Reference 
The following language-specific reference documents exist for this interface:
@T
\begin{itemize}
\item The @[<a href="odmg/Iterator.html">ODMG/C Iterator</a>@ interface.
\item The @[<a href="CC_odmg/CC_Iterator.html">ODMG/C++ Iterator</a>@ class.
\item The @[<a href="jOdmg/odmg.Iterator.html">ODMG/Java Iterator</a>@ class.
\end{itemize}

@+ Transactions
@T
Monet/ODMG implements a simple, non-nested, transaction model. The main
goal is to provide Atomicity and Isolation. Operating in a transaction 
gives you a consistent view of the database state, which is a stable copy 
taken from the start of the transaction. 
Updates made by other transactions, that might execute in parallel in
another thread of execution, are simply not seen. 
The changes made by you during the transaction can be either committed or 
aborted totally, and the transactions ends then.

Durability and Consistency (the other two letters from ACID) must be
ensured manually by the application programmer by locking objects.
Three kinds of locks are provided: read, write and upgrade. Below
we show a compatibility matrix of locks on an object: 
{\center\bf\begin{tabular}{r|l|l|l}
               & unlocked & read-locked & upgrade-locked & write-locked \hline\\
   lock(read)  &  proceed & proceed     & block          & block \hline\\
lock(upgrade)  &  proceed & proceed     & block          & block \hline\\
  lock(write)  &  proceed & block       & block          & block \\
\hline\end{tabular}}

Each row shows whether a transaction will be allowed to
start if it requires a lock on an object that is in a
certain state. The state is defined as which type of 
claims previously started transactions that are still alive
hold on the object.
@odl
        enum lockmode { LOCK_RELEASE, LOCK_READ, LOCK_UPGRADE, LOCK_WRITE };

        interface Transaction {
                void lock_reserve(Pobject, lockmode);
                void lock_reserve(Set, lockmode);

                void begin();  // wait till all reserved locks are acquired

                void lock_change(Pobject, lockmode);
                void lock_change(Set, lockmode);

                void abort();  // undo all changes, release all locks
                void commit(); // commit all changes, release all locks

		void destroy(); // destroy the transaction object
        };
@T
A transaction must specify all its locks before starting. This is done
with the 'lock\_reserve' methods. Calls to this method after issueing
'begin' will give run-time errors. The collection of reserved locks is 
not changed by abort/commit or even 'lock\_change' calls. One can thus
easily reuse a transaction object that was once specified in many repeating
transactions.

When a 'begin' is called the transaction will try to start. It will
block until the moment that it is able to acquire all reserved locks
in atomic way (it will acquire them all and start, or will acquire none 
and stay blocked). One thread of execution can only have one transaction 
started at the same time. Issueing 'begin' when the same thread of executiion
is running another transaction already, will cause a run-time error. 

During the transaction lock-modes on reserved locks can be changed with
the 'lock\_change' method. Trying to change mode on locks that were never
reserved will cause run-time errors. Only upgrade locks can be 
upgraded to write locks. Other locks can only be downgraded (going down from 
write to upgrade, to read to unlocked). 
When an upgrade lock is upgraded to a write lock, the transaction will 
block till all other transactions holding locks on the object(s) involved 
have released it. 

Note that if a previous transaction holds a read lock, the system will
let a subsequent transaction with an upgrade lock start, but the
other way around not (a previous upgrade lock impedes an read lock). 
Translated into plain english this means that transactions
can only wait for transactions that started earlier. It is hence
easy to see that this scheme is deadlock-free.

@- real-time access outside transactions
@T
Some applications, like a telephone central renumbering database need 
real-time read access to data. These applications might not need the 
very last version of the data, but might do with a 'recent' version of 
the data-item.

If you read data in Monet/ODMG outside a transaction, without acquiring
any locks, no serious problems will occur. You will just get a
'possibly outdated' view of all data. That is, all changes made by 
transactions that up to that point have committed, are visible.
It might be that other transactions have already modified the data that you
read, but still have not committed. For certain classes of applicstions
though, this is not a real problem.

This is supported in Monet/ODMG by letting read-actions outside any
transaction proceed {\bf without acquiring any locks}! Update transactions work
on copies that are unified at commit time. This potentially could cause
problems, but by atomical version switching with delayed deallocation of
old handles it was possible to provide the 'stable' data to read-only
transactions without any locking. 

@- bugs
@T
The transaction mechanismn in ODMG/Java does not support multiple
threads executing different transactions in parallel in the same applet. 
It does provide single-transaction distributed ACID properties.

{\bf Write-access outside a transaction should trigger run-time 
     errors!}  

@- Interface Reference 
The following language-specific reference documents exist for this interface:
@T
\begin{itemize}
\item The @[<a href="odmg/Transaction.html">ODMG/C Transaction</a>@ interface.
\item The @[<a href="CC_odmg/CC_Transaction.html">ODMG/C++ Transaction</a>@ class.
\item The @[<a href="jOdmg/odmg.Transaction.html">ODMG/Java Transaction</a>@ class.
\end{itemize}


@+ Database
@T
A database provides a handle to an object store. In this object store,
(sets of) persistent objects are present. After the contact with
the object store has been established ('open' the database), 
objects can be looked up by name. These looked-up objects are the 
'entry-points' of the application to the database. More data can
then be accessed by navigating from one object to the other. 

The ODL language also allows to give logical names to the extent-set of 
each class. An extent-set contains all current instances of a certain 
class. More logical names to objects in the database can be 
added by hand by the users.  
@odl
        interface Database {
                boolean open(string); // "dbname" or "host:port"
                void close();

                Pobject lookup(string);
                void name (Pobject, string);
                string name (Pobject); // return nil if it has no name
                void unname (Pobject, string);
        };
@- bugs
At this moment, named sets (apart from extents) are not supported.

@- Interface Reference 
The following language-specific reference documents exist for this interface:
@T
\begin{itemize}
\item The @[<a href="odmg/Database.html">ODMG/C Database</a>@ interface.
\item The @[<a href="CC_odmg/CC_Database.html">ODMG/C++ Database</a>@ class.
\item The @[<a href="jOdmg/odmg.Database.html">ODMG/Java Database</a>@ class.
\end{itemize}



@+ Monet Database
@T
Monet/ODMG is a layer built on top of @[<a href="monet.html">Monet</a>@,
and, until an OQL translator is present, ad-hoc queries can only
be executed with @[<a href="mil.html">MIL</a>@
(the algebraic MIL language allows to manipulate atomic values or binary 
tables (BATs) of atomic values, and is the direct query interface to Monet). 

Each Monet/ODL structure is mapped in some way to the Monet world of 
atoms and BATs. To simplify administration, each ODL type structure is 
symbolized by an ID (currently an integer). Structure IDs for atomic types
and subclasses of Pobject are available to the programmer
as constants in the system. 

The mapping of atomic values in ODL to Monet is just one to one. 
Sets of persistent objects are vertically decomposed  in Monet tables:
each ODL class has an 'extent' BAT that contains the OIDS of all current
objects in the left column, and the ID of their most specific subclass 
in the right column. Each attribute of the class is stored in an additional 
BAT, with OIDs in the left column, and attribute values in the right 
column. Object references are represented in Monet BATs as OIDs.  

For a further reference we refer to the 
@[<a href="monet.html">Monet Documentation</a>@
and @[<a href="mil.html">MIL Reference Manual</a>@.
@odl
        interface MonetDatabase : Database {
		boolean mil(string mil);

                Value mil_value(string valexpr, int eltid);
                Set<Value> mil_set(string batexpr, int eltid);
                Set<Value> mil_subset(string batexpr, int eltid, oid subset);

		Attribute mil_attr(string batexpr, int eltid, boolean Set);

                string lasterror();
        };
};
@- ad hoc queries
@T
The simplest way of executing something on the Monet server is
by the 'mil' method, but this returns nothing but an error status.

The 'mil_value' method executes a MIL expression that is supposed to yield 
a single (non BAT) value, which is returned. You must specify the structure
you expect beforehand. 

If the result of your MIL expression is a BAT, then the left column of this
BAT can be mapped instantly to a set of ODMG values using the 'set' method.
You can provide the structure ID of the highest common class, and the
system will automatically resolve each object to its most specific subclass.

A collection of values in the left column of a BAT can be restricted 
to a subset by restricting it to just the subset of values that have 
a certain OID in the right column. This is what the 'subset' method does.

@- errors
The 'mil' method returns TRUE on success and FALSE if errors occurred.
All other methods produce nil return values if errors occurred.
The 'lasterror' method gives a string error message corrsponding to 
the last 'mil_*' call.

@- bugs
Again, in an orthogonal type-system, the structure id's should 
be able to describe nested types. The manual distinction between 
'mil_value', 'mil_set', and 'mil_subset' can then disappear.

@- Interface Reference 
The following language-specific reference documents exist for this interface:
@T
\begin{itemize}
\item The @[<a href="odmg/MonetDatabase.html">ODMG/C MonetDatabase</a>@ interface.
\item The @[<a href="CC_odmg/CC_MonetDatabase.html">ODMG/C++ MonetDatabase</a>@ class.
\item The @[<a href="jOdmg/odmg.MonetDatabase.html">ODMG/Java MonetDatabase</a>@ class.
\end{itemize}

