@f meta
@d 04/11/1997
@a Peter Boncz, Niels Nes
@* The ODMG Meta Module 
@T
The information about the available datamodels -- that what in relational 
systems is called 'data dictionary' -- in Monet/ODMG is stored in a built-in
ODL module, which can be accessed just like any other ODL datastructure.
This document contains the ODL specification of this module with some
explications.
 
\begin{center}
{\epsfxsize=0.60\textwidth
\epsffile{odmg_meta.eps}
{\em The Meta Module and its place in the Monet/ODMG System}}
\end{center}

More information on the Monet/ODMG system can be found in the following
reference material:
\begin{itemize}
\item The @[<a href="monet.html">Monet Documentation</a>@
for more information on availability,
installing, and a general system overview.
\item The @[<a href="odl.html">ODL Reference Manual</a>@
for an exact definition of Monet/ODL. It was derived from the ODMG1.X
definition and introduces atomic extensibility but lacks some other features.
It differs widely from ODMG2.0.
\item See the @[<a href="man/odlp.html">Manual Page</a>@
for the exact calling options of the ODL parser.
\item The @[<a href="stdlib.html">ODMG Standard Library Reference</a>@
defines which standard facilities are present in ODMG, and what is their
exact interface in the ODMG/\{Java, C, C++\} programming environments
respectively.
\item The @[<a href="Example.html">Example ODL Model</a>@
introduces a simple Customer-Order-Item model and shows how this
can be accessed in the ODMG/C, ODMG/C++ and ODMG/Java environments
through stub classes.
\item The @[<a href="app.html">Example ODMG Application</a>@
uses the same data-model to build a simple application for
internet sales, that demonstrates easily how all system components
work and fit together.
\end{itemize}

 
@* The Meta Repository 
@odl
module meta {
	interface Class;
	interface Member;
	interface Link;
	interface Method;
	interface Func;

@- named objects
The named object repository that is available via Database.lookup can
also be visited by scanning the NamedObjects extent Set.
TODO: set-valued items cannot be stored for the moment.
@odl
	interface NamedObject( extent NamedObjects key Name ){
	   	attribute string Name;
		attribute oid theObject; 
		attribute int ClassId;
	};

@- registered ODL modules
@T
This is a straightforward scheme that shows on the ODL level how 
all meta-data about ODL schema's is stored. Binary tables in Monet (BATs)
are symbolized by Attribute identifiers at the ODL level.
This file is actually never fed through the ODL parsers because
this would cause chicken-or-egg problems (whoever was first).

The FUTURE lines contain method calls that will be added in the future
with which the ODL model can be extended at run-time.
@odl
	interface Module ( extent Modules key Name) persistent {
		attribute string Name;
 		relationship Set<Class> Classes inverse Class::theModule;
 		relationship Set<Func> Functions inverse Func::theModule;

		#FUTURE Class new_class(string name, string extent);
		#FUTURE void del_class(Class);
	};

	interface Class ( extent Classes key Name ) persistent {
		attribute string Name;
		attribute string ExtentName;
		attribute int ClassId;
		attribute Attribute extent;

 		relationship Set<Member> Members inverse Member::theClass;
 		relationship Set<Method> Methods inverse Method::theClass;

 		relationship Set<Class> Supers inverse Deriveds;
 		relationship Set<Class> Deriveds inverse Supers;

 		relationship Module theModule inverse Module::Classes;

		#FUTURE Member new_member(string name, int TypeId, boolean Set);
		#FUTURE Link new_link(string name, int ClassId, boolean Set, 
		#FUTURE		      Link reverse);
	};

	interface Member ( extent Members key Name ) persistent {
		attribute string Name;
		attribute int TypeId;
		attribute Attribute attr;
 		relationship Class theClass inverse Class::Members;
	};

	interface Link : Member ( extent Links ) persistent {
 		relationship Link Inverse;
	};

	interface Method ( extent Methods key Name ) persistent {
		attribute string Name;
		attribute ptr theFunc;
 		relationship Class theClass inverse Class::Methods;
	};

	interface Func ( extent Functions key Name ) persistent {
		attribute string Name;
		attribute ptr theFunc;
 		relationship Module theModule inverse Module::Functions;
	};
};
@
