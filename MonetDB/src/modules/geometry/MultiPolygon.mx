@f MultiPolygon
@a C.W. Quak
@h
#ifndef __MULTIPOLYGON_H__
#define __MULTIPOLYGON_H__

class MultiPolygon : public varray
{
public:
   //
   // Operations needed by Monet.
   //
   int hash() const;
   bool OK() const;
   bool operator==(const MultiPolygon& r) const;
   bool operator!=(const MultiPolygon& r) const;

   const Polygon& geometry(int index) const;
   Polygon& geometry(int index);

   static MultiPolygon* null();

   static MultiPolygon* create(int nitems,int usedbytes);
   static MultiPolygon* create(Array<Polygon*> items);
   static MultiPolygon* fromstr(char *s,int* parselen,int *buflen,MultiPolygon* p);
   int tostr(char* s,int len) const;
   int expectedstrlen() const;

   MultiPolygon* copy() const;

   int dimension() const;

   //
   // Update operations.
   //
   MultiPolygon* additem(const Polygon& p);
};

inline int MultiPolygon::dimension() const
{
   return(2);
}

#endif /* __MULTIPOLYGON_H__ */
@C
#include "geometry.h"
#include "opengis.h"

#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

MultiPolygon* MultiPolygon::copy() const
{
   return((MultiPolygon *)varray::copy());
}

MultiPolygon* MultiPolygon::create(int nitems,int usedbytes)
{
   return((MultiPolygon *)varray::create(nitems,usedbytes));
}

int MultiPolygon::expectedstrlen() const
{
   return(20 + (nbytes() * 10));
}

int MultiPolygon::tostr(char* string,int len) const
{
   int rval = 0;

   rval += sprintf(string + rval,"(%d:", nitems());

   for (int i = 0; i < nitems();++i)
   {
      rval += geometry(i).tostr(string + rval,len - rval);
   }
   rval += sprintf(string + rval,")");

   if (rval > len)
      GDKwarning("Increase value of MultiPolygon::expectedstrlen()\n");
   return(rval);
}

MultiPolygon* MultiPolygon::fromstr(char *,int* ,int *,MultiPolygon*)
{
   return(NULL);
}

MultiPolygon* MultiPolygon::additem(const Polygon& p)
{
   MultiPolygon* rval = (MultiPolygon* )insert(&p);
   return(rval);
}

int MultiPolygon::hash() const
{
   return(nitems());
}

bool MultiPolygon::operator!=(const MultiPolygon& r) const
{
   return(!(*this == r));
}

bool MultiPolygon::operator==(const MultiPolygon& r) const
{
   if (nitems() != r.nitems())
      return(false);

   int i;
   for(i=0;i<nitems();++i)
   {
      if (geometry(i) != r.geometry(i))
         break;
   }
   if (i == nitems())
      return(true);
   
   GDKwarning("MultiPolygon_comp not fully implemented yet");
   return(false);
}

bool MultiPolygon::OK() const
{
   varray::OK();

   if (nitems() < 0)
   {
      GDKerror("MultiPolygon with %d items \n",nitems());
      return(false);
   }

   for(int i=0;i<nitems();++i)
   {
      if (!geometry(i).OK())
      {
	 GDKerror("item %d of MultiPolygon is not ok\n",i);
	 return(false);
      }
   }

   return(true);
}

MultiPolygon* MultiPolygon::null()
{
   return((MultiPolygon *)varray::null());
}

Polygon& MultiPolygon::geometry(int i)
{
   return(*(Polygon *)(varray::item(i)));
}

const Polygon& MultiPolygon::geometry(int i) const
{
   return(*(const Polygon *)(varray::item(i)));
}

MultiPolygon* MultiPolygon::create(Array<Polygon*> items)
{
   MultiPolygon* rval = MultiPolygon::create(items.nitems(),3000);
   for(int i = 0; i < items.nitems();++i)
   {
      rval = rval->additem(*(items[i]));
   }
   return(rval);
}
