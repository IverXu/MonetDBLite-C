@f rtree_segment
@A C.W. Quak
@* The 'rtree_segment' accelerator for boxes.
@h
#ifndef __RTREE_SEGMENT_H__
#define __RTREE_SEGMENT_H__

extern BAT* join_param_segment_segment(BAT* left,BAT* right,const int type);
extern BAT* select_param_segment_segment(BAT* seglist,const segment& s,const int type);
extern BAT* select_overlap_segment_box(BAT* seglist,const box& b);
extern BAT* join_overlap_segment_segment(BAT* left,BAT* right);

#endif /* __RTREE_SEGMENT_H__ */
@C
#include "gis.h"
#include "opengis.h"
#include "gisbulk.proto.h"
#include "rtree.h"
#include "rtree_segment.h"

//
// Build an RTREE index on the head of the given bat.
//
// PRE: The bat must be of type (segment,any).
//
void RTREEbuild_segment(
   Heap* heap,
   int*,
   BAT* bat)
{
   if (BAThtype(bat) != TYPE_segment)
   {
      GDKerror("Cannot build RTREE because head not of type segment\n");
      return;
   }

   bat->hacctype = ACC_rtree_segment;
   RTREEcreate(heap);


   //
   // Insert all buns into the heap.
   //
   {
      BUN index,dummy;

      BATloop(bat,index,dummy)
      {
	 RTREEinsert_segment(heap,BUNindex(bat,index),bat,(segment *)BUNhead(bat, index));
      }
   }
}

static void RTREE_local_select(
   BAT* rectlist,
   Heap* heap,
   int nodeindex,
   const segment& s,
   const box& b,
   const int type,
   BAT* result)
{
   RTREEnode* self = RTREEindex(heap,nodeindex);

   if (!overlap(self->bbox,b))
      return;

   if (self->isleaf())
   {
      for(int i = 0;i<self->number;++i)
      {
	 BUN bun = (BUN)BUNptr(rectlist,self->entries[i]);
	 segment *t = (segment *)BUNtail(rectlist,bun);
	 segment dummy;
	 if (intRelate(*t,s,dummy) >= type)
	 {
            BUNins(result,BUNhead(rectlist,bun),t);
	 }
      }
   }
   else
   {
      for(int i = 0;i < self->number;++i)
	 RTREE_local_select(rectlist,heap,self->entries[i],s,b,type,result);
   }
}

//
// Select all rectangles from the rectlist which relate to box b.
//
BAT* select_param_segment_segment(BAT* seglist,const segment& s,const int type)
{
   box b(s.bbox());
   BAT* result = BATnew(BAThtype(seglist),BATttype(seglist),BATcount(seglist)/10);
   Heap* heap = &seglist->taccelerator;

   if (heap->base == NULL)
   {
      GDKerror("This BAT has no index");
      return(NULL);
   }

   int rootindex = RTREErootindex(heap);

   if (rootindex != 0)
      RTREE_local_select(seglist,heap,rootindex,s,b,type,result);

   return(result);
}

static void RTREE_local_select(
   BAT* rectlist,
   Heap* heap,
   int nodeindex,
   const box& b,
   BAT* result)
{
   RTREEnode* self = RTREEindex(heap,nodeindex);

   if (!overlap(self->bbox,b))
      return;

   if (self->isleaf())
   {
      for(int i = 0;i<self->number;++i)
      {
	 BUN bun = (BUN)BUNptr(rectlist,self->entries[i]);
	 segment *t = (segment *)BUNtail(rectlist,bun);
	 BUNins(result,BUNhead(rectlist,bun),t);
      }
   }
   else
   {
      for(int i = 0;i < self->number;++i)
	 RTREE_local_select(rectlist,heap,self->entries[i],b,result);
   }
}

BAT* select_overlap_segment_box(BAT* seglist,const box& b)
{
   BAT* result = BATnew(BAThtype(seglist),BATttype(seglist),BATcount(seglist)/10);
   Heap* heap = &seglist->taccelerator;

   if (heap->base == NULL)
   {
      GDKerror("This BAT has no index");
      return(NULL);
   }

   int rootindex = RTREErootindex(heap);

   if (rootindex != 0)
      RTREE_local_select(seglist,heap,rootindex,b,result);

   return(result);
}
//------------------------------------------------------------------------
void RTREE_RTREE_local_join(
   BAT* batleft,
   BAT* batright,
   Heap* heapleft,
   Heap* heapright,
   int nodeleft,
   int noderight,
   const int type,
   BAT* result)
{
   RTREEnode* leftptr = RTREEindex(heapleft,nodeleft);
   RTREEnode* rightptr = RTREEindex(heapright,noderight);

   //
   // If bounding boxes do not overlap the join is empty
   //
   if (!overlap(leftptr->bbox,rightptr->bbox))
      return;

   //
   // If both are leaves we are at the deepest level and must compare al pairs.
   //
   if ((leftptr->isleaf()) && (rightptr->isleaf()))
   {
      for(int i=0;i<leftptr->number;++i)
      {
	 segment* leftseg = (segment *)BUNtail(batleft,BUNptr(batleft,leftptr->entries[i]));

	 for(int j=0;j<rightptr->number;++j)
	 {
	    segment* rightseg = (segment *)BUNhead(batright,BUNptr(batright,rightptr->entries[j]));
	    segment dummy;

	    if (intRelate(*leftseg,*rightseg,dummy) >= type)
	    {
	       BUNins(result,
		  BUNhead(batleft,BUNptr(batleft,leftptr->entries[i])),
		  BUNtail(batright,BUNptr(batright,rightptr->entries[j])));
	    }
	 }
      }
   }
   else
   {
      /*
      // We must decide which node we enter. If we can choose (when both node
      // are intermediate nodes) we choose the largest node.
      */
      int deepen;
      if (leftptr->isleaf())
	 deepen = RIGHTBOX;
      else if (rightptr->isleaf())
	 deepen = LEFTBOX;
      else
      {
	 if (leftptr->bbox.area() > rightptr->bbox.area())
	    deepen = LEFTBOX;
	 else
	    deepen = RIGHTBOX;
      }

      if (deepen == LEFTBOX)
      {

	 for(int i=0;i<leftptr->number;++i)
	 {
	    RTREE_RTREE_local_join(
	       batleft,batright, heapleft,heapright,
	       leftptr->entries[i],noderight,
	       type,result);
	 }
      }
      else // we go into the right node
      {
	 for(int j=0;j<rightptr->number;++j)
	 {
	    RTREE_RTREE_local_join(
	       batleft,batright, heapleft,heapright,
	       nodeleft,rightptr->entries[j],
	       type,result);
	 }
      }
   }
}

BAT* join_param_segment_segment(BAT* left,BAT* right,const int type)
{
   Heap* heapleft = &(left->taccelerator);
   Heap* heapright = &(right->haccelerator);
   int leftrootindex = RTREErootindex(heapleft);
   int rightrootindex = RTREErootindex(heapright);


   //
   // We create a BAT for the joined pairs.
   // res_tuples should be set to the expected number of BUNs in the result.
   //
   int res_tuples = 1000;
   BAT* result = BATnew(BAThtype(left),BATttype(right),res_tuples);

   if ((leftrootindex != 0) && (rightrootindex != 0))
   {
      RTREE_RTREE_local_join(
	 left, right,
	 heapleft, heapright,
	 leftrootindex,
	 rightrootindex,
	 type,
	 result);
   }
   return(result);
}
//------------------------------------------------------------------------
static void RTREE_RTREE_local_join_overlap(
   BAT* batleft,
   BAT* batright,
   Heap* heapleft,
   Heap* heapright,
   int nodeleft,
   int noderight,
   BAT* result)
{
   RTREEnode* leftptr = RTREEindex(heapleft,nodeleft);
   RTREEnode* rightptr = RTREEindex(heapright,noderight);

   //
   // If bounding boxes do not overlap the join is empty
   //
   if (!overlap(leftptr->bbox,rightptr->bbox))
      return;

   //
   // If both are leaves we are at the deepest level and must compare al pairs.
   //
   if ((leftptr->isleaf()) && (rightptr->isleaf()))
   {
      for(int i=leftptr->number - 1;i>=0;--i)
      {
	 segment* leftseg = (segment *)BUNtail(batleft,BUNptr(batleft,leftptr->entries[i]));

	 for(int j=rightptr->number - 1;j>=0;--j)
	 {
	    segment* rightseg = (segment *)BUNhead(batright,BUNptr(batright,rightptr->entries[j]));

	    segment dummy;
	    int rel = intRelate(*leftseg,*rightseg,dummy);
	    if ((rel != relationship::DISJOINT) && (rel != relationship::TOUCH))
	    {
	       BUNins(result,
		  BUNhead(batleft,BUNptr(batleft,leftptr->entries[i])),
		  BUNtail(batright,BUNptr(batright,rightptr->entries[j])));
	    }
	 }
      }
   }
   else
   {
      /*
      // We must decide which node we enter. If we can choose (when both node
      // are intermediate nodes) we choose the largest node.
      */
      int deepen;
      if (leftptr->isleaf())
	 deepen = RIGHTBOX;
      else if (rightptr->isleaf())
	 deepen = LEFTBOX;
      else
      {
	 if (leftptr->bbox.area() > rightptr->bbox.area())
	    deepen = LEFTBOX;
	 else
	    deepen = RIGHTBOX;
      }

      if (deepen == LEFTBOX)
      {

	 for(int i=leftptr->number-1;i>=0;--i)
	 {
	    RTREE_RTREE_local_join_overlap(
	       batleft,batright, heapleft,heapright,
	       leftptr->entries[i],noderight,
	       result);
	 }
      }
      else // we go into the right node
      {
	 for(int j=rightptr->number-1;j>=0;--j)
	 {
	    RTREE_RTREE_local_join_overlap(
	       batleft,batright, heapleft,heapright,
	       nodeleft,rightptr->entries[j],
	       result);
	 }
      }
   }
}

BAT* join_overlap_segment_segment(BAT* left,BAT* right)
{
   BAT* result;
   Heap* heapleft = &(left->taccelerator);
   Heap* heapright = &(right->haccelerator);
   int leftrootindex = RTREErootindex(heapleft);
   int rightrootindex = RTREErootindex(heapright);


   /*
   // We create a BAT for the joined pairs.
   // res_tuples should be set to the expected number of BUNs in the result.
   */
   {
      int res_tuples = 1000;
      result = BATnew(BAThtype(left),BATttype(right),res_tuples);
   }

   if ((leftrootindex != 0) && (rightrootindex != 0))
   {
      RTREE_RTREE_local_join_overlap(
	 left, right,
	 heapleft, heapright,
	 leftrootindex,
	 rightrootindex,
	 result);
   }
   return(result);
}
