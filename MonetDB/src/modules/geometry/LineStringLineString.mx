@f LineStringLineString
@A C.W. Quak
@h
#ifndef __LINESTRINGLINESTRING_H__
#define __LINESTRINGLINESTRING_H__

extern bool Relate(const LineString& l1,const LineString& l2,const char matrix[9]);
extern relationship Relate(const LineString& l1,const LineString& l2);

#endif /* __LINESTRINGLINESTRING_H__ */
@C
#include "geometry.h"
#include "opengis.h"
#include "minirealm.h"

//
//===============================================
// Dimensionally Extended Nine-Intersection Model
//===============================================
//

static bool check_bbox(
   const LineString& l1,
   const LineString& l2,
   relmatrix& rel)
{
   if (!overlap(l1.bbox(),l2.bbox()))
   {
      rel.setdimension(0,-1);
      rel.setdimension(1,-1);
      rel.setdimension(2, 1);
      rel.setdimension(3,-1);
      rel.setdimension(4,-1);
      rel.setdimension(5, (l1.closed()?-1:0));
      rel.setdimension(6, 1);
      rel.setdimension(7, (l2.closed()?-1:0));
      rel.setdimension(8, 2);
      return(true);
   }
   else
      return(false);
}


static bool calc_026(
   const LineString& l1,
   const LineString& l2,
   relmatrix& rel)
{
   MultiPoint* l1b = l1.boundary();
   MultiPoint* l2b = l2.boundary();

   minirealm m(l1b,l2b);
   
   rel.setdimension(relationship::INTERIOR_EXTERIOR,-1);
   rel.setdimension(relationship::INTERIOR_INTERIOR,-1);
   rel.setdimension(relationship::EXTERIOR_INTERIOR,-1);

   m.add_nonintersect(l1,true,false);
   for(int j=0;j<l2.nsegments();++j)
   {
      m.add(l2.sgmt(j),false,true);
      if (m.dimab == 0)
      {
	 if (rel.setdimension(relationship::INTERIOR_INTERIOR,0))
	    return(true);
      }
      if (m.dimab == 1)
      {
	 if (rel.setdimension(relationship::INTERIOR_INTERIOR,1))
	    return(true);
      }
   }

   for(int k=0;k<m.lines.nitems();++k)
   {
      if (m.lines[k].a)
      {
         if (m.lines[k].b)
	 {
	    if (rel.setdimension(relationship::INTERIOR_INTERIOR,1))
	       return(true);
	 }
	 else
         {
	    if (rel.setdimension(relationship::INTERIOR_EXTERIOR,1))
	       return(true);
	 }
      }
      else
      {
         if (m.lines[k].b)
	 {
	    if (rel.setdimension(relationship::EXTERIOR_INTERIOR,1))
	       return(true);
	 }
	 else
	 {

	    GDKerror("There is a realm [%d] line with no line\n",k);
	    m.dump();
	 }
      }
   }
   rel.setdimension(relationship::INTERIOR_INTERIOR,m.dimab);
   return(false);
}

static bool calc_0(
   const LineString& l1,
   const LineString& l2,
   relmatrix& rel)
{
   if (l1.hasminitree() && l2.hasminitree())
   {
      MultiPoint* l1b = l1.boundary();
      MultiPoint* l2b = l2.boundary();

      return(calc_0(
         l1,
	 l1.getminitree(),
	 *l1b,
         l2,
	 l2.getminitree(),
	 *l2b,
	 rel));
   }
   else
   {
      return(calc_026(l1,l2,rel));
   }
}

static bool calc_134578(
   const LineString& l1,
   const LineString& l2,
   relmatrix& rel)
{
   MultiPoint* bnd1 = l1.boundary();
   MultiPoint* bnd2 = l2.boundary();

   rel.setdimension(8,2);

   //
   // Calculate the boundary_* intersection.
   //
   {
      rel.setdimension(4,-1);
      rel.setdimension(3,-1);
      rel.setdimension(5,-1);

      for(int i=0;i<bnd1->npoints();++i)
      {
	 const point& p = bnd1->pnt(i);

	 if (bnd2->contains(p))
	 {
	    if (rel.setdimension(4,0))
	       return(true);
	 }
	 else if (contains(l2,p))
	 {
	    if (rel.setdimension(3,0))
	       return(true);
	 }
	 else
	 {
	    if (rel.setdimension(5,0))
	       return(true);
	 }
      }
   }

   //
   // Calculate the *_boundary intersection.
   // Of course we did boundary_boundary above.
   //
   {
      rel.setdimension(1,-1);
      rel.setdimension(7,-1);

      for(int i=0;i<bnd2->npoints();++i)
      {
	 const point& p = bnd2->pnt(i);

	 if (bnd1->contains(p))
	 {
	    if (rel.setdimension(4,0))
	       return(true); // redundant.
	 }
	 else if (contains(l1,p))
	 {
	    if (rel.setdimension(1,0))
	       return(true);
	 }
	 else
	 {
	    if (rel.setdimension(7,0))
	       return(true);
	 }
      }
   }
   
   return (rel.isfalse(1) || rel.isfalse(3) || rel.isfalse(4) || rel.isfalse(5) || rel.isfalse(7) || rel.isfalse(8));
}

relationship Relate(const LineString& l1,const LineString& l2)
{
   relmatrix rel(l1.dimension(),l2.dimension(),"?????????");

   if (check_bbox(l1,l2,rel))
      return(rel.toRelationship());

   calc_134578(l1,l2,rel);

   calc_026(l1,l2,rel);

   return(rel.toRelationship());
}

bool Relate(const LineString& l1,const LineString& l2,const char matrix[9])
{
   relmatrix rel(l1.dimension(),l2.dimension(),matrix);

   if (check_bbox(l1,l2,rel))
      return(rel.match());

   if (rel.unresolved(1) || rel.unresolved(3) || rel.unresolved(4) || rel.unresolved(5) || rel.unresolved(7) || rel.unresolved(8))
   {
      if (calc_134578(l1,l2,rel))
	 return(false);
   }


   if (rel.unresolved(0) || rel.unresolved(2) || rel.unresolved(6))
   {
      if (rel.unresolved(2) || rel.unresolved(6))
      {
	 if (calc_026(l1,l2,rel))
	    return(false);
      }
      else
      {
	 if (calc_0(l1,l2,rel))
	    return(false);
      }
   }

   return(rel.match());
}
