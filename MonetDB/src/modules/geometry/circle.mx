@f circle
@t The circle class
@a C.W. Quak
@* The circle class
This file contains a C++ class definition and implementation for
a cicle. A circle is defined midpoint (location) and radius.
@h
#ifndef __CIRCLE_H__
#define __CIRCLE_H__

//
// Object Definition.
//
class circle
{
public:
   //
   // Data Storage.
   //
   point location;
   coord radius;

   //
   // Monet Operations.
   //
   int hash() const;
   int expectedstrlen() const;
   int tostr(char* s,int len) const;
   static circle* null();
   static circle* create();
   static circle* fromstr(char *s,int* parselen,int *buflen,circle* p);

   //
   // Constructors.
   //
   circle();
   circle(const point& center);
   circle (const point& center,coord radius);
   circle (const point& p1,const point& p2);
   circle (const point& p1,const point& p2,const point& p3);

   //
   // Const Operations.
   //
   box bbox() const;
   int dimension() const;
   double area() const;
   bool operator==(const circle& r) const;
   bool OK() const;

   void convert_host_to_net();
   void convert_net_to_host();
};

inline int circle::dimension() const
{
   return(2);
}
inline circle::circle()
   :location()
{
   radius = 0;
}

//
// Inline Implementations.
//
inline circle* circle::create()
{
   return new circle;
}

inline double circle::area() const
{
#ifdef DEBUG
   OK();
#endif
   return(M_PI * radius * radius);
}

#endif /* __CIRCLE_H__ */
@C
@+ Implementation Code for circle values.
@C
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "geometry.h"

bool circle::operator==(const circle& r) const
{
   return((location == r.location) && (radius == r.radius));
}

bool circle::OK() const
{
   if (radius < 0)
   {
      GDKwarning("circle ((%f,%f),%f) is inconsistent\n"
         ,location.x,location.y,radius);
      return(false);
   }
   return(true);
}

int circle::expectedstrlen() const
{
   return(200);
}

int circle::tostr(char* s,int len) const
{
#ifdef DEBUG
   OK();
#endif

   int rval = 0;
   rval += sprintf(s + rval,"((");
   rval += put_coord(s + rval,location.x);
   rval += sprintf(s + rval,",");
   rval += put_coord(s + rval,location.y);
   rval += sprintf(s + rval,"),");
   rval += put_coord(s + rval,radius);
   rval += sprintf(s + rval,")");

   if (rval > len)
      GDKwarning("Prepare for the worst\n");
   return(rval);
}

circle* circle::fromstr(char *s,int* parselen,int *buflen,circle* p)
{
   if (p == NULL)
   {
      p = circle::create();
      *buflen = sizeof(circle);
   }
   if (*buflen < (int)sizeof(circle))
   {
      delete (void *)p;
      p = circle::create();
      *buflen = sizeof(circle);
   }

   char* snew = s;

   snew = strchr(snew,'(');
   if(snew == NULL)
   {
      GDKerror("Illegal circle\n");
      return(0);
   }
   ++snew;
   snew = strchr(snew,'(');
   if(snew == NULL)
   {
      GDKerror("Illegal circle\n");
      return(0);
   }
   ++snew;
   p->location.x = get_coord(snew,&snew);
   snew = strchr(snew,',');
   if(snew == NULL)
   {
      GDKerror("Illegal circle\n");
      return(0);
   }
   ++snew;
   p->location.y = get_coord(snew,&snew);
   snew = strchr(snew,')');
   if(snew == NULL)
   {
      GDKerror("Illegal circle\n");
      return(0);
   }
   ++snew;
   snew = strchr(snew,',');
   if(snew == NULL)
   {
      GDKerror("Illegal circle\n");
      return(0);
   }
   ++snew;
   p->radius = get_coord(snew,&snew);
   snew = strchr(snew,')');
   if(snew == NULL)
   {
      GDKerror("Illegal circle\n");
      return(0);
   }
   ++snew;

   size_t bytesread = snew-s;
   if (bytesread > (size_t)*parselen)
      GDKwarning("Problems\n");
   
#ifdef DEBUG
   OK();
#endif

   *parselen = bytesread;
   return(p);
}

int circle::hash() const
{
#ifdef DEBUG
   OK();
#endif

   int i = (int) (location.x * location.y * radius);
   return(i);
}

circle* circle::null()
{
   circle* rval = new circle;
   rval->location.x = COORD_MAX;
   rval->location.y = COORD_MAX;
   rval->radius = COORD_MAX;
   return (rval);
}

box circle::bbox() const
{
#ifdef DEBUG
   OK();
#endif

   return(box(
    location.x - radius,
    location.y + radius,
    location.x + radius,
    location.y - radius
   ));
}


//
// Constructors.
//
circle::circle(const point& l)
   :location(l)
{
}

circle::circle(const point& l,coord r)
   :location(l),radius(r)
{
}

circle::circle(const point& p1,const point& p2)
{
   location = (p1 + p2)/2;
   radius = distance(p1,p2)/2;
}

//
// Generate a circle through the three given points.
// source: comp.graphics.algorithms FAQ 
//
circle::circle(const point& a,const point& b,const point& c)
{
   double D = 2 * (
      (a.y * c.x) +
      (b.y * a.x) -
      (b.y * c.x) -
      (a.y * b.x) -
      (c.y * a.x) +
      (c.y * b.x) );

      location.x =
	      ( b.y * a.x * a.x
	      - c.y * a.x * a.x
	      - b.y * b.y * a.y
	      + c.y * c.y * a.y
	      + b.x * b.x * c.y
	      + a.y * a.y * b.y
	      + c.x * c.x * a.y
	      - c.y * c.y * b.y
	      - c.x * c.x * b.y
	      - b.x * b.x * a.y
	      + b.y * b.y * c.y
	      - a.y * a.y * c.y ) / D;

      location.y =
	      ( a.x * a.x * c.x
	      + a.y * a.y * c.x
	      + b.x * b.x * a.x
	      - b.x * b.x * c.x
	      + b.y * b.y * a.x
	      - b.y * b.y * c.x
	      - a.x * a.x * b.x
	      - a.y * a.y * b.x
	      - c.x * c.x * a.x
	      + c.x * c.x * b.x
	      - c.y * c.y * a.x
	      + c.y * c.y * b.x) / D;

   radius = distance(location,a);
}

void circle::convert_host_to_net()
{
   location.convert_host_to_net();
   convert_endianism(radius);
}

void circle::convert_net_to_host()
{
   location.convert_net_to_host();
   convert_endianism(radius);
}
