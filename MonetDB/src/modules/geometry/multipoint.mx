@f multipoint
@A C.W. Quak
@* The multipoint class
@h
#ifndef __MULTIPOINT_H__
#define __MULTIPOINT_H__

//
// Object Definition.
//
class multipoint : public polystruct
{
public:

   bool OK() const;
   bool operator==(const multipoint& r) const;
   bool operator!=(const multipoint& r) const;

   //
   // Const Operations.
   //
   multipoint* copy() const;
   static multipoint* fromstr(char *s,int* parselen,int *buflen,multipoint* p);
   static multipoint* create(int npoints);
   static multipoint* create(const Array<point>& pointlist);

   multipoint* boundary() const;
   static multipoint null;
   bool isempty() const;
   bool isnull() const;
   bool contains(const point& p) const;
   multipoint();
   int dimension() const;
};

extern multipoint* intersection(const multipoint& m1,const multipoint& m2);
extern bool intersect(const multipoint& m1,const multipoint& m2);
extern bool subset(const multipoint& m1,const multipoint& m2);

inline bool multipoint::isempty() const
{
   return(npoints() == 0);
}

inline bool multipoint::isnull() const
{
   return(*this == null);
}

inline multipoint::multipoint()
{
}

inline int multipoint::dimension() const
{
   return(0);
}


#endif /* __MULTIPOINT_H__ */
@C
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "geometry.h"
#include "Pqueue.h"

multipoint multipoint::null;


bool multipoint::operator!=(const multipoint& r) const
{
   return(!(*this == r));
}

//
// Returns whether two multipoints are equivalent.
// In case of closed lines this is complicated because the lines
// do not have to start at the same point.
//
bool multipoint::operator==(const multipoint& r) const
{
   if (npoints() != r.npoints())
      return(false);

   if (isnull() && r.isnull())
      return(true);

   int i;
   for(i=0;i<npoints();++i)
   {
      if (pnt(i) != r.pnt(i))
	 break;
   }
   if (i == npoints())
      return(true);

   GDKerror("Equality of multipoints not implemented\n");
   return(false);
}

bool multipoint::OK() const
{
   bool rval = true;

   for(int i=0;i<npoints() - 1;++i)
   {
      for(int j=i+1;j<npoints() - 1;++j)
      {
	 if (pnt(i) == pnt(j))
	 {
	    GDKwarning("multipoint with duplicate points %d == %d\n",i,j);
	    rval = false;
	 }
      }
   }
   return(rval);
}

multipoint* multipoint::fromstr(char *instr,int* parselen,int *buflen,multipoint* p)
{
   return((multipoint *)polystruct::fromstr(instr,parselen,buflen,p));
}

multipoint* multipoint::create(const Array<point>& pointlist)
{
   return((multipoint *)polystruct::create(pointlist));
}

multipoint* multipoint::create(int npoints)
{
   return((multipoint *)polystruct::create(npoints));
}

multipoint* multipoint::copy() const
{
   return((multipoint *)polystruct::copy());
}

bool multipoint::contains(const point& p) const
{
   for(int i=0;i<npoints();++i)
   {
      if (pnt(i) == p)
         return(true);
   }
   return(false);
}

bool subset(const multipoint& m1,const multipoint& m2)
{
   for(int i1=0;i1<m1.npoints();++i1)
      if (!m2.contains(m1.pnt(i1)))
         return(false);
   return(true);
}

bool intersect(const multipoint& m1,const multipoint& m2)
{
   if (m1.npoints() == 0 || m2.npoints() == 0)
      return(false);

   multipoint* i = intersection(m1,m2);
   bool rval = (i->npoints() != 0);
   delete i;
   return(rval);
}

multipoint* intersection(const multipoint& m1,const multipoint& m2)
{
   if (m1.npoints() > m2.npoints())
      return(intersection(m2,m1));

   Array<point> retval;
   
   for(int i=0;i<m1.npoints();++i)
   {
      if (m2.contains(m1.pnt(i)))
      {
         retval.append(m1.pnt(i));
      }
   }
   return(multipoint::create(retval));
}

multipoint* multipoint::boundary() const
{
   multipoint* rval = multipoint::create(0);
   return(rval);
}
