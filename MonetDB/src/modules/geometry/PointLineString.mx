@f PointLineString
@A C.W. Quak
@h
#ifndef __POINTLINESTRING_H__
#define __POINTLINESTRING_H__

extern bool contains(const LineString& l,const Point& p);

extern bool Relate(const Point& p,const LineString& l,const char matrix[9]);
extern relationship Relate(const Point& p,const LineString& l);

#endif /* __POINTLINESTRING_H__ */
@C
#include "geometry.h"
#include "opengis.h"

bool contains(const LineString& l,const Point& p)
{
   if (l.hasminitree())
   {
      return(contains(l,l.getminitree(),p));
   }

   for(int i=0;i<l.nsegments();++i)
      if(baserelate(l.sgmt(i),p) != -1)
         return(true);
   return(false);
}

//
//===============================================
// Dimensionally Extended Nine-Intersection Model
//===============================================
//
static bool calc_345678(
   const Point& /* p */,
   const LineString& /* l*/,
   relmatrix& rel)
{
   rel.setdimension(3,-1);
   rel.setdimension(4,-1);
   rel.setdimension(5,-1);
   rel.setdimension(6,1);
   rel.setdimension(7,0);
   rel.setdimension(8,2);

   return (rel.isfalse(3) || rel.isfalse(4) ||rel.isfalse(5) ||rel.isfalse(6) ||rel.isfalse(7) ||rel.isfalse(8));
}

//
// There are 3 cases.
// 1. The point is on the boundary of the line.
// 2. The point is on the line itself.
// 3. The point and the line are disjoint.
//
static bool calc_012(
   const Point&  p,
   const LineString& l,
   relmatrix& rel)
{
   multipoint* m = l.boundary();

   if (m->contains(p)) 
   {
      //
      // The point is on the boundary. 
      //
      rel.setdimension(0,-1);
      rel.setdimension(1,0);
      rel.setdimension(2,-1);
   }
   else
   {
      if (contains(l,p))
      {
	 rel.setdimension(0,0);
	 rel.setdimension(1,-1);
	 rel.setdimension(2,-1);
      }
      else
      {
	 rel.setdimension(0,-1);
	 rel.setdimension(1,-1);
	 rel.setdimension(2,0);
      }
   }

   delete m;
   return (rel.isfalse(0) || rel.isfalse(1) || rel.isfalse(2));
}

bool Relate(const Point& p,const LineString& l,const char matrix[9])
{
   relmatrix rel(p.dimension(),l.dimension(),matrix);

   if (calc_345678(p,l,rel))
      return(false);
   
   if (rel.unresolved(0) || rel.unresolved(1) || rel.unresolved(2))
      calc_012(p,l,rel);

   return(rel.toRelationship().match(matrix));
}

relationship Relate(const Point& p,const LineString& l)
{
   relmatrix rel(p.dimension(),l.dimension(),"?????????");

   calc_345678(p,l,rel);
   calc_012(p,l,rel);

   return(rel.toRelationship());
}
