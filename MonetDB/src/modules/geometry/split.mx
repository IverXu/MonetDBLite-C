@f split
@A C.W. Quak
@* The module 'split'
@h
#ifndef __SPLIT_H__
#define __SPLIT_H__

extern void split(
   int number,		// IN : Number of boxes
   box* boxes[],	// IN : Array of pointers to boxes
   int  group[],	// OUT: For every box 0 or 1 2 or 3
   int ngroups,		// IN : Number of groups
   box* bbox);		// OUT: BBOX for every group

extern void quadratic_split(
   int number,		// In : Number of boxes
   box* boxes[],	// In : Array of pointers to boxes
   int  group[],	// Out: For every box 0 or 1 depending on group
   box& bbox0,		// Out: Bbox for group 1.
   box& bbox1);		// Out: Bbox for group 2.

extern void linear_split_4(
   int number,		// In : Number of boxes
   box* boxes[],	// In : Array of pointers to boxes
   int  group[],	// Out: For every box 0 or 1 2 or 3
   box* bbox);		// OUT: BBOX for every group

#endif /* __SPLIT_H__ */
@+ Implementation of functions in split.
@C
#include "gis.h"

@+ Clustering routines for boxes.
@C
//
// This function implements the PickSeeds function of the Guttman article
//
static void quadratic_pickseeds(
   int* seed1,		/* OUT:index of one   extreme box	*/
   int* seed2,		/* OUT:index of other extreme box	*/
   int number,		/* IN :number of boxes			*/
   box *boxset[])	/* IN :array of pointers to boxes	*/
{
   double seedarea;
   double testarea;

   *seed1 = 0;
   *seed2 = 1;
   box testbox = bbox(*boxset[*seed1],*boxset[*seed2]);
   seedarea = testbox.area() - boxset[*seed1]->area() - boxset[*seed1]->area();

   for(int i=0;i+1<number;++i)
   {
      for(int j=i+i;j<number;++j)
      {
	 testbox = bbox(*boxset[i],*boxset[j]);
	 testarea = testbox.area() - boxset[i]->area() - boxset[j]->area();

	 if (testarea > seedarea)
	 {
	    seedarea = testarea;
	    *seed1 = i;
	    *seed2 = j;
	 }
      }
   }
}

void quadratic_split(
   int number,		// In : Number of boxes
   box* boxes[],	// In : Array of pointers to boxes
   int  group[],	// Out: For every box 0 or 1 depending on group
   box& bbox0,
   box& bbox1)
{
   int x;
   int boxestogo;	// Number of boxes not yet grouped
   box tmpbox;		// temporary box

   for(x=0;x<number;++x)
      group[x] = -1;

   //
   // Calculate the first entry in both groups.
   //
   {
      int seed0,seed1;

      quadratic_pickseeds(&seed0,&seed1,number,boxes);
      group[seed0] = 0;
      group[seed1] = 1;
      boxestogo = number - 2;
      bbox0 = *boxes[seed0];
      bbox1 = *boxes[seed1];
   }

   {
      double curfabs;
      int curbox=0;
      int curgroup=0;
      double d0;
      double d1;
      int n0=1,n1=1;

      while(boxestogo > 0)
      {
	 curfabs = DBL_MAX;

	 for (x=0;x<number;++x)
	 {
	    if (group[x] == -1)
	    {
	       tmpbox = bbox0;
	       tmpbox.bbox_include(*boxes[x]);
	       d0 = tmpbox.area() - bbox0.area();

	       tmpbox = bbox1;
	       tmpbox.bbox_include(*boxes[x]);
	       d1 = tmpbox.area() - bbox1.area();

	       if (d0 < curfabs)
	       {
		  curfabs = d0;
		  curgroup = 0;
		  curbox =x;
	       }
	       if (d1 < curfabs)
	       {
		  curfabs = d1;
		  curgroup = 1;
		  curbox =x;
	       }
	    }
	 }
	 group[curbox] = curgroup;
	 if(curgroup == 0)
	 {
	    ++n0;
	    bbox0.bbox_include(*boxes[curbox]);
	 }
	 else
	 {
	    ++n1;
	    bbox1.bbox_include(*boxes[curbox]);
	 }

	 --boxestogo;

	 /*
	 // If n0 and n1 run too much apart all remaining boxes must
	 // be put in the other group (TODO).
	 */
      }
   }
}


enum{NW,NE,SW,SE};

void linear_split_4(
   int number,		// In : Number of boxes
   box* boxes[],	// In : Array of pointers to boxes
   int  group[],	// Out: For every box 0 or 1 2 or 3
   box* bbox)		// OUT: BBOX for every group
{
   int x;
   box bibox = *boxes[0];
   int gsize[4] = {0,0,0,0};

   for(x=0;x<number;++x)
      group[x] = -1;

   //
   // Calculate surrounding bbox
   //
   for(x=number-1;x>0;--x)
      bibox.bbox_include(*boxes[x]);

   for(x=0;x<number;++x)
   {
      box* check = boxes[x];
      double ldist = (check->left - bibox.left);
      double rdist = (bibox.right - check->right);
      double bdist = (check->bottom - bibox.bottom);
      double tdist = (bibox.top - check->top);

      int min = NW;
      double mindist = ldist+tdist;

      if (ldist+bdist < mindist)
      {
         min = SW;
	 mindist = ldist+bdist;
      }
      if (rdist+tdist < mindist)
      {
         min = NE;
	 mindist = rdist+tdist;
      }
      if (rdist+bdist < mindist)
      {
         min = SE;
	 mindist = rdist+bdist;
      }

      group[x] = min;
      ++gsize[min];
   }

   if ((gsize[0] == number) || (gsize[1] == number) || (gsize[2] == number)
      ||(gsize[3] == number))
   {
      int i=0;

      int maxarea=0;
      for(x=1;x<number;++x)
      {
	 if (boxes[x]->area() > boxes[maxarea]->area())
	    maxarea = x;
      }
      group[maxarea] = 3;
      for(x=1;x<number;++x)
      {
	 if (x != maxarea)
	    group[x] = (i++)%3;
      }
   }

   for(x=0;x<4;++x)
   {
      bbox[x].top = COORD_MIN;
      bbox[x].bottom = COORD_MAX;
      bbox[x].left = COORD_MAX;
      bbox[x].right = COORD_MIN;
   }

   for(x=0;x<number;++x)
      bbox[group[x]].bbox_include(*boxes[x]);
}

extern void split(
   int number,		// IN : Number of boxes
   box* boxes[],	// IN : Array of pointers to boxes
   int  group[],	// OUT: For every box 0 or 1 2 or 3
   int ngroups,		// IN : Number of groups
   box* bbox)		// OUT: BBOX for every group
{
   if (ngroups == 2)
   {
      quadratic_split(number,boxes,group,bbox[0],bbox[1]);
   }
   else if (ngroups == 4)
   {
      linear_split_4(number,boxes,group,bbox);
   }
   else
      GDKerror("split not implemented for this number of groups = %d\n",ngroups);
}
