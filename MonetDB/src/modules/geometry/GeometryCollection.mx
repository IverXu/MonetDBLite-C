@f GeometryCollection
@t The GeometryCollection class
@a C.W. Quak
@* The GeometryCollection class
@h
#ifndef __GEOMETRYCOLLECTION_H__
#define __GEOMETRYCOLLECTION_H__

class GeometryCollection : public varray
{
public:
   //
   // Operations needed by Monet.
   //
   int hash() const;
   bool OK() const;
   bool operator==(const GeometryCollection& r) const;
   bool operator!=(const GeometryCollection& r) const;

   const Geometry& geometry(int index) const;
   Geometry& geometry(int index);

   static GeometryCollection* null();

   static GeometryCollection* create(Array<Geometry*> items);
   static GeometryCollection* create(int nitems,int usedbytes);
   int expectedstrlen() const;

   GeometryCollection* copy() const;

   //
   // Update operations.
   //
   GeometryCollection* additem(const Geometry& p);
};

#endif /* __GEOMETRYCOLLECTION_H__ */
@C
#include "geometry.h"
#include "opengis.h"

#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

GeometryCollection* GeometryCollection::copy() const
{
   return((GeometryCollection *)varray::copy());
}

GeometryCollection* GeometryCollection::create(int nitems,int usedbytes)
{
   return((GeometryCollection *)varray::create(nitems,usedbytes));
}

int GeometryCollection::expectedstrlen() const
{
   return(20 + (nbytes() * 10));
}


GeometryCollection* GeometryCollection::additem(const Geometry& p)
{
   varray* rval;

   if (!fits(p.nbytes(),8))
   {
      rval = realloc(1,p.nbytes() + 8);
      delete this;
   }
   else
      rval = this;
   
   rval->append(&p,p.nbytes(),8);

   return((GeometryCollection* )rval);
}

int GeometryCollection::hash() const
{
   return(nitems());
}

bool GeometryCollection::operator!=(const GeometryCollection& r) const
{
   return(!(*this == r));
}

bool GeometryCollection::operator==(const GeometryCollection& r) const
{
   if (nitems() != r.nitems())
      return(false);

   int i;
   for(i=0;i<nitems();++i)
   {
      if (geometry(i) != r.geometry(i))
         break;
   }
   if (i == nitems())
      return(true);
   
   GDKwarning("GeometryCollection_comp not fully implemented yet");
   return(false);
}

bool GeometryCollection::OK() const
{
   varray::OK();

   if (nitems() < 0)
   {
      GDKerror("GeometryCollection with %d items \n",nitems());
      return(false);
   }

   for(int i=0;i<nitems();++i)
   {
      if (!geometry(i).OK())
      {
	 GDKerror("item %d of GeometryCollection is not ok\n",i);
	 return(false);
      }
   }

   return(true);
}

GeometryCollection* GeometryCollection::null()
{
   return((GeometryCollection *)varray::null());
}

Geometry& GeometryCollection::geometry(int i)
{
   return(*(Geometry *)(varray::item(i)));
}

const Geometry& GeometryCollection::geometry(int i) const
{
   return(*(const Geometry *)(varray::item(i)));
}

GeometryCollection* GeometryCollection::create(Array<Geometry*> items)
{
   GeometryCollection* rval = GeometryCollection::create(items.nitems(),3000);
   for(int i = 0; i < items.nitems();++i)
   {
      rval = rval->additem(*(items[i]));
   }
   return(rval);
}
