@f inside
@A C.W. Quak
@* The module 'inside'
@h
#ifndef __INSIDE_H__
#define __INSIDE_H__

extern bool inside(const point& p,const box& b);
extern bool inside(const point& p,const circle& c);
extern bool inside(const point& p,const cpolygon& c);

extern bool inside(const box& b1,const box& b2);

extern bool inside(const segment& s,const box& b);
extern bool inside(const segment& s,const circle& c);
extern bool inside(const segment& s,const polygon& p);
extern bool inside(const segment& s,const cpolygon& c);

extern bool inside(const circle& c,const box& b);

extern bool inside(const triangle& t,const box& b);

extern bool inside(const polyline& pln,const box& b);
extern bool inside(const polyline& pln,const circle& c);
extern bool inside(const polyline& pln,const polygon& pgn);
extern bool inside(const polyline& pln,const cpolygon& cpg);

extern bool inside(const polygon& p,const box& b);
extern bool inside(const polygon& p,const circle& c);
extern bool inside(const polygon& p1,const polygon& p2);
extern bool inside(const polygon& pgn,const cpolygon& cpg);

extern bool inside(const cpolygon& p,const box& b);
extern bool inside(const cpolygon& p,const circle& c);
extern bool inside(const cpolygon& cpg,const polygon& pgn);
extern bool inside(const cpolygon& cpg1,const cpolygon& cpg2);

#endif /* __INSIDE_H__ */
@+ Implementation of functions in inside.
@C
#include "geometry.h"
#include <math.h>

#include "minitree.h"

bool inside(const point& p,const box& b)
{
   return(b.surrounds(p));
}

bool inside(const box& b1,const box& b2)
{
   return(b2.surrounds(b1));
}

bool inside(const circle& c,const box& b)
{
   return(inside(c.bbox(),b));
}

bool inside(const segment& s,const box& b)
{
   return(b.surrounds(s));
}

bool inside(const segment& s,const circle& c)
{
   return(inside(s.source,c) && inside(s.dest,c));
}

bool inside(const point& p,const circle& c)
{
   return(distance(p,c.location) < c.radius);
}

bool inside(const segment& s,const polygon& p)
{
   if (!inside(s.source,p))
      return(false);
   
   polyline* bnd = p.boundary();
   bool rval = !overlap(s,*bnd);
   delete bnd;
   return(rval);
}

bool inside(const segment& s,const cpolygon& c)
{
   if (!inside(s,c.boundary()))
      return(false);

   for(int i=0;i<c.nholes();++i)
      if(overlap(s,c.hole(i)))
	 return(false);
   return(true);
}

bool inside(const triangle& t,const box& b)
{
   return(inside(t.p1,b) && inside(t.p2,b) && inside(t.p3,b));
}

bool inside(const polyline& p,const circle& c)
{
   for(int i=0;i<p.npoints();++i)
      if (!inside(p.pnt(i),c))
	 return(false);
   return(true);
}

bool inside(const polyline& p,const box& b)
{
   for(int i=0;i<p.npoints();++i)
      if (!inside(p.pnt(i),b))
	 return(false);
   return(true);
}

bool inside(const polyline& pln,const polygon& pgn)
{
   if (!inside(pln.source(),pgn))
      return(false);
   
   polyline* bnd = pgn.boundary();
   bool rval = !overlap(pln,*bnd);
   delete bnd;
   return(rval);
}

bool inside(const polygon& p,const box& b)
{
   for(int i=0;i<p.npoints();++i)
   {
      if (!inside(p.pnt(i),b))
	 return(false);
   }
   return(true);
}


bool inside(const polygon& p,const circle& c)
{
   for(int i=0;i<p.npoints();++i)
   {
      if (!inside(p.pnt(i),c))
	 return(false);
   }
   return(true);
}

bool inside(const polygon& p1,const polygon& p2)
{
   if (p1.hasminitree() && p2.hasminitree())
   {
      return(inside(p1,*(p1.minitreeptr()),p2,*(p2.minitreeptr())));
   }

   if (!inside(p1.bbox(),p2.bbox()))
      return(false);

   if (inside(p1.pnt(0),p2))
   {
      polyline* b1 = p1.boundary();
      polyline* b2 = p2.boundary();

      double rval = !overlap(*b1,*b2);

      delete b1;
      delete b2;
      
      return(rval);
   }
   else
      return(false);
}

bool inside(const cpolygon& c,const box& b)
{
   return(inside(c.boundary(),b));
}

bool inside( const cpolygon& cpg, const circle& cir)
{
   return(inside(cpg.boundary(),cir));
}

bool inside(const cpolygon& c,const polygon& p)
{
   return(inside(c.boundary(),p));
}

//
//========================================================================
//

@:cpinside(point)@
@:cpinside(polyline)@
@:cpinside(polygon)@
@:cpinside(cpolygon)@

@= cpinside
//
// An object is inside a polygon if.
// 1. It is inside the boundary.
// 2. It does not overlap with any of the holes.
//
bool inside(const @1& obj,const cpolygon& c)
{
   if (!inside(obj,c.boundary()))
      return(false);
   else
   {
      for(int i=0;i<c.nholes();++i)
	 if (overlap(obj,c.hole(i)))
	    return(false);
      return(true);
   }
}
@
@C
