@f varheap
@A C.W. Quak
@* The varheap class
@h
#ifndef __VARHEAP_H__
#define __VARHEAP_H__

#include "varlen.h"

class varheap : public varlen
{
private:
   int free_v;	// Index of first unused byte.

public:
   //
   // Create a varheap which can store at least 'nitems' items with a total size
   // of 'usedbytes' bytes. We do not take into account that you might need more
   // because of alignment.
   //
   static varheap* create(
      int usedbytes);

   //
   // Return 'true' if an object with size 'usedbytes' aligned on a 'aligment' byte
   // boundary could be added to the varheap without resizing it.
   //
   bool fits(int usedbytes,int alignment) const;

   //
   //
   //
   int free() const;

   //
   // index operator on varheap.
   //
   void* index(int idx) const;

   //
   // Return the index of the first block on the heap.
   //
   int firstblock(int alignment = 4) const;

   //
   // Append object 'obj' to the varheap. If it does not fit do not append it and
   // return false. Return true otherwise.
   //
   bool append(const void* obj,int length,int alignment);

   //
   // Allocate nbytes bytes on the heap.
   // 
   varheap* alloc(int nbytes,int alignment,int& rval);

   //
   // Return an exact duplicate of this object.
   //
   varheap* copy() const;

   //
   // Return a minimized copy of the varheap.
   //
   varheap* minimize() const;

   //
   // Return a duplicate of this object with more free space.
   //
   varheap* realloc(int newmaxbytes);

   //
   // Pointer to null value for varheap.
   //
   static const varheap* null();

   //
   // Print status of objects as error messages.
   //
   void info() const;

   //
   // Check internal integrity and give appropriate error messages.
   //
   bool OK() const;

   //
   // Return the number of actually used bytes in the varheap.
   //
   int usedbytes() const;
private:
   static varheap vnull;
};

#endif /* __VARHEAP_H__ */
@C
#include "varheap.h"
#include <stdlib.h>
#include <gdk.h>

int varheap::usedbytes() const
{
   return(free_v);
}

static inline int roundup_num(int number,int alignment)
{
   int rval = number + alignment -1;
   rval -= (rval % alignment);
   return(rval);
}

void* varheap::index(int ind) const
{
#ifdef DEBUG
   if ((ind < 0) || (ind >= free()))
      GDKerror("varheap::index(%d) out of bounds [0,%d]",ind,free());
#endif
   return((void *)(((char*)this)+ ind));
}

//
// Create a varheap with the given number of items.
//
varheap* varheap::create(int usedbytes)
{
   int bytesneeded = 0;
   bytesneeded += usedbytes;
   bytesneeded += sizeof(varheap) - sizeof(varlen);

   varheap* rval = (varheap* )varlen::create(bytesneeded);

   rval->free_v = sizeof(varheap);


   return(rval);
}

int varheap::firstblock(int alignment) const
{
   return(roundup_num(sizeof(varheap),alignment));
}

varheap* varheap::realloc(int bytesadded)
{
   //
   // How many more bytes do we need.
   //
   int bytesneeded = 0;
   bytesneeded += bytesadded;
   bytesneeded += usedbytes();
   bytesneeded -= sizeof(varlen);

   varheap* rval = (varheap *)varlen::realloc(bytesneeded);
   return(rval);
}

varheap* varheap::copy() const
{
   return((varheap *)varlen::copy());

}

//
// Returns whether a given objects fits into a varheap.
//
bool varheap::fits(int itemsize,int alignment) const
{
   int bytesfree = nbytes() - usedbytes();
   int bytesneeded = roundup_num(itemsize,alignment) + sizeof(int);
   return(bytesneeded < bytesfree);
}

//
// Allocate nbytes bytes on the heap.
// 
varheap* varheap::alloc(int number,int alignment,int& retval)
{
   varheap* rval;
   

   if (fits(number,alignment))
      rval = this;
   else
      rval = realloc(number + 8 + usedbytes() + usedbytes());

   retval = roundup_num(rval->free_v,alignment);
   rval->free_v += number;

   return(rval);
}


int varheap::free() const
{
   return free_v;
}

//
// Print all available info on this varheap.
//
void varheap::info() const
{
   GDKwarning("Object has %d bytes\n",nbytes());
}

//
// Appends the given item to the varheap.
//
bool varheap::append(const void* item,int itemsize,int alignment)
{
   if (!fits(itemsize,alignment))
   {
      GDKerror("append does not fit\n");
      return(false);
   }

   int newitem_index = roundup_num(free_v,alignment);

   void* newplace = index(newitem_index);
   memcpy(newplace,item,itemsize);
   return(true);
}

//
// Null value for varheap.
//
const varheap* varheap::null()
{
   return((varheap*)varlen::null());
}

//
// Returns true if varheap is internally consistent.
//
bool varheap::OK() const
{
   bool rval=true;

   if (isnull())
      rval = true;
   else
   {
      if (free() > nbytes())
      {
	 GDKerror("varheap has free() = %d and nbytes() %d\n",
	    free(),nbytes());
	 rval = false;
      }
   }
   return(rval);
}
