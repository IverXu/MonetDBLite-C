@f distance
@A C.W. Quak
@* The module 'distance'
@h
#ifndef __DISTANCE_H__
#define __DISTANCE_H__

//
// Declare squared distance functions.
// Define distance functions as sqrt of squared function.
//
@:distdecl(point,point)@
@:distdecl(point3d,point3d)@
@:distdecl(point,box)@
@:distdecl(point,segment)@
@:distdecl(point,circle)@
@:distdecl(point,polyline)@
@:distdecl(point,polygon)@
@:distdecl(point,cpolygon)@
@:distdecl(box,box)@
@:distdecl(segment,segment)@
@:distdecl(segment,circle)@
@:distdecl(segment,polyline)@
@:distdecl(segment,polygon)@
@:distdecl(segment,cpolygon)@
@:distdecl(circle,circle)@
@:distdecl(polyline,polyline)@
@:distdecl(polyline,polygon)@
@:distdecl(polyline,cpolygon)@
@:distdecl(polygon,polygon)@
@:distdecl(polygon,cpolygon)@
@:distdecl(cpolygon,cpolygon)@

@= distdecl
extern double squared_distance(const @1& obj1,const @2& obj2);

inline double distance(const @1& obj1,const @2& obj2)
{
   return(sqrt(squared_distance(obj1,obj2)));
}
@
@h

//
// Define reversed versions of distance function.
//
@:squred_distrev(box,point)@
@:squred_distrev(segment,point)@
@:squred_distrev(circle,point)@
@:squred_distrev(circle,segment)@
@:squred_distrev(polyline,point)@
@:squred_distrev(polyline,segment)@
@:squred_distrev(polygon,point)@
@:squred_distrev(polygon,segment)@
@:squred_distrev(polygon,polyline)@
@:squred_distrev(cpolygon,point)@
@:squred_distrev(cpolygon,segment)@
@:squred_distrev(cpolygon,polyline)@
@:squred_distrev(cpolygon,polygon)@

@= squred_distrev
inline double squared_distance(const @1& arg1,const @2& arg2)
{
   return(squared_distance(arg2,arg1));
}
@
@h

//
// Squared mindist and maxdists.
//
extern double squared_mindist(const box&b1,const box& b2);
extern double squared_maxdist(const box&b1,const box& b2);

extern double squared_mindist(const point& p,const box& b);
extern double squared_maxdist(const point& p,const box& b);

@:squaredist(mindist,point,point)@
@:squaredist(mindist,point,box)@
@:squaredist(mindist,box,box)@

@:squaredist(maxdist,point,point)@
@:squaredist(maxdist,point,box)@
@:squaredist(maxdist,box,box)@

@= squaredist
extern double squared_@1(const @2& obj1,const @3& obj2);

// inline double @1(const @2& obj1,const @3& obj2)
// {
//    return(sqrt(squared_@1(obj1,obj2)));
// }
@
@h

extern void reduce_squared_distance(
   double& curmin,
   const segment& s1,
   const segment& s2);

extern void reduce_squared_distance(
   double& curmin,
   const point& p1,
   const point& p2);

extern void reduce_squared_distance(
   double& curmin,
   const point& p,
   const segment& s);

extern void reduce_squared_distance(
   double& curmin,
   const segment& s,
   const polyline& p);

extern void reduce_squared_distance(
   double& curmin,
   const segment& s,
   const polygon& p);

#endif /* __DISTANCE_H__ */
@+ Implementation of functions in distance.
@C
#include "geometry.h"
#include "math.h"

#include "minitree.h"

double squared_distance(const point3d &p1,const point3d& p2)
{
   point3d p(p1.x - p2.x,p1.y - p2.y,p1.z - p2.z);
   return((p.x * p.x) + (p.y * p.y) + (p.z * p.z));
}

double squared_distance(const point &p1,const point& p2)
{
   point p(p1.x - p2.x,p1.y - p2.y);
   return((p.x * p.x) + (p.y * p.y));
}

double squared_distance(const point& p,const box& b)
{
   interval h(b.left,b.right);
   interval v(b.bottom,b.top);

   point di((coord)distance(h,p.x),(coord)distance(v,p.y));
   return(di.squared_length());
}

// source:http://www.smartpages.com/faqs/graphics/algorithms-faq/faq-doc-8.html
//
// 7) How do I find the distance from a point to a line?
//
//     Let the point be C (XC,YC) and the line be AB (XA,YA) to (XB,YB).
//     The length of the line segment AB is L:
//
//         L=((XB-XA)**2+(YB-YA)**2)**0.5
//
//     and
//             (YA-YC)(YA-YB)-(XA-XC)(XB-XA)
//         r = -----------------------------
//                         L**2
//
//             (YA-YC)(XB-XA)-(XA-XC)(YB-YA)
//         s = -----------------------------
//                         L**2
//
//     Let I be the point of perpendicular projection of C onto AB, the
//
//         XI=XA+r(XB-XA)
//         YI=YA+r(YB-YA)
//
//     Distance from A to I = r*L
//     Distance from C to I = s*L
//
//     If r<0      I is on backward extension of AB
//     If r>1      I is on ahead extension of AB
//     If 0<=r<=1  I is on AB
//
//     If s<0      C is left of AB (you can just check the numerator)
//     If s>0      C is right of AB
//     If s=0      C is on AB
//

double squared_distance(const point& p,const segment& s)
{
   if (s.source == s.dest)
      return(squared_distance(s.source,p));

   double XC = p.x;
   double YC = p.y;
   double XA = s.source.x;
   double YA = s.source.y;
   double XB = s.dest.x;
   double YB = s.dest.y;

   double L = s.length();

   double r = ((((YA-YC)*(YA-YB))-((XA-XC)*(XB-XA)))
/ //          --------------------------------------
                            (L * L));

   if (r < 0)
   {
      return(squared_distance(p,s.source));
   }
   else if (r > 1)
   {
      return(squared_distance(p,s.dest));
   }
   else
   {
      coord XI= (coord)(XA+(r*(XB-XA)));
      coord YI= (coord)(YA+(r*(YB-YA)));
      point I(XI,YI);
      return(squared_distance(p,I));
   }
}

double squared_distance(const point& p,const circle& c)
{
   double cdist = squared_distance(p,c.location);
   cdist -= c.radius;

   if (cdist < 0)
      cdist = 0;

   return(cdist);
}

double squared_distance(const point& p,const polyline& pol)
{
   double curdist = squared_distance(p,pol.pnt(0));

   for(int i=0;i<pol.npoints() -1;++i)
   {
      segment s(pol.pnt(i),pol.pnt(i+1));
      reduce_squared_distance(curdist,p,s);

      if (curdist == 0)
	 return(0);
   }
   return(curdist);
}

double squared_distance(const point& p,const polygon& pgn)
{
   //
   // If the polygon has a builtin accelerator structure we use
   // it of course.
   //
   if (pgn.hasminitree())
   {
      return(squared_distance(p,pgn,pgn.getminitree()));
   }

   //
   // If the point is inside the polygon the distance is 0 of course.
   //
   if (inside(p,pgn))
      return(0);

   double curdist = squared_distance(p,pgn.pnt(0));
   for(int i=0;i<pgn.npoints();++i)
   {
      reduce_squared_distance(curdist,p,pgn.sgmt(i));
      if (curdist == 0)
	 return(0);
   }
   return(curdist);
}


double squared_distance(const box& b1,const box& b2)
{
   return(squared_mindist(b1,b2));
}

double squared_distance(const segment& s1,const segment& s2)
{
   segment isection;
   if (baserelate(s1,s2,isection) == -1)
      return(0);

   double val1 = squared_distance(s1,s2.source);
   double val2 = squared_distance(s1,s2.dest);
   double val3 = squared_distance(s2,s1.source);
   double val4 = squared_distance(s2,s1.dest);

   double rval = val1;
   if (val2 < rval) rval = val2;
   if (val3 < rval) rval = val3;
   if (val4 < rval) rval = val4;

   return(rval);
}

double squared_distance(const segment& s,const circle& c)
{
   double rval = distance(c.location,s) - c.radius;
   
   if (rval < 0)
      rval = 0;
   return(rval * rval); // XXX
}

double squared_distance(const segment& s,const polyline& p)
{
   double curdist = squared_distance(s.source,p.source());

   //
   // The distance between a segment and a polyline is the the 
   // distance between the segment and the closes segment of the polyline.
   //
   for(int i=0;i<p.nsegments();++i)
   {
      reduce_squared_distance(curdist,s,p.sgmt(i));
      if (curdist == 0)
	 return(0);
   }
   return(curdist);
}

double squared_distance(const segment& s,const polygon& p)
{
   //
   // If the polygon has a builtin accelerator structure we use
   // it of course.
   //
   if (p.hasminitree())
   {
      return(squared_distance(s,p,p.getminitree()));
   }

   if (inside(s,p))
      return(0);
   else
   {
      polyline* bnd = p.boundary();
      double rval = squared_distance(s,*bnd);
      delete bnd;
      return(rval);
   }
}


double squared_distance(const circle& c1,const circle& c2)
{
   double cendist = distance(c1.location,c2.location);
   cendist -= c1.radius;
   cendist -= c2.radius;

   if (cendist < 0)
      return(0);
   else
      return(cendist * cendist); // XXXXXXXXXX
}

double squared_distance(const polyline& p1,const polyline& p2)
{
   box b2 = p2.bbox();

   double curdist = squared_distance(p1.pnt(0),p2.pnt(0));

   for(int i1=0;i1<p1.nsegments();++i1)
   {
      segment s1 = p1.sgmt(i1);

      if (squared_mindist(s1.bbox(),b2) < curdist)
      {
	 reduce_squared_distance(curdist,s1,p2);
	 if (curdist == 0)
	    return(curdist);
      }
   }
   return(curdist);
}

double squared_distance(const polyline& pln,const polygon& pgn)
{
   box b2 = pgn.bbox();

   double curdist = squared_distance(pln.pnt(0),pgn.pnt(0));

   for(int i1=0;i1<pln.nsegments();++i1)
   {
      segment s1 = pln.sgmt(i1);

      if (squared_mindist(s1.bbox(),b2) < curdist)
      {
	 reduce_squared_distance(curdist,s1,pgn);
	 if (curdist == 0)
	    return(curdist);
      }
   }
   return(curdist);
}

double squared_distance(const polygon& p1,const polygon& p2)
{
   //
   // If the polygon has a builtin accelerator structure we use
   // it of course.
   //
   if ((p1.hasminitree()) && (p2.hasminitree()))
   {
      return(squared_distance(p1,p1.getminitree(),p2,p2.getminitree()));
   }

   box b2 = p2.bbox();

   double curdist = squared_distance(p1.pnt(0),p2.pnt(0));

   for(int i1=0;i1<p1.nsegments();++i1)
   {
      segment s1 = p1.sgmt(i1);

      if (squared_mindist(s1.bbox(),b2) < curdist)
      {
	 for(int i2=0;i2<p2.npoints();++i2)
	 {
	    segment s2 = p2.sgmt(i2);

	    double newdist = squared_distance(s1,s2);

	    if (newdist < curdist)
	    {
	       curdist = newdist;
	    }
	    if (curdist == 0)
	       return(curdist);
	 }
      }
   }

   if (inside(p1.pnt(0),p2) || inside(p2.pnt(0),p1))
      return(0);
   else
      return(curdist);
}

@:cpdist(point)@
@:cpdist(segment)@
@:cpdist(polyline)@
@:cpdist(polygon)@
@:cpdist(cpolygon)@

@= cpdist
double squared_distance(const @1& obj,const cpolygon& c)
{
   double rval;

   rval = squared_distance(obj,c.boundary());
   if (rval > 0)
      return(rval);
   
   //
   // Only if a @1 is inside an island the distance is different.
   //
   for(int i=0;i<c.nholes();++i)
   {
      if (inside(obj,c.hole(i)))
      {
	 polyline* bnd = c.hole(i).boundary();
	 rval = squared_distance(obj,*bnd);
	 delete bnd;
	 return(rval);
      }
   }
   return(0);
}
@
@C

//
// Mindist and Maxdist operations.
//

double squared_mindist(const point& p,const box& b)
{
   interval hor(b.left,b.right);
   interval ver(b.bottom,b.top);

   double d1 = mindist(p.x,hor);
   double d2 = mindist(p.y,ver);

   return((d1 * d1) + (d2 * d2));
}

double squared_maxdist(const point& p,const box& b)
{
   interval hor(b.left,b.right);
   interval ver(b.bottom,b.top);

   double d1 = maxdist(p.x,hor);
   double d2 = maxdist(p.y,ver);

   return((d1 * d1) + (d2 * d2));
}

double squared_mindist(const box&b1,const box& b2)
{
   interval i1h(b1.left,b1.right);
   interval i1v(b1.bottom,b1.top);
   interval i2h(b2.left,b2.right);
   interval i2v(b2.bottom,b2.top);

   double d1 = mindist(i1h,i2h);
   double d2 = mindist(i1v,i2v);

   return((d1 * d1) + (d2 * d2));
}

double squared_maxdist(const box& b1,const box& b2)
{
   interval i1h(b1.left,b1.right);
   interval i1v(b1.bottom,b1.top);
   interval i2h(b2.left,b2.right);
   interval i2v(b2.bottom,b2.top);

   double d1 = maxdist(i1h,i2h);
   double d2 = maxdist(i1v,i2v);

   return((d1 * d1) + (d2 * d2));
}

double squared_mindist(const point& p1,const point& p2)
{
   return(squared_distance(p1,p2));
}

double squared_maxdist(const point& p1,const point& p2)
{
   return(squared_distance(p1,p2));
}


//
// Calculate the distance between s1 and s2, as long as this
// distance is smaller curmin. Put the result in curmin.
//
void reduce_squared_distance(
   double& curmin,
   const segment& s1,
   const segment& s2)
{
   box bb1(s1.bbox());
   box bb2(s2.bbox());
   
   //
   // If bounding boxes do not allow to reduce distances we
   // can return.
   //
   if (squared_mindist(bb1,bb2) >= curmin)
      return;

   //
   // If segments intersect the distance is 0 and we are ready.
   //
   segment isection;
   if (baserelate(s1,s2,isection) == -1)
   {
      curmin = 0;
      return;
   }

   if (squared_mindist(s2.source,bb1) < curmin)
   {
      double newdist = squared_distance(s2.source,s1);
      if (newdist < curmin)
	 curmin = newdist;
   }

   if (squared_mindist(s2.dest,bb1) < curmin)
   {
      double newdist = squared_distance(s2.dest,s1);
      if (newdist < curmin)
	 curmin = newdist;
   }

   if (squared_mindist(s1.source,bb2) < curmin)
   {
      double newdist = squared_distance(s1.source,s2);
      if (newdist < curmin)
	 curmin = newdist;
   }

   if (squared_mindist(s1.dest,bb2) < curmin)
   {
      double newdist = squared_distance(s1.source,s2);
      if (newdist < curmin)
	 curmin = newdist;
   }
}

void reduce_squared_distance(
   double& curmin,
   const point& p,
   const segment& s)
{
   box bb(s.bbox());

   if (squared_mindist(p,bb) < curmin)
   {
      double newdist = squared_distance(p,s);
      if (newdist < curmin)
	 curmin = newdist;
   }
}

void reduce_squared_distance(
   double& curmin,
   const point& p1,
   const point& p2)
{
   double d = squared_distance(p1,p2);
   if (d < curmin)
      curmin = d;
}

void reduce_squared_distance(
   double& curmin,
   const segment& s,
   const polyline& p)
{
   for(int i=0;i<p.nsegments();++i)
   {
      reduce_squared_distance(curmin,s,p.sgmt(i));
      if (curmin == 0)
	 return;
   }
   return;
}

void reduce_squared_distance(
   double& curmin,
   const segment& s,
   const polygon& p)
{
   if (inside(s,p))
   {
      curmin = 0;
   }
   else
   {
      polyline* bnd = p.boundary();
      reduce_squared_distance(curmin,s,*bnd);
      delete bnd;
   }
}

