@f baserelate
@A C.W. Quak
@h
#ifndef __BASERELATE_H__
#define __BASERELATE_H__


extern double baserelate(const segment& s,const point& p);
// extern interval baserelate(const segment& s1,const segment& s2);
extern int baserelate(const segment& s1,const segment& s2,segment& intersection);
extern bool equivalent(const point& p1,const point& p2);
extern bool inside(const point& p,const polygon& pgn);

extern bool dimensioncompare(const int dimension,const char pattern);

class relmatrix
{
public:
   int dim_min[9];
   int dim_max[9];
   char pattern[9];

   static const int STATUS_UNKNOWN = -1;
   static const int STATUS_FALSE = 0;
   static const int STATUS_TRUE = 1;

   static int dimension_interior(int dim);
   static int dimension_boundary(int dim);
   static int dimension_exterior(int dim);

   static const char WANTED = '?';
   static const char ANY = '*';
   static const char NOTEMPTY= 'T';
   static const char EMPTY= 'F';
   static const char ZERO = '0';
   static const char ONE = '1';
   static const char TWO = '2';

   static const int INTERIOR_INTERIOR = 0;
   static const int INTERIOR_BOUNDARY = 1;
   static const int INTERIOR_EXTERIOR = 2;
   static const int BOUNDARY_INTERIOR = 3;
   static const int BOUNDARY_BOUNDARY = 4;
   static const int BOUNDARY_EXTERIOR = 5;
   static const int EXTERIOR_INTERIOR = 6;
   static const int EXTERIOR_BOUNDARY = 7;
   static const int EXTERIOR_EXTERIOR = 8;

   //
   // Construct an initial relmatrix to compare two objects
   // of dimension d1 and d2, with pattern matrix.
   //
   relmatrix(int d1,int d2,const char matrix[9]);

   //
   // Increase the minimum dimension of a cell.
   // If the status of the cell known afterwards we return true.
   //
   bool increase_mindimension(int cell,int d);

   //
   // Set the exact dimension of a cell.
   // Returns true if this dimension resolves to false. This means
   // that the complete matrix resolves to false and we can stop.
   //
   bool setdimension(int cell,int d);

   //
   // Returns true if this cell does not match.
   //
   bool isfalse(int pos) const;

   //
   // Returns true if this cell is resolved.
   //
   bool resolved(int pos) const;

   //
   // Returns true if this cell is unresolved.
   //
   bool unresolved(int pos) const;

   //
   // Returns the status of this cell:
   //   STATUS_UNKNOWN 
   //   STATUS_FALSE 
   //   STATUS_TRUE 
   //
   int status(int pos) const;

   //
   // Return the dimension of this cell. 
   // This will return in an error if the status of the cell
   // is unknown.
   //
   int dimension(int cell) const;

   //
   // Returns whether this cell matches true or false.
   // This will give an error if the status if the cell is unknown.
   //
   bool match(int pos) const;

   //
   // Returns whether the complete matrix matches true or false.
   // This will give an error if the status if the cell is unknown.
   //
   bool match() const;

   class relationship toRelationship() const;
};

class relationship
{
public:
   int dimensions[9];

   static const int INTERIOR_INTERIOR = 0;
   static const int INTERIOR_BOUNDARY = 1;
   static const int INTERIOR_EXTERIOR = 2;
   static const int BOUNDARY_INTERIOR = 3;
   static const int BOUNDARY_BOUNDARY = 4;
   static const int BOUNDARY_EXTERIOR = 5;
   static const int EXTERIOR_INTERIOR = 6;
   static const int EXTERIOR_BOUNDARY = 7;
   static const int EXTERIOR_EXTERIOR = 8;

   enum
   {
      DISJOINT,
      TOUCH,
      REINL,
      LEINR,
      CROSS,
      EQUAL,
      LINR,
      RINL,
      LIN2R,
      RIN2L,
      OVERLAP
   };

   relationship(int ii,int ib,int ie,int bi,int bb,int be,int ei,int eb,int ee);
   char* tostring() const;
   static int value(int dim,char pattern);

   bool match(const char matrix[9]) const;
   relationship reverse() const;
   bool operator==(const relationship& right);

};

#endif /* __BASERELATE_H__ */
@C
#include "geometry.h"
#include "baserelate.h"
//
//===========================================
// The base of al relationships two segments.
//===========================================
//

//
// source: http://www.smartpages.com/faqs/graphics/algorithms-faq/faq-doc-9.html
//
// 8) How do I find intersections of 2 2D line segments?
//
//     This problem can be extremely easy or extremely difficult depends
//     on your applications.  If all you want is the intersection point,
//     the following should work:
//
//     Let A,B,C,D be 2-space position vectors.  Then the directed line
//     segments AB & CD are given by:
//
//         AB=A+r(B-A), r in [0,1]
//         CD=C+s(D-C), s in [0,1]
//
//     If AB & CD intersect, then
//
//         A+r(B-A)=C+s(D-C), or
//
//         XA+r(XB-XA)=XC+s(XD-XC)
//         YA+r(YB-YA)=YC+s(YD-YC)  for some r,s in [0,1]
//
//     Solving the above for r and s yields
//
//             (YA-YC)(XD-XC)-(XA-XC)(YD-YC)
//         r = -----------------------------  (eqn 1)
//             (XB-XA)(YD-YC)-(YB-YA)(XD-XC)
//
//             (YA-YC)(XB-XA)-(XA-XC)(YB-YA)
//         s = -----------------------------  (eqn 2)
//             (XB-XA)(YD-YC)-(YB-YA)(XD-XC)
//
//     Let I be the position vector of the intersection point, then
//
//         I=A+r(B-A) or
//
//         XI=XA+r(XB-XA)
//         YI=YA+r(YB-YA)
//
//     By examining the values of r & s, you can also determine some
//     other limiting conditions:
//
//         If 0<=r<=1 & 0<=s<=1, intersection exists
//             r<0 or r>1 or s<0 or s>1 line segments do not intersect
//
//         If the denominator in eqn 1 is zero, AB & CD are parallel
//         If the numerator in eqn 1 is also zero, AB & CD are coincident
//
//     If the intersection point of the 2 lines are needed (lines in this
//     context mean infinite lines) regardless whether the two line
//     segments intersect, then
//
//         If r>1, I is located on extension of AB
//         If r<0, I is located on extension of BA
//         If s>1, I is located on extension of CD
//         If s<0, I is located on extension of DC
//
//     Also note that the denominators of eqn 1 & 2 are identical.
//
//     References:
//
//     [O Rourke] pp. 249-51
//     [Gems III] pp. 199-202 "Faster Line Segment Intersection,"
//

//
// Given A,B,C,D this function calculates r of the above story.
//
double segment_intersec(
   const point& A,
   const point& B,
   const point& C,
   const point& D,
   double& numerator,
   double& denominator)
{
   numerator = (((A.y-C.y)*(D.x-C.x))-((A.x-C.x)*(D.y-C.y)));
   denominator = (((B.x-A.x)*(D.y-C.y))-((B.y-A.y)*(D.x-C.x)));

   if (denominator == 0)
      return(0);

   return(numerator/denominator);
}

int baserelate(
   const segment& s1,
   const segment& s2,
   segment& rval)
{
   const point& A = s1.source;
   const point& B = s1.dest;
   const point& C = s2.source;
   const point& D = s2.dest;

   //
   // Bounding Box check.
   //
   if ((disjoint(interval(A.x,B.x),interval(C.x,D.x))) || 
      (disjoint(interval(A.x,B.x),interval(C.x,D.x))))
   {
      return(-1);
   }
   

   //
   // First we handle two special cases when
   // the lines are equivalent.
   //
   if (s1 == s2)
   {
      rval = s1;
      return(1);
   }

   double r_numerator,r_denominator;
   double s_numerator,s_denominator;

   double r = segment_intersec(A,B,C,D,r_numerator,r_denominator);
   double s = segment_intersec(C,D,A,B,s_numerator,s_denominator);

   if (r_denominator == 0)
   {
      if (r_numerator == 0)
      {
	 //
	 // The lines are coincident.
	 //
	 double s1_start;
	 double s1_end;
	 double s2_start;
	 double s2_end;
	 interval i1;
	 interval i2;

	 if ((A.x == B.x) && (C.x == D.x))
	 {
	    //
	    // If the lines are vertical we project
	    // them on the y-axis.
	    //
	    s1_start = A.y;
	    s1_end = B.y;
	    s2_start = C.y;
	    s2_end = D.y;
	    i1 = interval(A.y,B.y);
	    i2 = interval(C.y,D.y);
	 }
	 else
	 {
	    //
	    // The lines are not vertical we project them
	    // on the x-axis.
	    //
	    s1_start = A.x;
	    s1_end = B.x;
	    s2_start = C.x;
	    s2_end = D.x;
	    i1 = interval(A.x,B.x);
	    i2 = interval(C.x,D.x);
	 }

	 if (!overlap(i1,i2))
	 {
	    //
	    // The segments are disjoint.
	    //
	    return(-1);
	 }
	 else if (touch(i1,i2))
	 {
	    //
	    // The segments touch.
	    //
	    if (s1.hasendpoint(s2.source))
	    {
	       rval = segment(s2.source);
	       return(0);
	    }
	    else
	    {
	       rval = segment(s2.dest);
	       return(0);
	    }
	 }
	 else
	 {
	    //
	    // The segments overlap.
	    //
	    bool samedirection = ((s1_start > s1_end) == (s2_start > s2_end));
	    interval is = intersection(i1,i2);

	    if ((s1_start == is.min) || (s1_start == is.max))
	       rval.source = A;
	    else
	    {
	       if (samedirection)
		  rval.source = C;
	       else
		  rval.source = D;

	    }

	    if ((s1_end == is.min) || (s1_end == is.max))
	       rval.dest = B;
	    else
	    {
	       if (samedirection)
		  rval.dest = D;
	       else
		  rval.dest = C;
	    }

	    return(1);
	 }
      }
      else
      {
         //
	 // The line are not coincident.
	 //
	 return(-1);
      }
   }
   else
   {
      //
      // The lines are not parallel.
      //

      //
      // They can touch in an endpoint.
      //
      if ((B == C) || (B == D))
      {
         rval = segment(B);
	 return(0);
      }
      if ((A == C) || (A == D))
      {
         rval = segment(A);
	 return(0);
      }
      
      //
      // Check whether they have an endpoint in common.
      //

      if ((r<0) || (r>1) || (s<0) || (s>1))
      {
	 //
	 // There is no intersection.
	 //
	 return(-1);
      }
      else
      {
	 //
	 // There is one intersection point.
	 //
	 if (r == 0)
	 {
	    rval = segment(s1.source);
	 }
	 else
	 {
	    if (r == 1)
	    {
	       rval = segment(s1.dest);
	    }
	    else
	    {
	       rval = segment(s1.pointon(r));
	    }
	 }
	 return(0);
      }
   }
}

// interval baserelate(
//    const segment& s1,
//    const segment& s2)
// {
//    const point& A = s1.source;
//    const point& B = s1.dest;
//    const point& C = s2.source;
//    const point& D = s2.dest;
// 
//    //
//    // First we handle two special cases when
//    // the lines are equivalent.
//    //
//    if (s1 == s2)
//    {
//       return(interval(0.0,1.0));
//    }
// 
//    double r_numerator,r_denominator;
//    double s_numerator,s_denominator;
// 
//    double r = segment_intersec(A,B,C,D,r_numerator,r_denominator);
//    double s = segment_intersec(C,D,A,B,s_numerator,s_denominator);
// 
//    if (r_denominator == 0)
//    {
//       if (r_numerator == 0)
//       {
// 	 //
// 	 // The lines are coincident.
// 	 //
// 
// 	 interval i1;
// 	 interval i2;
// 
// 	 if ((A.x == B.x) && (C.x == D.x))
// 	 {
// 	    //
// 	    // If the lines are vertical we project
// 	    // them on the y-axis.
// 	    //
// 	    i1 = interval(A.y,B.y);
// 	    i2 = interval(C.y,D.y);
// 	 }
// 	 else
// 	 {
// 	    //
// 	    // The lines are not vertical we project them
// 	    // on the x-axis.
// 	    //
// 	    i1 = interval(A.x,B.x);
// 	    i2 = interval(C.x,D.x);
// 	 }
// 
// 	 if (!overlap(i1,i2))
// 	 {
// 	    //
// 	    // The segments are disjoint.
// 	    //
// 	    return(interval::empty());
// 	 }
// 	 else if (touch(i1,i2))
// 	 {
// 	    //
// 	    // The segments touch.
// 	    //
// 	    if (i1.max == i2.min)
// 	    {
// 	       return(interval(1.0,1.0));
// 	    }
// 	    else
// 	    {
// 	       return(interval(0.0,0.0));
// 	    }
// 	 }
// 	 else
// 	 {
// 	    interval is = intersection(i1,i2);
// 
// 	    return(interval(
// 	       (is.min - i1.min) / (i1.max - i1.min),
// 	       (is.max - i1.min) / (i1.max - i1.min)));
// 	 }
//       }
//       else
//       {
//          //
// 	 // The line are not coincident.
// 	 //
// 	 return(interval::empty());
//       }
//    }
//    else
//    {
//       //
//       // The lines are not parallel.
//       //
// 
//       if ((r<0) || (r>1) || (s<0) || (s>1))
//       {
// 	 //
// 	 // There is no intersection.
// 	 //
// 	 return(interval::empty());
//       }
//       else
//       {
// 	 //
// 	 // There is one intersection point.
// 	 //
// 	 return(interval(r,r));
//       }
//    }
// }

//
//============================================================
// The base of al relationships between a segment and a point.
//============================================================
//

//
// Find out the relationship between a line segment and a point.
// There are three options:
//    -1 : Point is left to the line.
//    1  : Point is right to the line.
//    0  : Point parallel with the line
//
double baserelate(const segment& s,const point& p)
{
   if (p == s.source)
      return(0);
   if (p == s.dest)
      return(1);

   double       area=0;

   area += ( s.source.x - s.dest.x) * ( s.source.y + s.dest.y);
   area += ( s.dest.x - p.x) * ( s.dest.y + p.y);
   area += ( p.x - s.source.x) * ( p.y + s.source.y);

   if (area == 0) // The point is parallel to the line.
   {
      double position;
      if (fabs(s.source.x - s.dest.x) > fabs(s.source.y - s.dest.y))
         position = (p.x - s.source.x) / (s.dest.x - s.source.x);
      else
         position = (p.y - s.source.y) / (s.dest.y - s.source.y);

      if ((position >= 0) && (position <= 1))
         return(position);
      else
         return(-1);
   }
   else if (area > 0) // The point is to the left of the line.
   {
      return(-1);
   }
   else // The point is to the right of the line.
   {
      return(-1);
   }
}

//
//===========================================================
// The base of al relationships between a point and a polygon
//===========================================================
//

/*
 * C code from the article
 * "An Incremental Angle Point in Polygon Test"
 * by Kevin Weiler, kjw@autodesk.com
 * in "Graphics Gems IV", Academic Press, 1994
 */

//
// quadrant ids, incremental angles, accumulated angle values
//
typedef short quadrant_type;

//
// determine the quadrant of a polygon point relative to the test point
//
static inline int quadrant(
   const point& vertex,
   const point& p)
{
   return(
    ( (vertex.x > p.x) ? ((vertex.y > p.y) ? 0 : 3) : ( (vertex.y > p.y) ? 1 : 2)
    ));
}

//
// determine x intercept of a polygon edge
// with a horizontal line at the y value of the test point
//
static inline double x_intercept(
   const point& pt1,
   const point& pt2,
   const double& yy)
{
   return(pt2.x - ( (pt2.y - yy) * ((pt1.x - pt2.x) / (pt1.y - pt2.y)) ) );
}

// #define x_intercept(pt1, pt2,  yy) (pt2.x - ( (pt2.y - yy) * ((pt1.x - pt2.x) / (pt1.y - pt2.y)) ) )

//
// determine if a test point is inside of or outside of a polygon
// polygon is "poly", test point is at "x","y"
//
bool inside(const point& p,const polygon& pgn)
{
   if (pgn.hasminitree())
   {
      const minitree* m = pgn.minitreeptr();
      return(inside(p,pgn,*m));
   }

   int  vertex, next_vertex;
   quadrant_type quad, next_quad, delta, angle;

   //
   // initialize
   //
   vertex = 0;
   quad = quadrant(pgn.pnt(vertex), p);
   angle = 0;

   //
   // loop on all vertices of polygon
   //
   do
   {
      next_vertex = (vertex + 1) % pgn.npoints();
      //
      // calculate quadrant and delta from last quadrant
      //
      next_quad = quadrant(pgn.pnt(next_vertex), p);
      delta = next_quad - quad;

      //
      // Adjust delta
      //
      switch (delta)
      {
         //
	 // make quadrant deltas wrap around
	 //
	 case  3:
	    delta = -1; break;					
	 case -3:
	    delta = 1; break;					
         //
	 // check if went around point cw or ccw
	 //
         case  2:
	 case -2:
	    if (x_intercept(pgn.pnt(vertex), pgn.pnt(next_vertex), p.y) > p.x)	
               delta =  - (delta);						
	    break;
      }

      //
      // add delta to total angle sum
      //
      angle = angle + delta;

      //
      // increment for next step
      //
      quad = next_quad;
      vertex = next_vertex;
   }

   while (vertex != 0);

   //
   // complete 360 degrees (angle of + 4 or -4 ) means inside
   //
   if ((angle == +4) || (angle == -4))
      return true;
   else
      return false;

   //
   //odd number of windings rule
   //
   /* if (angle & 4) return TRUE; else return FALSE; */
       /* non-zero winding rule */
   /* if (angle != 0) return TRUE; else return FALSE; */
}


//
//=================================================
// The base of al relationships between two points.
//=================================================
//
bool equivalent(const point& p1,const point& p2)
{
   return((p1.x == p2.x) && (p1.y == p2.y));
}

//
//=================================
// Compare function for the DE-9IM.
//=================================
//
extern bool dimensioncompare(const int dimension,const char pattern)
{
   if (pattern == '*')
      return(true);

   switch(pattern)
   {
      case 'T': return(dimension != -1);
      case 'F': return(dimension == -1);
      case '0': return(dimension == 0);
      case '1': return(dimension == 1);
      case '2': return(dimension == 2);
      default : GDKwarning("Pattern '%c' is not allowed in the DE-9IM methods\n",pattern);
	 break;
   }
   return(false);
}

bool relationship::match(const char matrix[9]) const
{
   return(
      dimensioncompare(dimensions[0],matrix[0]) &&
      dimensioncompare(dimensions[1],matrix[1]) &&
      dimensioncompare(dimensions[2],matrix[2]) &&
      dimensioncompare(dimensions[3],matrix[3]) &&
      dimensioncompare(dimensions[4],matrix[4]) &&
      dimensioncompare(dimensions[5],matrix[5]) &&
      dimensioncompare(dimensions[6],matrix[6]) &&
      dimensioncompare(dimensions[7],matrix[7]) &&
      dimensioncompare(dimensions[8],matrix[8]));
}

int relmatrix::dimension_interior(int dim)
{
   return(dim);
}

int relmatrix::dimension_boundary(int dim)
{
   return(dim - 1);
}

int relmatrix::dimension_exterior(int /* dim */)
{
   return(2);
}

relmatrix::relmatrix(int dima,int dimb,const char matrix[9])
{
   dim_max[INTERIOR_INTERIOR] = MIN(dimension_interior(dima),dimension_interior(dimb));
   dim_max[INTERIOR_BOUNDARY] = MIN(dimension_interior(dima),dimension_boundary(dimb));
   dim_max[INTERIOR_EXTERIOR] = MIN(dimension_interior(dima),dimension_exterior(dimb));
   dim_max[BOUNDARY_INTERIOR] = MIN(dimension_boundary(dima),dimension_interior(dimb));
   dim_max[BOUNDARY_BOUNDARY] = MIN(dimension_boundary(dima),dimension_boundary(dimb));
   dim_max[BOUNDARY_EXTERIOR] = MIN(dimension_boundary(dima),dimension_exterior(dimb));
   dim_max[EXTERIOR_INTERIOR] = MIN(dimension_exterior(dima),dimension_interior(dimb));
   dim_max[EXTERIOR_BOUNDARY] = MIN(dimension_exterior(dima),dimension_boundary(dimb));
   dim_max[EXTERIOR_EXTERIOR] = MIN(dimension_exterior(dima),dimension_exterior(dimb));

   dim_min[0] = -1;
   dim_min[1] = -1;
   dim_min[2] = -1;
   dim_min[3] = -1;
   dim_min[4] = -1;
   dim_min[5] = -1;
   dim_min[6] = -1;
   dim_min[7] = -1;
   dim_min[8] = -1;

   pattern[0] = matrix[0];
   pattern[1] = matrix[1];
   pattern[2] = matrix[2];
   pattern[3] = matrix[3];
   pattern[4] = matrix[4];
   pattern[5] = matrix[5];
   pattern[6] = matrix[6];
   pattern[7] = matrix[7];
   pattern[8] = matrix[8];
}

relationship relationship::reverse() const
{
   return(relationship(
      dimensions[0],
      dimensions[3],
      dimensions[6],
      dimensions[1],
      dimensions[4],
      dimensions[7],
      dimensions[2],
      dimensions[5],
      dimensions[8]));
}

relationship::relationship(int ii,int ib,int ie,int bi,int bb,int be,int ei,int eb,int ee)
{
   dimensions[0] = ii;
   dimensions[1] = ib;
   dimensions[2] = ie;
   dimensions[3] = bi;
   dimensions[4] = bb;
   dimensions[5] = be;
   dimensions[6] = ei;
   dimensions[7] = eb;
   dimensions[8] = ee;
}

char* relationship::tostring() const
{
   char* rval = (char *)GDKmalloc(10);

   for(int i=0;i<9;++i)
   {
      switch(dimensions[i])
      {
	 case -1: rval[i] = '-'; break;
	 case 0 : rval[i] = '0'; break;
	 case 1 : rval[i] = '1'; break;
	 case 2 : rval[i] = '2'; break;
         default:
	    GDKwarning("Invalid dimension %d in relationship::tostring at position %d\n",dimensions[i],i);
            rval[i] = 'X';
	    break;
      }
   }
   rval[9] = 0;

   return(rval);
}

bool relationship::operator==(const relationship& r)
{
   for(int i=0;i<9;++i)
      if (dimensions[i] != r.dimensions[i])
         return(false);
   return(true);
}

bool relmatrix::increase_mindimension(int cell,int newmin)
{
   if (newmin > dim_min[cell])
      dim_min[cell] = newmin;
   return(status(cell) != STATUS_UNKNOWN);
}

bool relmatrix::setdimension(int cell,int d)
{
   dim_min[cell] = d;
   dim_max[cell] = d;
   return(isfalse(cell));
}

int relmatrix::status(int pos) const
{
   int rval = -1;

   switch(pattern[pos])
   {
      case 'T':
	 if ((dim_min[pos] == -1) && (dim_max[pos] == -1))
	    rval = STATUS_FALSE;
	 else
	 {
	    if (dim_min[pos] == -1)
	       rval = STATUS_UNKNOWN;
	    else
	       rval = STATUS_TRUE;
	 }
	 break;
      case 'F':
	 if ((dim_min[pos] == -1) && (dim_max[pos] == -1))
	    rval = STATUS_TRUE;
	 else
	 {
	    if (dim_min[pos] == -1)
	       rval = -1;
	    else
	       rval = STATUS_FALSE;
	 }
	 break;
      case '0':
	 if ((dim_min[pos] == 0) && (dim_max[pos] == 0))
	    rval = STATUS_TRUE;
	 else
	 {
	    if ((dim_max[pos] < 0) || (dim_min[pos] > 0))
	       rval = STATUS_FALSE;
	    else
	       rval = STATUS_UNKNOWN;
	 }
	 break;
      case '1':
	 if ((dim_min[pos] == 1) && (dim_max[pos] == 1))
	    rval = STATUS_TRUE;
	 else
	 {
	    if ((dim_max[pos] < 1) || (dim_min[pos] > 1))
	       rval = STATUS_FALSE;
	    else
	       rval = STATUS_UNKNOWN;
	 }
	 break;
      case '2':
	 if ((dim_min[pos] == 2) && (dim_max[pos] == 2))
	    rval = STATUS_TRUE;
	 else
	 {
	    if (dim_max[pos] < 2)
	       rval = STATUS_FALSE;
	    else
	       rval = STATUS_UNKNOWN;
	 }
	 break;
      case '*':
         rval = STATUS_TRUE;
	 break;
      case '?':
         if (dim_min[pos] == dim_max[pos])
	    rval = STATUS_TRUE;
	 else
	    rval = STATUS_UNKNOWN;
	 break;
      default:
	 GDKwarning("Unknown case '%c' in relationship::status at pos %d\n",pattern[pos],pos);
	 rval = -1;
	 break;
   }
   return(rval);
}

relationship relmatrix::toRelationship() const
{
   return(relationship(
      dimension(0),
      dimension(1),
      dimension(2),
      dimension(3),
      dimension(4),
      dimension(5),
      dimension(6),
      dimension(7),
      dimension(8)
   ));
}

bool relmatrix::match(int pos) const
{
   int v = status(pos);

   if (v == STATUS_UNKNOWN)
   {
      GDKerror("Cannot match relmatrix[%d] = ",pos);
      return(true);
   }
   else
   {
      if (v == STATUS_TRUE)
         return(true);
      else
      {
         if (v == STATUS_FALSE)
	    return(false);
	 else
	 {
	    GDKerror("Strange match relmatrix[%d] = ",pos);
	    return(true);
	 }
      }
   }
}

int relmatrix::dimension(int pos) const
{
   if (dim_max[pos] == dim_min[pos])
      return(dim_max[pos]);
   else
   {
      GDKerror("Cannot know dim of relmatrix[%d] = [%d,%d]\n",pos,dim_min[pos],dim_max[pos]);
      return(-1);
   }
}

bool relmatrix::match() const
{
   return(
      match(0) &&
      match(1) &&
      match(2) &&
      match(3) &&
      match(4) &&
      match(5) &&
      match(6) &&
      match(7) &&
      match(8)
   );
}

bool relmatrix::resolved(int pos) const
{
   return(status(pos) != STATUS_UNKNOWN);
}

bool relmatrix::unresolved(int pos) const
{
   return(status(pos) == STATUS_UNKNOWN);
}

bool relmatrix::isfalse(int pos) const
{
   bool rval = (this->status(pos) == FALSE);
   return(rval);
}
