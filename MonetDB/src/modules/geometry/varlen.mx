@f varlen
@A C.W. Quak
@* The varlen class
@h
#ifndef __VARLEN_H__
#define __VARLEN_H__

// #include "Boolean.h"

class varlen
{
public:
   int nbytes_v;

public:

   //
   // Return true if this instance is equivalent to the null value.
   //
   bool isnull() const;

   //
   // Return the lenght of the array.
   //
   int nbytes() const;

   //
   // Create a varlen with nbytes free bytes.
   //
   static varlen* create(int nbytes);

   //
   // Perform some integrity checks.
   //
   bool OK() const;

   //
   // Return a pointer to the null value of this class.
   //
   static const varlen* null();

   int expectedstrlen() const;
   int tostr(char* s,int len) const;
   static varlen* fromstr(char *s,int* parselen,int *buflen,varlen* p);
   int hash() const;
   int operator== (const varlen& r) const;

   //
   // Make a duplicate of this instance and copy as much data to this new
   // instance as might fit.
   //
   varlen* realloc(int newbytes) const;

   //
   // Make a duplicate of this instance.
   //
   varlen* copy() const;

   //
   // index operator on varray.
   //
   void* index(int idx) const;
};

#define INDEX(HEAP,IDX,TYPE) ((TYPE *)(((char *)(HEAP)) + (IDX)))


#endif /* __VARLEN_H__ */
@C
// #include "Boolean.h"
#include "varlen.h"
#include <stdlib.h>
#include <string.h>
#include <gdk.h>


int varlen::nbytes() const
{
   if (nbytes_v == -1)
      return(sizeof(varlen));

#ifdef DEBUG
   if (nbytes_v < (int)sizeof(varlen))
      GDKerror("varlen::nbytes() too small %d\n",nbytes_v);
#endif
   return(nbytes_v);
}

//
// Create a varlen with the given number of bytes capacity.
//
varlen* varlen::realloc(int newbytes) const
{
   varlen* rval = varlen::create(newbytes);

   int nb = rval->nbytes();

   if (rval->nbytes() < nbytes())
      memcpy(rval,this,rval->nbytes());
   else
      memcpy(rval,this,nbytes());
   
   rval->nbytes_v = nb;
   return(rval);
}

varlen* varlen::create(int nbytes)
{
   int nb = sizeof(varlen) + nbytes;
   varlen* rval = (varlen *)new char[nb];

#ifdef DEBUG
   memset(rval,0,nb);
#endif
   
   rval->nbytes_v = nb;
   return(rval);
}

bool varlen::isnull() const
{
   return(nbytes_v == -1);
}

//
// Null value for varlen.
//
const varlen* varlen::null()
{
   varlen* rval = (varlen*)GDKmalloc(sizeof(varlen));
   rval->nbytes_v = -1;
   return(rval);
}

//
// Returns true if varlen is internally consistent.
//
bool varlen::OK() const
{
   bool rval = true;

   if (nbytes_v < (int)sizeof(varlen))
   {
      GDKerror("varlen::nybtes() too small %d\n");
      rval = true;
   }
   return(rval);
}

void* varlen::index(int ind) const
{
#ifdef DEBUG
   if ((ind < 0) || (ind >= nbytes()))
      GDKerror("varlen::index(%d) out of bounds [0,%d]",ind,nbytes());
#endif
   return((void *)(((char*)this)+ ind));
}

varlen* varlen::copy() const
{
   varlen* rval = (varlen *)new char[nbytes()];
   memcpy(rval,this,nbytes());
   return(rval);
}

int varlen::expectedstrlen() const
{
   return(20 + (nbytes() * 4));
}

int varlen::operator== (const varlen& r) const
{
   if (nbytes() != r.nbytes())
      return(1);

   if (isnull() || r.isnull())
      return(1);

   return((0 == memcmp(this,&r,nbytes())));
}

int varlen::hash() const
{
   return(nbytes());
}

int varlen::tostr(char*,int) const
{
   return 0;
}

varlen* varlen::fromstr(char *,int* ,int *,varlen* )
{
   return NULL;
}
