@f varray
@A C.W. Quak
@* The varray class
@h
#ifndef __VARRAY_H__
#define __VARRAY_H__

#include "varlen.h"

class varray : public varlen
{
private:
   int nitems_v;	// Number of items in varray.
   int index_v;		// Index of itemindex

public:
   //
   // Create a varray which can store at least 'nitems' items with a total size
   // of 'usedbytes' bytes. We do not take into account that you might need more
   // because of alignment.
   //
   static varray* create(
      int nitems,
      int usedbytes);

   //
   // Return 'true' if an object with size 'usedbytes' aligned on a 'aligment' byte
   // boundary could be added to the varray without resizing it.
   //
   bool fits(int usedbytes,int alignment) const;

   //
   // Append object 'obj' to the varray. If it does not fit do not append it and
   // return false. Return true otherwise.
   //
   bool append(const void* obj,int length,int alignment);

   //
   // Return a pointer to object 'idx' in the varray. NULL when this object is not
   // in the varray. Give warning in case of wrong index.
   //
   void* item(int idx);
   void* item(int idx) const;

   //
   // Return an exact duplicate of this object.
   //
   varray* copy() const;

   //
   // Return a minimized copy of the varray.
   //
   varray* minimize() const;

   //
   // Return a duplicate of this object with more free space.
   //
   varray* realloc(int newmaxitems,int newmaxbytes);

   //
   // Pointer to null value for varray.
   //
   static const varray* null();

   //
   // Print status of objects as error messages.
   //
   void info() const;

   //
   // Check internal integrity and give appropriate error messages.
   //
   bool OK() const;

   //
   // Insert a varray into this one
   //
   varray* insert(const varray* newitem);

   //
   // Return number of items in object.
   //
   int nitems() const;

   //
   // Return the number of actually used bytes in the varray.
   //
   int usedbytes() const;
private:
   static varray vnull;
};

#endif /* __VARRAY_H__ */
@C
// #include "Boolean.h"
#include "varray.h"
#include <stdlib.h>
#include <gdk.h>

int varray::nitems() const
{
#ifdef DEBUG
   if (nitems_v < 0)
      GDKerror("varray corrupt nitems() < 0 %d\n",nitems_v);
#endif
   return(nitems_v);
}

int varray::usedbytes() const
{
   return(index_v + (sizeof(int) * nitems()));
}

static inline int roundup_num(int number,int alignment)
{
   int rval = number + alignment -1;
   rval -= (rval % alignment);
   return(rval);
}

//
// Create a varray with the given number of items.
//
varray* varray::create(int nitems,int usedbytes)
{
   int bytesneeded = sizeof(int) * nitems;
   bytesneeded += usedbytes;
   bytesneeded += sizeof(varray) - sizeof(varlen);

   varray* rval = (varray* )varlen::create(bytesneeded);

   rval->index_v = sizeof(varray);
   rval->nitems_v = 0;

   return(rval);
}

varray* varray::insert(const varray* newitem)
{
   varray* rval;

   if (!fits(newitem->usedbytes(),8))
   {
      rval = realloc(1,newitem->usedbytes() + 8);
      delete this;
   }
   else
      rval = this;
   
   rval->append(newitem,newitem->usedbytes(),8);

   //
   // We reduce the size of new inserted item to usedbytes.
   //
   varray* copieditem = (varray *)(rval->item(rval->nitems() - 1));
   copieditem->nbytes_v = copieditem->usedbytes();

   return(rval);
}

varray* varray::realloc(int itemsadded,int bytesadded)
{
   //
   // How many more bytes do we need.
   //
   int bytesneeded = 0;
   bytesneeded += sizeof(int) * (itemsadded);
   bytesneeded += bytesadded;
   bytesneeded += usedbytes();
   bytesneeded -= sizeof(varlen);

   varray* rval = (varray *)varlen::realloc(bytesneeded);
   return(rval);
}

varray* varray::copy() const
{
   return((varray *)varlen::copy());

}

void* varray::item(int inum) const
{
   if ((inum >= 0) && (inum <nitems()))
   {
      int* idx = (int *)index(index_v);
      return(index(idx[inum]));
   }
   else
   {
      GDKwarning("item %d not in [0,%d]\n",inum,nitems());
      return(0);
   }
}

void* varray::item(int inum)
{
   if ((inum >= 0) && (inum <nitems()))
   {
      int* idx = (int *)index(index_v);
      return(index(idx[inum]));
   }
   else
   {
      GDKwarning("item %d not in [0,%d]\n",inum,nitems());
      return(0);
   }
}

//
// Returns whether a given objects fits into a varray.
//
bool varray::fits(int itemsize,int alignment) const
{
   int bytesfree = nbytes() - usedbytes();
   int bytesneeded = roundup_num(itemsize,alignment) + sizeof(int);
   return(bytesneeded < bytesfree);
}

//
// Print all available info on this varray.
//
void varray::info() const
{
   GDKwarning("Object has %d bytes\n",nbytes());
   GDKwarning("Object has %d items\n",nitems_v);
   GDKwarning("The itemindex starts at %d\n",index_v);

   int* idx = (int *)index(index_v);
   for(int i=0;i<nitems_v;++i)
      GDKwarning("   object %d starts at %d\n",i,idx[i]);
}

//
// Appends the given item to the varray.
//
bool varray::append(const void* item,int itemsize,int alignment)
{
   if (!fits(itemsize,alignment))
   {
      GDKerror("append does not fit\n");
      return(false);
   }

   //
   // Save old itemindices in itemsave.
   //
   // int *itemsave = new int[nitems() +1];
   int *itemsave = (int *)GDKmalloc(sizeof(int) * (nitems() +1));
   {
      int* currentplace = (int*)index(index_v);

      for(int i=0;i<nitems();++i)
	 itemsave[i] = currentplace[i];
   }
   int newitem_index = roundup_num(index_v,alignment);
   itemsave[nitems()] = newitem_index;

   void* newplace = index(newitem_index);
   memcpy(newplace,item,itemsize);
   
   ++nitems_v;
   index_v = newitem_index + roundup_num(itemsize,4);

   //
   // And copy them back
   //
   {
      int* currentplace = (int*)index(index_v);

      for(int i=0;i<nitems();++i)
	 currentplace[i] = itemsave[i];
   }

   delete [] itemsave;

   return(true);
}

//
// Null value for varray.
//
const varray* varray::null()
{
   return((varray*)varlen::null());
}

//
// Returns true if varray is internally consistent.
//
bool varray::OK() const
{
   bool rval;

   if (isnull())
      rval = true;
   else
   {
      if (nitems_v < 0)
	 GDKerror("varray corrupt nitems() < 0 %d\n",nitems_v);
      if (nbytes() < (int)sizeof(varray))
	 GDKerror("varray corrupt nbytes() too small %d\n",nbytes());

      rval = true;
   }
   return(rval);
}
