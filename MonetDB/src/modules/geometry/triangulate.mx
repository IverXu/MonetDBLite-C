@f triangulate
@A C.W. Quak
@* The module 'triangulate'
@h
#ifndef __TRIANGULATE_H__
#define __TRIANGULATE_H__

extern void triangulate(const polygon& p,Array<segment>& rval);
extern void triangulate(const polygon& p,Array<triangle>& rval);

extern int triangulate(const cpolygon& pol,segment **rval);
extern int triangulate(int *x1,int *x2,int *x3,const polygon& pol);

extern int triangulate_polygon(
   int ncontours,
   int *cntr,
   double (*vertices)[2],
   int (*triangles)[3]);


extern int triangulate(
   const cpolygon& c,
   int (*triangles)[3]);


#endif /* __TRIANGULATE_H__ */
@+ Implementation of functions in distance.
@C
#include "gis.h"
#include "triangulate.h"

//
// Error. XXX QQQ
// 
// Somehow, it goes awfully wrong with islands.
//
int triangulate(const cpolygon& c,segment **retval)
{
   int nvertices = c.boundary().npoints();

   if (c.nholes() != 0)
   {
      GDKwarning("triangulate must be debugged first\n");
   }

   for(int i=0;i<c.nholes();++i)
      nvertices += c.hole(i).npoints() ;

   int* polygonid = new int[nvertices];
   int* pointid = new int[nvertices];
   double (*vertices)[2] =  new double[nvertices][2];

   int ncontours = 1 + c.nholes();
   int* contour = new int[ncontours];
   int current_contour = 0;

   int current_vertex = 1; 		// strangely enough we start at 1.

   for(int hole=-1;hole<c.nholes();++hole)
   {
      const polygon& p = c.hole(hole);

      contour[current_contour] = p.npoints();

      int incr;
      int spoint;

      if (((hole == -1) && p.clockwise()) || ((hole != -1) && !p.clockwise()))
      {
	 incr = -1;
	 spoint = p.npoints() - 1;
      }
      else
      {
	 incr = 1;
	 spoint = 0;
      }

      for(int j=0;j<p.npoints();++j)
      {
	 polygonid[current_vertex] = hole;
	 pointid[current_vertex] = spoint + (incr * j);
	 vertices[current_vertex][0] = p.pnt(spoint + (incr * j)).x;
	 vertices[current_vertex][1] = p.pnt(spoint + (incr * j)).y;

	 ++current_vertex;
      }
      ++current_contour;
   }

   if (current_vertex != nvertices + 1)
      GDKwarning("cv = %d and nv = %d\n",current_vertex,nvertices);

   //
   // Call triangulate.
   //
   int (*triangs)[3] =  new int[nvertices - 2][3];
   
   int ntriangs = triangulate_polygon(ncontours,contour,vertices,triangs);

   int nedges = ((3 * ntriangs) - nvertices)/2;


   //
   // Process data to desired return type.
   //
   segment* rval = new segment[nedges];

   int current = 0;

   for(int j=0;j<ntriangs;++j)
   {
      for(int k=0;k<3;++k)
      {
	 int start = triangs[j][k];
	 int end = triangs[j][(k+1)%3];

	 if (polygonid[start] == polygonid[end])
	 {
	    if (start > end)
	       continue;
	    if (start + 1 == end)
	       continue;
	    if ((start == 0) && (end == nvertices))
	       continue;
	 }
	 else
	 {
	    if (polygonid[start] < polygonid[end])
	       continue;
	 }
      

	 if (current == nedges)
	 {
	    GDKwarning("too many segs returned\n");
	    --current;
	 }

         rval[current].set(
	    c.hole(polygonid[start]).pnt(pointid[start]),
	    c.hole(polygonid[end]).pnt(pointid[end]));
	 ++current;
      }
   }

   if (current != nedges)
      GDKwarning("not enough segs returned\n");

   delete [] polygonid;
   delete [] pointid;
   delete [] vertices;
   delete [] contour;
   delete [] triangs;

   *retval = rval;
   return(current);
}

void triangulate(const polygon& p,Array<segment>& rval)
{
   rval.clear();
   if (p.npoints() <= 3)
      return;

   //
   // Preprocess date for routine.
   //
   int ntriangs = p.npoints() -2;
   int (*triangs)[3] = new int[ntriangs][3];
   double (*vertices)[2] = new double[p.npoints()+1][2];
   int ncontours = 1;
   int cntr[1] = {p.npoints()};

   int incr;
   int spoint;
   if (p.clockwise())
   {
      incr = -1;
      spoint = p.npoints() - 1;
   }
   else
   {
      incr = 1;
      spoint = 0;
   }

   for(int i=0;i<p.npoints();++i)
   {
      vertices [i + 1][0] = p.pnt(spoint + (incr * i)).x;
      vertices [i + 1][1] = p.pnt(spoint + (incr * i)).y;
   }

   //
   // Call triangulate.
   //
   triangulate_polygon(ncontours,cntr,vertices,triangs);

   //
   // Process data to desired return type.
   //
   int nsegs = p.npoints() -3;
   int current = 0;

   for(int j=0;j<ntriangs;++j)
   {
      for(int k=0;k<3;++k)
      {
	 int start = triangs[j][k] -1;
	 int end = triangs[j][(k+1)%3] -1;

	 if (start > end)
	    continue;
	 if (start + 1 == end)
	    continue;
	 if ((start == 0) && (end == p.npoints()))
	    continue;

	 if (current == nsegs)
	 {
	    GDKwarning("too many segs returned\n");
	    --current;
	 }

	 rval.append(segment(p.pnt(spoint + (incr * start)),
	                     p.pnt(spoint + (incr * end))));
	 ++current;
      }
   }

   if (current != nsegs)
      GDKwarning("not enough segs returned\n");

   delete [] triangs;
   delete [] vertices;
   return;
}

int triangulate(
   int* np1,
   int* np2,
   int* np3,
   const polygon& p)
{
   if (p.npoints() < 3)
   {
      return(0);
   }

   //
   // Preprocess date for routine.
   //
   int ntriangs = p.npoints() -2;
   int (*triangs)[3] = new int[ntriangs][3];
   double (*vertices)[2] = new double[p.npoints()+1][2];
   int ncontours = 1;
   int cntr[1] = {p.npoints()};

   int incr;
   int spoint;
   if (p.clockwise())
   {
      incr = -1;
      spoint = p.npoints() - 1;
   }
   else
   {
      incr = 1;
      spoint = 0;
   }

   for(int i=0;i<p.npoints();++i)
   {
      vertices [i + 1][0] = p.pnt(spoint + (incr * i)).x;
      vertices [i + 1][1] = p.pnt(spoint + (incr * i)).y;
   }

   //
   // Call triangulate.
   //
   triangulate_polygon(ncontours,cntr,vertices,triangs);

   for(int j=0;j<ntriangs;++j)
   {
      np1[j] = spoint + (incr * (triangs[j][0] -1));
      np2[j] = spoint + (incr * (triangs[j][1] -1));
      np3[j] = spoint + (incr * (triangs[j][2] -1));
   }

   delete [] triangs;
   delete [] vertices;

   return(ntriangs);
}



void triangulate(const polygon& p,Array<triangle>& rval)
{
   if (p.npoints() < 3)
      return;

   //
   // Preprocess date for routine.
   //
   int ntriangs = p.npoints() -2;
   int (*triangs)[3] = new int[ntriangs][3];
   double (*vertices)[2] = new double[p.npoints()+1][2];
   int ncontours = 1;
   int cntr[1] = {p.npoints()};

   int incr;
   int spoint;
   if (p.clockwise())
   {
      incr = -1;
      spoint = p.npoints() - 1;
   }
   else
   {
      incr = 1;
      spoint = 0;
   }

   for(int i=0;i<p.npoints();++i)
   {
      vertices [i + 1][0] = p.pnt(spoint + (incr * i)).x;
      vertices [i + 1][1] = p.pnt(spoint + (incr * i)).y;
   }

   //
   // Call triangulate.
   //
   triangulate_polygon(ncontours,cntr,vertices,triangs);

   //
   // Process data to desired return type.
   //
   for(int j=0;j<ntriangs;++j)
   {
      rval.append(triangle(
	  p.pnt(spoint + (incr * (triangs[j][0] -1))),
	  p.pnt(spoint + (incr * (triangs[j][1] -1))),
	  p.pnt(spoint + (incr * (triangs[j][2] -1)))));
   }

   delete [] triangs;
   delete [] vertices;

   return;
}
@mil
setoid(oid(20000000));
module(gis);
p := polygon("(4:-2,2,2,2,2,-2,-2,-2)");
p.triangulate.print;
c := cpolygon("(0:(4:-2,2,2,2,2,-2,-2,-2))");
c.triangulate.print;
#c := cpolygon("(1:(4:-2,2,2,2,2,-2,-2,-2),(4:-1,1,1,1,1,-1,-1,-1))");
#c.triangulate.print;

quit;
