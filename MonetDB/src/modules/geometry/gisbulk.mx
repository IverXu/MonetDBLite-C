@f gisbulk
@A C.W. Quak
@* The 'gisbulk' module.
@m
.MODULE gisbulk;

   .USE opengis;

   .ACCELERATOR octree(box3d);
      .BUILD     = octree_build;
      .DESTROY   = octree_destroy;
      .INSERT    = octree_insert;
      .DELETE    = octree_delete;
      .SAVE      = octree_save;
      .REPAIR    = ACCrepairSTD;
   .END;

   .ACCELERATOR interval_tree(interval);
      .BUILD     = interval_tree_build;
      .DESTROY   = interval_tree_destroy;
      .INSERT    = interval_tree_insert;
      .DELETE    = interval_tree_delete;
      .SAVE      = interval_tree_save;
      .REPAIR    = ACCrepairSTD;
   .END;

   .ACCELERATOR rtree_box(box);
      .BUILD     = RTREEbuild_box;
      .DESTROY   = RTREEdestroy;
      .INSERT    = RTREEinsert_box;
      .DELETE    = RTREEdelete_box;
      .SAVE      = RTREEsave;
      .REPAIR    = ACCrepairSTD;
   .END;

   .ACCELERATOR rtree_point(point);
      .BUILD     = RTREEbuild_point;
      .DESTROY   = RTREEdestroy;
      .INSERT    = RTREEinsert_point;
      .DELETE    = RTREEdelete_point;
      .SAVE      = RTREEsave;
      .REPAIR    = ACCrepairSTD;
   .END;

   .ACCELERATOR rtree_segment(segment);
      .BUILD     = RTREEbuild_segment;
      .DESTROY   = RTREEdestroy;
      .INSERT    = RTREEinsert_segment;
      .DELETE    = RTREEdelete_segment;
      .SAVE      = RTREEsave;
      .REPAIR    = ACCrepairSTD;
   .END;

   .ACCELERATOR rtree_polyline(polyline);
      .BUILD     = RTREEbuild_polyline;
      .DESTROY   = RTREEdestroy;
      .INSERT    = RTREEinsert_polyline;
      .DELETE    = RTREEdelete_polyline;
      .SAVE      = RTREEsave;
      .REPAIR    = ACCrepairSTD;
   .END;

   .ACCELERATOR rtree_polygon(polygon);
      .BUILD     = RTREEbuild_polygon;
      .DESTROY   = RTREEdestroy;
      .INSERT    = RTREEinsert_polygon;
      .DELETE    = RTREEdelete_polygon;
      .SAVE      = RTREEsave;
      .REPAIR    = ACCrepairSTD;
   .END;

   .COMMAND rtreebbox(bat[any,box]) :box 		= RTREEbbox_box; ""
   .COMMAND rtreebbox(bat[any,segment]) :box 		= RTREEbbox_segment; ""
   .COMMAND rtreebbox(bat[any,point]) :box 		= RTREEbbox_point; ""
   .COMMAND rtreebbox(bat[any,polygon]) :box 		= RTREEbbox_polygon; ""
   .COMMAND rtreebbox(bat[any,polyline]) :box 		= RTREEbbox_polyline; ""

   .COMMAND rtree_ok(bat[box,any]) : bit		= RTREEok_box; ""
   .COMMAND rtree_ok(bat[point,any]) : bit		= RTREEok_point; ""
   .COMMAND rtree_ok(bat[segment,any]) : bit		= RTREEok_segment; ""
   .COMMAND rtree_ok(bat[polyline,any]) : bit		= RTREEok_polyline; ""
   .COMMAND rtree_ok(bat[polygon,any]) : bit		= RTREEok_polygon; ""

   .COMMAND rtree_print(bat[box,any]) 			= RTREEprint_segment; ""
   .COMMAND rtree_print(bat[point,any]) 		= RTREEprint_point; ""
   .COMMAND rtree_print(bat[segment,any]) 		= RTREEprint_box; ""
   .COMMAND rtree_print(bat[polyline,any]) 		= RTREEprint_polyline; ""
   .COMMAND rtree_print(bat[polygon,any]) 		= RTREEprint_polygon; ""
   .COMMAND octree_print(bat[any,box3d]) 		= octree_print; ""

   .COMMAND octree_number(bat[any,box3d]): bat[int,box3d]	 = octree_number; ""
   .COMMAND octree_number_leaves(bat[any,box3d]): bat[int,box3d] = octree_number_leaves; ""
   .COMMAND rtree_number_leaves(bat[any,box]): bat[int,box] 	 = rtree_number_leaves; ""

   .COMMAND rtreecluster(bat[box,any])         		= RTREEcluster_box; ""

   .COMMAND iselect(
             bat[any,interval],
	     interval)		   : bat[any,interval]	= interval_tree_select_interval; ""

   .COMMAND iselect(
             bat[any,interval],
	     dbl)		   : bat[any,interval]	= interval_tree_select_double; ""
   .COMMAND interval_tree_print(bat[any,interval]) 	= interval_tree_print; ""


   .COMMAND sselect(bat[any,box],box) 
   				: bat[any,box] 	    	= RTREEselect_box_box; "Select all boxes from the given bat which overlap with the given box"
   .COMMAND sselect(bat[any,point],box) 
   				: bat[any,point]	= RTREEselect_point_box; "Select all points from the given bat which are inside the given box"
   .COMMAND sselect(bat[any,polyline],box) 
   				: bat[any,polyline]	= RTREEselect_polyline_box; "Select all polylines from the BAT of which the bounding box overlaps with the given box"
   .COMMAND sselect(bat[any,polygon],box) 
   				: bat[any,polygon]	= RTREEselect_polygon_box; "Select all polylines from the BAT of which the bounding box overlaps with the given box"
   .COMMAND sselect(bat[any,segment],box) 
   				: bat[any,segment]	= RTREEselect_segment_box; "Select all segments from the BAT of which the bounding box overlaps with the given box"
   .COMMAND sselect_cross(bat[any,segment],segment)
   				: bat[any,segment]	= RTREEselect_segment_segment;"Select all segments from the BAT which cross the given segent"
   .COMMAND sselect(bat[any,box3d],box3d) 
   				: bat[any,box3d] 	= octree_select_box3d;  "Select all boxes from the given bat which overlap with the given box"

   .COMMAND sselect_overlap(bat[any::1,polyline],polyline)
   			: bat[any::1,polyline]		= RTREEselect_polyline_polyline_overlap; "Returns all polylines that have something different than an endpoint in common"


   .COMMAND sjoin(bat[any::1,box],bat[box,any::2])
				: bat[any::1,any::2]	= RTREEjoin_box_box; ""
   .COMMAND sjoin(bat[any::1,box],bat[point,any::2])
				: bat[any::1,any::2]	= RTREEjoin_box_point; ""
   .COMMAND sjoin(bat[any::1,point],bat[box,any::2])
				: bat[any::1,any::2]	= RTREEjoin_point_box; ""
   .COMMAND sjoin(bat[any::1,segment],bat[segment,any::2])
				: bat[any::1,any::2]	= RTREEjoin_segment_segment; ""

   .COMMAND dselect(bat[any,box],point,dbl,dbl)
   				: bat[any,box]		= RTREEdselect_box_point; ""
   .COMMAND dselect(bat[any,box],box,dbl,dbl)
   				: bat[any,box]		= RTREEdselect_box_box; ""
   .COMMAND dselect(bat[any,point],point,dbl,dbl)
   				: bat[any,point]	= RTREEdselect_point_point; ""


   .COMMAND djoin(bat[any,box],bat[box,any],dbl,dbl)
   				: bat[any,any]		= RTREEdjoin_box_box; ""
   .COMMAND djoin(bat[any,point],bat[point,any],dbl,dbl)
   				: bat[any,any]		= RTREEdjoin_point_point; ""
   .COMMAND djoin(bat[any,box],bat[point,any],dbl,dbl)
   				: bat[any,any]		= RTREEdjoin_box_point; ""
   .COMMAND djoin(bat[any,point],bat[box,any],dbl,dbl)
   				: bat[any,any]		= RTREEdjoin_point_box; ""
	    

   .COMMAND disjoint_join(bat[any,box],bat[box,any])
   				: bat[any,any]		= RTREEdisjointjoin_box_box; ""
   .COMMAND inside_join(bat[any,box],bat[box,any])
   				: bat[any,any]		= RTREEijoin_box_box; ""
   .COMMAND inside_join(bat[any,polygon],bat[polygon,any])
   				: bat[any,any]		= RTREEijoin_polygon_polygon; ""


   .COMMAND sselect(bat[any,segment],segment,int)		
   			: bat[any,segment]	= RTREEselect_ext_segment_segment; ""
   .COMMAND sjoin(bat[any,segment],bat[segment,any],int)
   			: bat[any,any]		= RTREEjoin_ext_segment_segment; ""

   .COMMAND sjoin_overlap(bat[any::1,polyline],bat[polyline,any::2])
   			: bat[any::1,any::2]		= RTREEjoin_polyline_polyline_overlap; "Returns all pairs of polylines that have something different than an endpoint in common"
   .COMMAND sjoin_overlap(bat[any::1,segment],bat[segment,any::2])
   			: bat[any::1,any::2]		= RTREEjoin_segment_segment_overlap; "Returns all pairs of segments that have something different than an endpoint in common"

.END gisbulk;
@+ Header Code for gisbulk.
@h
#ifndef __GISBULK_H__
#define __GISBULK_H__

#include "gis.h"
#include "opengis.h"
#include "rtree.h"
#include "rtree_point.h"
#include "rtree_box.h"
#include "rtree_segment.h"
#include "rtree_polyline.h"
#include "rtree_polygon.h"
#include "rtree_djoin.h"
#include "gisbulk.proto.h"

#endif /* __GISBULK_H__ */
@C
#include "gis.h"
#include "gisbulk.h"

int RTREEjoin_segment_segment(
   BAT** rval,
   BAT*  left,
   BAT*  right)
{
   //
   // If there are no indices we create them.
   //
   if (left->tacctype != ACC_rtree_segment)
   {
      int dummy;
      
      RTREEbuild_segment(&left->taccelerator,&dummy,BATmirror(left));
   }
   if (right->hacctype != ACC_rtree_segment)
   {
      int dummy;
      
      RTREEbuild_segment(&right->haccelerator,&dummy,right);
   }

   *rval = join_param_segment_segment(left,right,relationship::CROSS);
   return(GDK_SUCCEED);
}

int RTREEjoin_box_box(
   BAT** rval,
   BAT*  left,
   BAT*  right)
{
   //
   // If there are no indices we create them.
   //
   if (left->tacctype != ACC_rtree_box)
   {
      int dummy;
      
      RTREEbuild_box(&left->taccelerator,&dummy,BATmirror(left));
   }
   if (right->hacctype != ACC_rtree_box)
   {
      int dummy;
      
      RTREEbuild_box(&right->haccelerator,&dummy,right);
   }

   *rval = join_overlap_box_box(left,right);
   return(GDK_SUCCEED);
}

int RTREEdjoin_box_box(
   BAT** rval,
   BAT*  leftboxes,
   BAT*  rightboxes,
   dbl*  mindist,
   dbl*	 maxdist)
{
   //
   // If there are no indices we create them.
   //
   if (leftboxes->tacctype != ACC_rtree_box)
   {
      int dummy;

      RTREEbuild_box(&leftboxes->taccelerator,&dummy,BATmirror(leftboxes));
   }
   if (rightboxes->hacctype != ACC_rtree_box)
   {
      int dummy;

      RTREEbuild_box(&rightboxes->haccelerator,&dummy,rightboxes);
   }

   //
   // We convert from distances to squared distances.
   //
   if (mindist != NULL)
     *mindist *= *mindist;
   if (maxdist != NULL)
     *maxdist *= *maxdist;


   *rval = join_squared_dist_box_box(
      leftboxes,
      rightboxes,
      mindist,
      maxdist);
   return(GDK_SUCCEED);
}

int RTREEdjoin_point_point(
   BAT** rval,
   BAT*  leftpoints,
   BAT*  rightpoints,
   dbl*  mindist,
   dbl*	 maxdist)
{
   //
   // If there are no indices we create them.
   //
   if (leftpoints->tacctype != ACC_rtree_point)
   {
      int dummy;

      RTREEbuild_point(&leftpoints->taccelerator,&dummy,BATmirror(leftpoints));
   }
   if (rightpoints->hacctype != ACC_rtree_point)
   {
      int dummy;

      RTREEbuild_point(&rightpoints->haccelerator,&dummy,rightpoints);
   }

   //
   // We convert from distances to squared distances.
   //
   if (mindist != NULL)
     *mindist *= *mindist;
   if (maxdist != NULL)
     *maxdist *= *maxdist;

   *rval = join_squared_dist_point_point(
      leftpoints,
      rightpoints,
      mindist,
      maxdist);
   return(GDK_SUCCEED);
}

int RTREEdjoin_point_box(
   BAT** rval,
   BAT*  leftpoints,
   BAT*  rightboxes,
   dbl*  mindist,
   dbl*	 maxdist)
{
   //
   // If there are no indices we create them.
   //
   if (leftpoints->tacctype != ACC_rtree_point)
   {
      int dummy;
      RTREEbuild_point(&leftpoints->taccelerator,&dummy,BATmirror(leftpoints));
   }
   if (rightboxes->hacctype != ACC_rtree_box)
   {
      int dummy;
      RTREEbuild_box(&rightboxes->haccelerator,&dummy,rightboxes);
   }

   //
   // We convert from distances to squared distances.
   //
   if (mindist != NULL)
     *mindist *= *mindist;
   if (maxdist != NULL)
     *maxdist *= *maxdist;

   *rval = join_squared_dist_point_box(
      leftpoints,
      rightboxes,
      mindist,
      maxdist);
   return(GDK_SUCCEED);
}

int RTREEdjoin_box_point(
   BAT** rval,
   BAT*  leftboxes,
   BAT*  rightpoints,
   dbl*  mindist,
   dbl*	 maxdist)
{
   //
   // If there are no indices we create them.
   //
   if (leftboxes->tacctype != ACC_rtree_box)
   {
      int dummy;

      RTREEbuild_box(&leftboxes->taccelerator,&dummy,BATmirror(leftboxes));
   }
   if (rightpoints->hacctype != ACC_rtree_point)
   {
      int dummy;

      RTREEbuild_point(&rightpoints->haccelerator,&dummy,rightpoints);
   }

   //
   // We convert from distances to squared distances.
   //
   if (mindist != NULL)
     *mindist *= *mindist;
   if (maxdist != NULL)
     *maxdist *= *maxdist;

   *rval = join_squared_dist_point_box(
      BATmirror(rightpoints),
      BATmirror(leftboxes),
      mindist,
      maxdist);

   if (*rval != 0)
      *rval = BATmirror(*rval);

   return(GDK_SUCCEED);
}

int RTREEjoin_box_point(
   BAT** rval,
   BAT*  boxes,
   BAT*  points)
{
   //
   // If there are no indices we create them.
   //
   if (boxes->tacctype != ACC_rtree_box)
   {
      int dummy;

      RTREEbuild_box(&boxes->taccelerator,&dummy,BATmirror(boxes));
   }
   if (points->hacctype != ACC_rtree_point)
   {
      int dummy;

      RTREEbuild_point(&points->haccelerator,&dummy,points);
   }

   *rval = join_overlap_box_point(boxes,points);

   return(GDK_SUCCEED);
}

int RTREEjoin_point_box(
   BAT** rval,
   BAT*  points,
   BAT*  boxes)
{
   int retval = RTREEjoin_box_point(
      rval,
      BATmirror(boxes),
      BATmirror(points));

   if (*rval != 0)
      *rval = BATmirror(*rval);

   return(retval);
}

int RTREEselect_point_box(
   BAT** rval,
   BAT*  points,
   box*  rectangle)
{
   if (points->tacctype != ACC_rtree_point)
   {
      int dummy;
      RTREEbuild_point(&points->taccelerator,&dummy,BATmirror(points));
   }

   *rval = select_overlap_point_box(points,*rectangle);

   return(GDK_SUCCEED);
}

int RTREEselect_polyline_box(
   BAT** retval,
   BAT*  polylines,
   box*  rectangle)
{
   if (polylines->tacctype != ACC_rtree_polyline)
   {
      int dummy;
      RTREEbuild_polyline(&polylines->taccelerator,&dummy,BATmirror(polylines));
   }

   *retval = select_overlap_polyline_box(polylines,*rectangle);
   return(GDK_SUCCEED);
}

int RTREEselect_polygon_box(
   BAT** retval,
   BAT*  polygons,
   box*  rectangle)
{
   if (polygons->tacctype != ACC_rtree_polygon)
   {
      int dummy;
      RTREEbuild_polygon(&polygons->taccelerator,&dummy,BATmirror(polygons));
   }

   *retval = select_overlap_polygon_box(polygons,*rectangle);
   return(GDK_SUCCEED);
}

int RTREEselect_segment_box(
   BAT** retval,
   BAT*  segments,
   box*  rectangle)
{
   if (segments->tacctype != ACC_rtree_segment)
   {
      int dummy;

      RTREEbuild_segment(&segments->taccelerator,&dummy,BATmirror(segments));
   }

   *retval = select_overlap_segment_box(segments,*rectangle);
   return(GDK_SUCCEED);
}

int RTREEselect_box_box(
   BAT** retval,
   BAT*  boxes,
   box*  rectangle)
{
   if (boxes->tacctype != ACC_rtree_box)
   {
      int dummy;
      RTREEbuild_box(&boxes->taccelerator,&dummy,BATmirror(boxes));
   }

   *retval = select_overlap_box_box(boxes,*rectangle);
   return(GDK_SUCCEED);
}

int RTREEselect_segment_segment(
   BAT**     retval,
   BAT*      segments,
   segment*  segment)
{
   if (segments->tacctype != ACC_rtree_segment)
   {
      int dummy;
      RTREEbuild_segment(&segments->taccelerator,&dummy,BATmirror(segments));
   }

   *retval = select_param_segment_segment(segments,*segment,relationship::CROSS);
   return(GDK_SUCCEED);
}

int RTREEdselect_point_point(
   BAT**     retval,
   BAT*      points,
   point*    p,
   double*   min,
   double*   max)
{
   if (points->tacctype != ACC_rtree_point)
   {
      int dummy;
      RTREEbuild_point(&points->taccelerator,&dummy,BATmirror(points));
   }

   *retval = select_dist_point_point(points,*p,min,max);
   return(GDK_SUCCEED);
}

int RTREEdselect_box_point(
   BAT** rval,
   BAT*  rectlist,
   point*  p,
   double* min,
   double* max)
{
   if (BATttype(rectlist) != TYPE_box)
   {
      GDKerror("No selects allowed on this type only on box\n");
      return(GDK_FAIL);
   }
   if (rectlist->tacctype != ACC_rtree_box)
   {
      GDKerror("There is no index on bat so RTREEselect is wrong\n");
      return(GDK_FAIL);
   }

   box b(*p);

   *rval = select_dist_box_box(rectlist,b,min,max);
   return(GDK_SUCCEED);
}

int RTREEdselect_box_box(
   BAT** rval,
   BAT*  rectlist,
   box*  rectangle,
   double* min,
   double* max)
{
   if (BATttype(rectlist) != TYPE_box)
   {
      GDKerror("No selects allowed on this type only on box\n");
      return(GDK_FAIL);
   }
   if (rectlist->tacctype != ACC_rtree_box)
   {
      GDKerror("There is no index on bat so RTREEselect is wrong\n");
      return(GDK_FAIL);
   }

   *rval = select_dist_box_box(rectlist,*rectangle,min,max);
   return(GDK_SUCCEED);
}

int RTREEdisjointjoin_box_box(
   BAT** rval,
   BAT*  left,
   BAT*  right)
{

   if (left->tacctype != ACC_rtree_box)
   {
      int dummy;
      RTREEbuild_box(&left->taccelerator,&dummy,BATmirror(left));
   }
   if (right->hacctype != ACC_rtree_box)
   {
      int dummy;
      RTREEbuild_box(&right->haccelerator,&dummy,left);
   }

   *rval = join_disjoint_box_box(left,right);
   return(GDK_SUCCEED);
}

int RTREEijoin_polygon_polygon(
   BAT** rval,
   BAT*  left,
   BAT*  right)
{

   if (left->tacctype != ACC_rtree_polygon)
   {
      int dummy;
      RTREEbuild_polygon(&left->taccelerator,&dummy,BATmirror(left));
   }
   if (right->hacctype != ACC_rtree_polygon)
   {
      int dummy;
      RTREEbuild_polygon(&right->haccelerator,&dummy,right);
   }

   *rval = join_inside_polygon_polygon(left,right);
   return(GDK_SUCCEED);
}

int RTREEijoin_box_box(
   BAT** rval,
   BAT*  left,
   BAT*  right)
{

   if (left->tacctype != ACC_rtree_box)
   {
      int dummy;
      RTREEbuild_box(&left->taccelerator,&dummy,BATmirror(left));
   }
   if (right->hacctype != ACC_rtree_box)
   {
      int dummy;
      RTREEbuild_box(&right->haccelerator,&dummy,right);
   }

   *rval = join_inside_box_box(left,right);
   return(GDK_SUCCEED);
}

int RTREEcluster_box(BAT* bat)
{
   if (bat->hacctype != ACC_rtree_box)
   {
      GDKwarning("rtree cluster impossible because no ACC_rtree_box there");
      return(GDK_FAIL);
   }

   RTREEcluster(bat);
   return(GDK_SUCCEED);
}

int RTREEselect_ext_segment_segment(
   BAT** rval,
   BAT*  seglist,
   segment*  s,
   int*  type)
{
   //
   // Some sanity checking.
   //
   if (BATttype(seglist) != TYPE_segment)
   {
      GDKerror("No selects allowed on this type only on segment\n");
      return(GDK_FAIL);
   }
   if (seglist->tacctype != ACC_rtree_segment)
   {
      GDKerror("There is no index on bat so RTREEselect is wrong\n");
      return(GDK_FAIL);
   }

   *rval = select_param_segment_segment(seglist,*s,*type);
   return(GDK_SUCCEED);
}

int RTREEselect_polyline_polyline_overlap(
   BAT** rval,
   BAT*  left,
   polyline* p)
{

   //
   // Some sanity checking.
   //
   if (left->tacctype != ACC_rtree_polyline)
   {
      int dummy;
      RTREEbuild_polyline(&left->taccelerator,&dummy,BATmirror(left));
   }

   *rval = select_overlap_polyline_polyline(left,*p);
   return(GDK_SUCCEED);
}

int RTREEjoin_polyline_polyline_overlap(
   BAT** rval,
   BAT*  left,
   BAT*  right)
{

   //
   // Some sanity checking.
   //
   if (left->tacctype != ACC_rtree_polyline)
   {
      int dummy;
      RTREEbuild_polyline(&left->taccelerator,&dummy,BATmirror(left));
   }
   if (right->hacctype != ACC_rtree_polyline)
   {
      int dummy;
      RTREEbuild_polyline(&right->haccelerator,&dummy,right);
   }

   *rval = join_overlap_polyline_polyline(left,right);
   return(GDK_SUCCEED);
}

int RTREEjoin_segment_segment_overlap(
   BAT** rval,
   BAT*  left,
   BAT*  right)
{

   //
   // Some sanity checking.
   //
   if (left->tacctype != ACC_rtree_segment)
   {
      int dummy;
      RTREEbuild_segment(&left->taccelerator,&dummy,BATmirror(left));
   }
   if (right->hacctype != ACC_rtree_segment)
   {
      int dummy;
      RTREEbuild_segment(&right->haccelerator,&dummy,right);
   }

   *rval = join_overlap_segment_segment(left,right);
   return(GDK_SUCCEED);
}

int RTREEjoin_ext_segment_segment(
   BAT** rval,
   BAT*  left,
   BAT*  right,
   int*  type)
{

   //
   // Some sanity checking.
   //
   if (left->tacctype != ACC_rtree_segment)
   {
      GDKerror("Left BAT must have tail accelerator\n");
      return(GDK_FAIL);
   }
   if (right->hacctype != ACC_rtree_segment)
   {
      GDKerror("Right BAT must have head accelerator\n");
      return(GDK_FAIL);
   }

   *rval = join_param_segment_segment(left,right,*type);
   return(GDK_SUCCEED);
}

@mil
setoid(oid(20000000));
module(gisbulk);

boxes := new(int,box);

b1 := box("(0,1,1,0)");
b2 := box("(0,10,10,0)");
b3 := box("(-10,-1,-1,-10)");

boxes.insert(1,b1);
boxes.insert(2,b2);
boxes.insert(3,b3);
boxes.reverse.accbuild(rtree_box);
boxes.delete(1,b1);
boxes.delete(2,b2);
boxes.delete(3,b3);
boxes.reverse.rtree_ok();
# this print should be empty.
boxes.print;
boxes.insert(1,b1);
boxes.insert(2,b2);
boxes.insert(3,b3);

# this should print [5].
boxes.sjoin(boxes.reverse).count.print;
boxes.reverse.accdestroy(rtree_box);

points := new(int,point);
points.insert(1,point("(0,1)"));
points.insert(2,point("(0,2)"));
points.insert(3,point("(0,3)"));
points.reverse.accbuild(rtree_point);

#points.dselect(point("(0,0)"),dbl("0.5"),dbl("1.5"));

quit;
