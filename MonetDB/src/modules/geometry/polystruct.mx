@f polystruct
@A C.W. Quak
@* The polystruct class
@h
#ifndef __POLYSTRUCT_H__
#define __POLYSTRUCT_H__

class builtintree
{
public:
   int nbytes;
};


//
// Object Definition.
//
class polystruct
{
public:
   int npoints_v;
public:
   int accelerator_v;
protected:
   point data_v[1];
public:

   //
   // Data storage.
   //
   int npoints() const;
   point& data(int i);

   polystruct();
   

   //
   // Required Operations
   //
   int hash() const;
   int nbytes() const;
   static int length(int npoints);
   bool OK() const;
   void convert_host_to_net();
   void convert_net_to_host();

   void* acceleratorptr() const;
   int accelerator() const;
   bool hasaccelerator() const;
   polystruct* addaccelerator(const char* accelerator,size_t accbytes) const;
   polystruct* removeaccelerator() const;

   int expectedstrlen() const;
   int tostr(char* s,int len) const;

   static polystruct null;
   bool isnull() const;

   static polystruct* create(const Array<point>& pointlist);
   static polystruct* create(int npoints);
   static polystruct* create(int npoints,int acceleratorsize);
   static polystruct* fromstr(char *s,int* parselen,int *buflen,polystruct* p);

   const point& operator[](int index) const;
   const point& pnt(int index) const;
   point& pnt(int index);
   const point& modpnt(int index) const;
   box bbox() const;
   polystruct* copy() const;
   bool ismonotone(int start,int end) const;

   void reverse();
   void translate(const point& p);
   void scale(const double factor);
   void rotate(const double angle);

   void operator+=(const point& p);
   void operator-=(const point& p);
   void operator*=(const double factor);
   void operator/=(const double factor);

   //
   // Calculate the bounding box of the points in the range of
   //    [min .. max] (including p[max])
   // This results in four integers.
   //
   void rangebbox(
      int start,
      int end,
      int& left,
      int& top,
      int& right,
      int& bottom) const;
};

inline polystruct::polystruct()
{
   npoints_v = -1;
   accelerator_v = 0;
}

inline const point& polystruct::modpnt(int index) const
{
   return(data_v[index%npoints_v]);
}

inline const point& polystruct::operator[](int index) const
{
   if ((index < 0) || (index >= npoints_v))
      GDKerror("polystruct::operator[%d] out of bounds [0,%d]\n",
         index,npoints_v -1);

   return(data_v[index]);
}

inline point& polystruct::pnt(int index)
{
   if ((index < 0) || (index >= npoints_v))
      GDKerror("Index %d out of bounds [0,%d]\n",index,npoints_v -1);
   return(data_v[index]);
}

inline const point& polystruct::pnt(int index) const
{
   if ((index < 0) || (index >= npoints_v))
      GDKerror("Index %d out of bounds [0,%d]\n",index,npoints_v -1);

   return(data_v[index]);
}

inline int polystruct::accelerator() const
{
   return(accelerator_v);
}

inline bool polystruct::hasaccelerator() const
{
   return(accelerator() != 0);
}

inline int polystruct::npoints() const
{
   return(npoints_v);
}

inline point& polystruct::data(int index)
{
#ifdef DEBUG
   if ((index < 0) || (index >= npoints_v))
      GDKerror("Index %d out of bounds [0,%d]\n",index,npoints_v -1);
#endif
   return(data_v[index]);
}

#endif /* __POLYSTRUCT_H__ */
@C
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "geometry.h"
#include "polystruct.h"

int polystruct::length(int np)
{
   register int varsize = (np-1) * sizeof(point);
   return (varsize > 0) ? sizeof(polystruct) + varsize : sizeof(polystruct);
}

box polystruct::bbox() const
{
   coord left,right,top,bottom;

   bottom = top =  pnt(0).y ;
   right = left =  pnt(0).x ;

   for(int i=npoints()-1;i>=1;--i)
   {
      const point& pn = pnt(i);
      double tx = pn.x;
      double ty = pn.y;

      if (tx < left)
         left = tx;
      if (tx > right)
         right = tx;
      if (ty > top)
         top = ty;
      if (ty < bottom)
         bottom = ty;
   }

   return(box(left,top,right,bottom));
}

int polystruct::nbytes() const
{
#ifdef DEBUG
   OK();
#endif

   if (hasaccelerator())
   {
      int start = accelerator();
      builtintree* b = (builtintree *)acceleratorptr();
      start += b->nbytes;
      return(start);
   }
   else
      return(polystruct::length(npoints()));
}

void polystruct::translate(const point& p)
{
#ifdef DEBUG
   OK();
#endif

   for(int i=0;i<npoints();++i)
      data_v[i].translate(p);
}

void polystruct::scale(const double factor)
{
#ifdef DEBUG
   OK();
#endif

   for(int i=0;i<npoints();++i)
      data_v[i].scale(factor);
}

void polystruct::rotate(const double angle)
{
   for(int i=0;i<npoints();++i)
      data_v[i].rotate(angle);
}

int polystruct::hash() const
{
   int rval = bbox().hash();
   // GDKwarning("returning %d\n",rval);
   return(rval);
}

//
// Allocate space for a polystruct with n points
// together with an index of indexsize bytes.
//
polystruct* polystruct::create(int np,int acceleratorsize)
{
   int nbytes = polystruct::length(np);

   //
   // Round up to 8 bytes.
   //
   nbytes +=  7;
   nbytes -= (nbytes % 8);

   int accelerator_v = nbytes;


   nbytes += acceleratorsize;

   polystruct* rval = (polystruct *)new char[nbytes];
   //polystruct* rval = (polystruct *)GDKmalloc(nbytes);
   rval->npoints_v = np;
   rval->accelerator_v = accelerator_v;

   return(rval);
}

polystruct* polystruct::create(const Array<point>& pointlist)
{
   polystruct* rval = polystruct::create(pointlist.nitems());
   
   for(int i=0;i<pointlist.nitems();++i)
      rval->pnt(i) = pointlist[i];

   return(rval);
}

//
// Allocate space for a polystruct with n points.
//
polystruct* polystruct::create(int np)
{
   polystruct* rval = (polystruct *)new char[polystruct::length(np)];
   rval->npoints_v = np;
   rval->accelerator_v = 0;
   return(rval);
}

polystruct* polystruct::removeaccelerator() const
{
   int nb = polystruct::length(npoints());
   polystruct* rval = (polystruct *)new char[nb];
   memcpy(rval,this,nb);
   rval->accelerator_v = 0;
   return(rval);
}

polystruct* polystruct::copy() const
{
   if (isnull())
      return(new polystruct());
   else
   {
      int nb = nbytes();

      polystruct* rval = (polystruct *)new char[nb];
      memcpy(rval,this,nbytes());
      return(rval);
   }
}

int polystruct::expectedstrlen() const
{
   return(20 + (npoints() * 40));
}

int polystruct::tostr(char* string,int len) const
{
   int rval = 0;

   rval += sprintf(string + rval,"(%d:",npoints());

   for (int i = 0; i < npoints(); ++i)
   {
      rval += put_coord(string + rval, pnt(i).x);
      rval += sprintf  (string + rval,",");
      rval += put_coord(string + rval, pnt(i).y);
      if (i+1 != npoints())
	rval += sprintf(string + rval,",");
   }
   rval += sprintf(string + rval,")");

   if (rval > len)
      GDKwarning("Prepare for the worst\n");
   return(rval);
}

polystruct* polystruct::fromstr(char *sstart,int* parselen,int *buflen,polystruct* p)
{
   char* s = sstart;

   s = strchr(s,'(');
   if (s == 0)
      GDKerror("Missing ( in polystruct");
   ++s;

   int np = get_long(s,&s);
   if (s == 0)
      GDKerror("Illegal npoints in polystruct");

   s = strchr(s,':');
   if (s == 0)
      GDKerror("Missing : in polystruct");
   ++s;

   if (p == 0)
   {
      p = polystruct::create(np);
      *buflen = polystruct::length(np);
   }
   else if (*buflen < polystruct::length(np))
   {
      delete p;
      p = polystruct::create(np);
      *buflen = polystruct::length(np);
   }
   p->npoints_v = np;
   p->accelerator_v = 0;

   for(int i=0;i<np;++i)
   {
      p->data_v[i].x = get_coord(s,&s);
      s = strchr(s,',');
      if (s == 0)
      {
	 GDKerror("Missing , in polystruct\n");
	 return(p);
      }
      ++s;
      p->data_v[i].y = get_coord(s,&s);
      if (i != np -1)
      {
	 s = strchr(s,',');
	 if (s == 0)
	 {
	    GDKerror("Missing, in polystruct\n");
	    return(p);
	 }
	 ++s;
      }
   }

   s = strchr(s,')');
   if (s == 0)
      GDKerror("Missing ) in polystruct");
   ++s;

   *parselen = s-sstart-1;
   return(p);
}

polystruct polystruct::null;

bool polystruct::isnull() const
{
   return(npoints() == -1);
}

bool polystruct::OK() const
{
   if (npoints() < 0)
   {
      GDKerror("polystruct with %d points",npoints());
      return(false);
   }
   return(true);
}

void polystruct::reverse()
{
   int npt = npoints()/2;
   for(int i=0;i<npt;++i)
   {
      point tmp(pnt(i));
      data(i) = pnt(npoints() -1 -i);
      data(npoints() -1 -i) = tmp;
   }
}

void polystruct::rangebbox(
      int start,
      int end,
      int& left,
      int& top,
      int& right,
      int& bottom) const
{
   left = start;
   top = start;
   right = start;
   bottom = start;

   for(int i=start + 1;i<=end;++i)
   {
      if(modpnt(i).x < modpnt(left).x)
         left = i;
      if(modpnt(i).y > modpnt(top).y)
         top = i;
      if(modpnt(i).x > modpnt(right).x)
         right = i;
      if(modpnt(i).y < modpnt(bottom).y)
         bottom = i;
   }
}

void* polystruct::acceleratorptr() const
{
   int accindex = accelerator();
   if (accindex == 0)
   {
      GDKerror("No accelerator\n");
      return ((void *)0);
   }

   char* start = (char *)this;
   void* rval = (void *)(&(start[accindex]));

   return(rval);
}

//
// Copy this polystruct and add the given accelerator.
//
polystruct* polystruct::addaccelerator(const char* accelerator,size_t accbytes) const
{
   if (hasaccelerator())
   {
      GDKwarning("Polygon already has accelerator\n");
   }

   //
   // Create new polystruct.
   //
   int npoints_v = npoints();
   int accelerator_v = nbytes();

   polystruct* rval = polystruct::create(npoints(),accbytes);

   memcpy(rval,this,nbytes());

   rval->npoints_v = npoints_v;
   rval->accelerator_v = accelerator_v;

   memcpy(rval->acceleratorptr(),accelerator,accbytes);

   return(rval);
}

//
// Return true if the given polystruct is  monontone
// between the given start and endpoint.
//
bool polystruct::ismonotone(int start,int end) const
{
    if (modpnt(start).x < modpnt(end).x)
    {
       for(int x=start + 1;x<=end;++x)
       {
          if(modpnt(x -1) > modpnt(x))
	     return(false);
       }
    }
    else
    {
       for(int x=start + 1;x<=end;++x)
       {
          if(modpnt(x -1) < modpnt(x))
	     return(false);
       }
    }

    if (modpnt(start).y < modpnt(end).y)
    {
       for(int y=start + 1;y<=end;++y)
       {
          if(modpnt(y -1) > modpnt(y))
	     return(false);
       }
    }
    else
    {
       for(int y=start + 1;y<=end;++y)
       {
          if(modpnt(y -1) < modpnt(y))
	     return(false);
       }
    }
    return(true);
}

void polystruct::operator -=(const point& p)
{
   for(int i=0;i<npoints();++i)
      data_v[i] -= p;
}

void polystruct::operator +=(const point& p)
{
   for(int i=0;i<npoints();++i)
      data_v[i] += p;
}

void polystruct::operator *=(const double factor)
{
   for(int i=0;i<npoints();++i)
      data_v[i] *= factor;
}

void polystruct::operator /=(const double factor)
{
   for(int i=0;i<npoints();++i)
      data_v[i] /= factor;
}

void polystruct::convert_host_to_net()
{
   for(int i=0;i<npoints();++i)
      pnt(i).convert_host_to_net();

   convert_endianism(npoints_v);
   convert_endianism(accelerator_v);   
}
void polystruct::convert_net_to_host()
{
   convert_endianism(npoints_v);
   convert_endianism(accelerator_v);   

   for(int i=0;i<npoints();++i)
      pnt(i).convert_net_to_host();
}
