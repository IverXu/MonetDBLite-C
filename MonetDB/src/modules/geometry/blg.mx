@f blg
@t The blg module.
@a C.W. Quak
@* The blg module.
The blg module contains an implementation of the Binary Line Generalization
Tree (BLG) as described in chapter 5 of Peter van Oosterom's Ph.D. thesis.
The tree is implemented as an atomic type which is always associated with a 
polyline atom. The create_blg function create the corresponding blg-tree for
a given polyline. The reduce command reduces this polyline to a lower resolution
with a given maximum error. The command printblg is for debugging purposes only.
@m
.MODULE blg;

   .USE gis;

   .ATOM blg;
      .TOSTR   = blg_tostr;
      .FROMSTR = blg_fromstr;
      .NEQUAL  = blg_comp;
      .DEL     = blg_del;
      .HASH    = blg_hash;
      .NULL    = blg_null;
      .PUT     = blg_put;
      .LENGTH  = blg_length;
      .HEAP    = blg_heap;
      .CHECK   = HEAP_check;
   .END;

   .COMMAND create_blg(polyline) 	: blg		= BLGcreate; ""
   .COMMAND reduce(polyline,blg,dbl) 	: polyline	= BLGreduce; ""

   .COMMAND printblg(blg)				= BLGprint; ""

.END blg;
@h
#ifndef __BLG_H__
#define __BLG_H__

//
// Object Definition.
//
class blg_node
{
public:
   int left;
   int right;
   float error;
};

class blg
{
public:
   //
   // Data storage.
   //
   int nnodes;
   int rootindex;
   blg_node data[1];

   //
   // Operations needed by Monet.
   //
   int hash() const;
   int nbytes() const;

   //
   // Constructors.
   //
   // void operator delete(void *ptr);

   blg_node& node(int index);
};

static inline int blgsize(int nnodes)
{
   return(sizeof(blg) + ((nnodes-1) * sizeof(blg_node)));
}

extern blg* create_blg(const polyline& p);

#include "blg.proto.h"

#endif /* __BLG_H__ */
@C
#include "gis.h"
#include "blg.h"

blg_node& blg::node(int index)
{
   --index;
   if ((index < 0) || (index >= nnodes))
      GDKerror("blgnode index out of range\n");
   
   return(data[index]);
}

static int blg_build_rec(
   const polyline& p,
   int min,
   int max,
   blg* tree)
{
   if (min + 1 == max)
      return(0);
   
   segment s(p.pnt(min),p.pnt(max));

   //
   // Find the current node.
   //
   int current = -1;
   float errval = -1.0;
   for (int i=min + 1;i<max;++i)
   {
      double d = distance(p.pnt(i),s);
      if (d > errval)
      {
	 errval = d;
	 current = i;
      }
   }

   if (current == -1)
      GDKerror("implementation error\n");

   //
   // current -- location where node needs to be split.
   // errval -- error value at this level.
   //


   int leftson = blg_build_rec(
      p,
      min,
      current,
      tree);
   int rightson = blg_build_rec(
      p,
      current,
      max,
      tree);
   
   blg_node& thisnode = tree->node(current);
   thisnode.left = leftson;
   thisnode.right = rightson;
   thisnode.error = errval;
   
   
   return(current);
}

blg* create_blg(const polyline& p)
{
   int nnodes = p.npoints()-2;
   blg* rval = (blg *)GDKmalloc(blgsize(nnodes));
   rval->nnodes = nnodes;
   
   rval->rootindex = blg_build_rec(p,0,p.npoints() -1,rval);
   return(rval);
}

static void blg_reduce_rec(
   point* rval,
   int& npts,
   const polyline& p,
   int nodeindex,
   float error,
   blg& tree,
   int maxpoints)
{
   if (nodeindex == 0)
      return;

   blg_node currnode = tree.node(nodeindex);

   if (currnode.error <= error)
      return;
   
   blg_reduce_rec(
      rval,
      npts,
      p,
      currnode.left,
      error,
      tree,
      maxpoints);

   rval[npts++] = p.pnt(nodeindex);
   if (npts == maxpoints)
   {
      GDKerror("wrong");
      --(npts);
   }

   blg_reduce_rec(
      rval,
      npts,
      p,
      currnode.right,
      error,
      tree,
      maxpoints);

}

polyline* reduce(blg& tree,const polyline& p,float error)
{
   point* rpoints = new point[p.npoints() + 1];
   int npts=1;
   rpoints[0] = p.source();
   blg_reduce_rec(rpoints,npts,p,tree.rootindex,error,tree,p.npoints());
   rpoints[npts++] = p.dest();

   if ((npts == 2) && (rpoints[0] == rpoints[1]))
      npts = 1;

   polyline* rval = polyline::create(npts);
   for(int i=0;i<npts;++i)
      rval->data(i) = rpoints[i];
   delete [] rpoints;
   return(rval);
}

@- Basic blg routines
@C
int blg_tostr(str* tostr,int* l,blg*)
{
   {
      int expectedlen = 10 ;
      if (*l < expectedlen)
      {
         if (*tostr != NULL)
            GDKfree(*tostr);
         *tostr = (str)GDKmalloc(expectedlen);
         *l = expectedlen;
      }
   }

   sprintf(*tostr,"useless");
   char* s = *tostr + strlen(*tostr);
   *s = '\0';
   return(s - *tostr);
}

int blg_fromstr(str,int*,blg** val)
{
   *val = NULL;
   return(1);
}

void blg_put(Heap* h,int* bun,blg* val)
{
   char* base;

   *bun  = HEAP_malloc(h,blgsize(val->nnodes));
   base = h->base;
   memcpy(&base[*bun],(char *)val,blgsize(val->nnodes));

}

int blg_comp(blg* l,blg*  r)
{
   if (l->nnodes != r->nnodes)
      return(1);
   int len = l->nnodes;

   if (len == -1)
      return(0);

   return(0);
}

void blg_del(Heap* h,int* index)
{
   HEAP_free(h,*index);
}

static int war=0;
int blg_hash(blg* I)
{
   if (war == 0)
   {
      ++war;
      GDKerror("blg_hash badly implemented yet");
   }
   return(I->nnodes);
}

blg* blg_null()
{
   blg* rval = new blg;
   rval->nnodes = 0;
   return(rval);
}

int blg_length(blg* p)
{
   return(blgsize(p->nnodes));
}

int blg_heap(Heap* heap,int capacity)
{
   HEAP_initialize(heap,capacity,0,8);
   return 0;
}

@C
//
// .COMMAND createblg(int) : blg
//
int BLGcreate(
   blg** retval,
   polyline* p)
{
   blg* rval = create_blg(*p);
   *retval = rval;
   return(GDK_SUCCEED);
}

int BLGprint(blg* tree)
{
   GDKwarning("the root of the tree has index %d\n",tree->rootindex);
   for(int i=0;i<tree->nnodes;++i)
   {
      GDKwarning("Node %d has error %f and children (%d,%d)\n",
         i+1,tree->data[i].error,tree->data[i].left,tree->data[i].right);

   }
   return(GDK_SUCCEED);
}
//
// .COMMAND reduce(polyline,blg,dbl) : polyline	= BLGreduce; ""
//
int BLGreduce(
   polyline** retval,
   polyline* p,
   blg* tree,
   double* error)
{
   polyline* rval = reduce(*tree,*p,(float)(*error));
   *retval = rval;
   return(GDK_SUCCEED);
}

@mil
setoid(oid(20000000));
module(blg);
a := polyline("(3:0,0,1,1,2,2)");
a.create_blg;

quit;
