@f Minspect
@v 0.5
@a M.L. Kersten
@* The Minspect utility
@+ Manual Page
@T
The utility Minspect can be used to assess the damage after a system
crash and to obtain some statistics for administrative purposes.
The related program is Mrecover, which resolves the errors found.
 
@- Usage
@T
\begin{verbatim}
Minspect [-home <file>] [-db <name>] 
\end{verbatim}
@{
@+ Implementation
@c
#include <gdk.h>
#include <dirent.h>

int error,fatal;
char * home = 0, *db = 0;
int dbload =0;
extern int BBPdirty;

int main(int argc, char **argv) {
        char *args[5];

	dbargs(argc,argv, args);
	args[4]= GDKstrdup("-recover");
        GDKinit(5,args);

	chkDir();
	chkBBP();
	chkTmp();
	chkDictionary();
	chkBAT();
	if( error ) 
		printf("System detected %d recoverable errors\n",error);
	else	printf("Database is OK\n");
	/* printf("and %d non-recoverable errors\n",fatal);*/
	GDKexit();
}

void usage() {
	printf("usage: Minspect [-home <home>] -db <db>\n");
}
@-
First action is to read and check the BBP table.
@c

void chkBBP() {
	int i;
	printf("Scanning Bat Buffer Pool table.\n");
	if(BBP_logical(0) ) { error++;
		printf("BBP_logical(0) is garbage:%s. ", BBP_logical(0));
	}
	if(BBP_physical(0) ) {error++;
		printf("BBP_physical(0) is garbage:%s. ", BBP_physical(0));
	}
	for(i=1;i<BBPsize;i++)
	if(BBP_logical(i)) {
		chkFile(BBP_physical(i),"desc",i);
		chkFile(BBP_physical(i),"buns",i);

		if(BBP_logical(i) && BBP_physical(i)==0){
			printf("Physical part missing: %s\n", BBP_logical(i)); 
			error++;
		}
		if(BBP_physical(i) && BBP_logical(i)){
			printf("Logical part missing: %s\n", BBP_physical(i)); 
			error++;
		}
	}
}

void chkFile(char *nme, char *extension, inti) {
	FILE *f,*fc;
		char buf[200];
		sprintf(buf,"%s.Z",extension);
		
		f = (FILE*) GDKfilelocate(nme,"r",extension);
		fc= (FILE*) GDKfilelocate(nme,"r",buf);
		if(f && fc){
			printf("Replicate storage: %s%s and %s%s\n",
				nme,extension,nme,buf);
			error++;
		} else
		if(f == NULL && fc == NULL){
			printf("File missing: %s%s\n",nme,extension);
			error++;
		}
		if(f) fclose(f); if(fc) fclose(fc);
}
@-
In a crash situation the directory may contain temporary BATs.
They are recognized by name pattern. Those referenced from the BBP should
be retained. Others are simple discarded upon closure of the program.
@c
void chkTmp() {
	int i,j;
	for(i=0;i<BBPsize;i++)
	if(BBP_logical(i) && sscanf(BBP_logical(i),"tmp_%d",&j)==1){
		error++;
		printf("Temporary found: %s\n",BBP_logical(i));
	}
}
@-
The next phase inspects the directory for files that look like a BAT, but
which are not stored in the BBP table. Repair simply means addition.
@c
void chkDir() {
	DIR *dp;
	struct dirent *dirp;
	char msg[200],*s;
        char buffer[2048];

	sprintf(msg,"%sbat/",dbhome);
	printf("Scanning the directory %s\n",msg);
	dp= opendir(msg);
	if( dp== (DIR*) NULL){
		printf("Could not open database directory %s\n",msg);
		return;
	}
@-
Version 3.04 uses the notion of <db>/users/<usr> for collectin
specific user items
@c
        sprintf(msg,"%s/mod", dbhome);
        if( opendir(msg) == (DIR*) NULL){
                fprintf(stderr,"Module directory missing\n");
        }
        sprintf(msg,"%s/users", dbhome);
        if( opendir(msg) == (DIR*) NULL){
                fprintf(stderr,"User directory missing\n");
        }

	for(;;){
		dirp= readdir(dp);
		if( dirp== (struct dirent *) NULL){
			closedir(dp);
			break;
		}
		s= (char*) strchr(dirp->d_name,'.');
		if(s && (strcmp(s,".desc")==0 || strcmp(s,".desc.Z")==0)){	
			*s=0;
			if(BBPindex(dirp->d_name)) continue;
			printf("BBP entry missing: %s\n",dirp->d_name);
			error++;
		}
	}
}
@-
The last check operation is load each BAT to check for inconsistent reads.
This option should be used with care.
@c
void chkBAT() {
	BAT *b;
	int i;

        if( dbload == 0 ){
                printf("BATs not explicitly loaded for conversion\n");
                printf("If needed use the extension -load\n");
                return;
        }


	printf("Loading all BATs once.\n");
	for(i=1;i<BBPsize;i++)
	if( BBP_logical(i)){
		b = BATload(BBP_physical(i));
		if(b==0){
			printf("Corrupted BAT: %s\n", BBP_logical(i));
			fatal++;
		} else {
			BBPunload(i);
		}
	}
}

@-
Monet maintains a dictionary. As a result of a system malfunction, this
database may have become corrupted. The routine below removes all
related files, such that are automatically reconstructed upon starting the
server.
@c
void chkDictionary() {
	printf("Remove dictionary tables by hand\n");
}
@- Common utilities
The routine getarguments is shared by most tools. They analyse the calling
parameters to determine the home and database. 
Furthermore, it prepares the argument list for the database server.
This code is textually included in all relevant tools. (Should be
done in a better way).
@c
void dbargs(int argc, char **argv, char *args[4]) {
 	int i; 
	char buf[PATHLENGTH];

	args[0]= GDKstrdup("-home");
	args[2] = GDKstrdup("-db");
	home=(char *) getenv("MONETHOME");
	if(argc<3) usage();
	for(i=1;i<argc;i++)
	if( strcmp(argv[i],"-home")==0)
		home = argv[++i];
	else
	if( strcmp(argv[i],"-db")==0)
		db = argv[++i];
        else
        if ( strcmp(argv[i],"-load") == 0)
                dbload =1;

        if( home == 0) {
                printf("MONETHOME missing\n");
		exit(0);
        }
        if( db == 0) {
                printf("database name missing\n");
		exit(0);
        }
	sprintf(buf,"%s/homes",home);
	args[1] = GDKstrdup(buf);
	args[3] = GDKstrdup(db);
}
@}
