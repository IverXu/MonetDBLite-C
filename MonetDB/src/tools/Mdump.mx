@f Mdump
@a M. L. Kersten, Menzo Windhouwer
@v 0.6 
@* Monet Database Dump Utility
@+ Manual Page
@T
The {\tt Mdump} utility is designed to prepare a backup copy of a Monet 
database in ascii format. It is typically used to migrate between 
versions of the system.
 
@- Usage
@T
\begin{verbatim}
Mdump [-d<debug level>]  [-s ] [ -port <host:port> ]  <backup-directory> 
\end{verbatim}

A directory should be given where the result should be retained.
If the dump works properly, it contains a script to reload the database

The dump utility can run concurrently with the server only after we have
installed the concurrency controller. For now we assume a quite database.

The program uses the Mapi interface as another example to test this entry point.
@{
@+ Implementation
@c
#include <stdio.h>
#include <stdlib.h>

#include   "Mapi.h"
#include <gdk.h>

extern void dumpdb();
extern void dumpBat();

int	debug, scriptonly, nonpersist;
char 	*address, *dir;
FILE	*sf;
Msession   mid;
Msession   qry;

void usage() {
	printf("usage: Mdump [-port <portid>] [-nonpersistent] <backupdirectory>\n");
	exit(0);
}

int main(int argc, char **argv) {
	int i;
	char *s, sname[500];

	address = getenv("MONETPORT");
        for(i = 1; i < argc; i++) 
	if (argv[i][0] == '-') {
		switch(argv[i][1]) {
		case 'd':
			debug++;
			break;
		case 's':
			scriptonly++;
			break;
		case 'p':
			if (strcmp(argv[i], "-port") == 0) {
				address = argv[++i];
				break;
			}
		case 'n':
			nonpersist++;
			break;
		default:
			fprintf(stderr,
			"unknown argument:%s\n", argv[i]);
			usage();
		}
	} else if( dir ) {
		usage();
	} else {
		dir = argv[i];
		if (dir[strlen(dir)-1] != '/')
			strcat(dir,"/");
	}

	if( address == 0 || dir == 0 ) usage();
	s = (char *) strchr(address,':');
	if( s == 0 ){
		printf("address syntax error: %s\n", address);
		exit(0);
	}
	*s = 0;
	i = atoi(s+1);
	if( *address == 0 ) address = 0;
	mid = Mconnect(address,i,0,0);
	if( Merror(mid)) {
		Mexplain(mid,stdout);
		exit(0);
	}
	mid->trace = debug;
	qry = Mconnect(address,i,0,0);
	if( Merror(qry)) {
		Mexplain(qry,stdout);
		exit(0);
	}
	qry->trace = debug;
@-
The directory should be cleared and there should be enough disk space.
@c
	sprintf(sname,"%s/DBrestore",dir);
	sf = fopen(sname,"w");
	if( sf == 0) {
		printf("Can not create script file: %s\n",sname);
		exit(0);
	}
	chmod(sname,0770);
	if( debug ) sf= stdout;
	dumpdb();
        Mdisconnect(mid);
/*
        if( Merror(mid)) Mexplain(mid,stdout);
*/
	Mdisconnect(qry);
/*
        if( Merror(qry)) Mexplain(qry,stdout);
*/
	printf("# dump finished\n");
	return 0;
}
@-
The Monet script to reload the database
@c
void dumpdb() {
	int retval,i;
	char buffer[2000], *s = buffer;

	if (nonpersist)
		strcpy(buffer,"view_bbp_name.kdiff(view_bbp_name.likeselect(\"monet_%%\")).kdiff(view_bbp_name.likeselect(\"tmp_%%\")).print;");
	else
		strcpy(buffer,"view_bbp_name.semijoin(view_bbp_kind.select(\"pers\")).print;");
	retval = Mquery(mid,buffer,0);
	if( retval ) { Mexplain(mid,stdout); exit(0); }

	while( !Merror(mid) && 
		Mfetch(mid, &i, TYPE_int,&s, TYPE_str, 0) == MOK) {
		printf("# %d %s\n", i,s);
		if (strcmp(s,"")!=0)
			dumpBat(s);
	}
}
@-
For each BAT we have to generate a small script that creates it.
It relies on the implementation of the BATschema command, which generates
the key properties that should be known to reconstruct the BAT.
The line produced reads:
@T
[ batname, hname, htype, hkey, tname, ttype, tkey, set, capacity]
@
The script is sent to standard output for now.
@c
char *infoBat(char *b, char *s, char *q) {
	char sbackup[1000];
	strcpy(b,"");
	sprintf(sbackup,"%s.info.find(\"%s\").print;",s,q);
	if (Mquery(qry, sbackup, 0) != MOK) {
		Mexplain(qry,stdout);
	} else if (Mget(qry, &b, TYPE_str,0) != MOK) {
		Mexplain(qry,stdout);
		strcpy(b,"");
	}
	return b;
}

void dumpBat(char* s) {
	char buf[1000];

	char ht[100] ="int";
	char tt[100] ="int";
	char cap[10] ="1000";
	char hn[100] ="h";
	char tn[100] ="t";
	int set = 0;
	int persists = 0;
	int hk = 0;
	int tk = 0;

	strcpy(ht,infoBat(buf,s,"head"));
	strcpy(tt,infoBat(buf,s,"tail"));
/*
	strcpy(cap,infoBat(buf,s,"??"));
*/
	strcpy(hn,infoBat(buf,s,"hident"));
	strcpy(tn,infoBat(tn,s,"tident"));
	set = strcmp(infoBat(buf,s,"batSet"),"0");
	persists = !strcmp(infoBat(buf,s,"batPersistence"),"persistent");
	hk = strcmp(infoBat(buf,s,"hkey"),"0");
	tk = strcmp(infoBat(buf,s,"tkey"),"0");

	fprintf(sf,"%s := new(%s, %s, %s);\n", s, ht,tt,cap);
	fprintf(sf,"%s.rename(\"%s\");\n", s,s);
	fprintf(sf,"%s.roles(\"%s\", \"%s\");\n", s, hn,tn);
	fprintf(sf,"%s.set(%s);\n", s, (set?"true":"false"));
	fprintf(sf,"%s.persists(%s);\n", s, (persists?"true":"false"));
	fprintf(sf,"%s.key(%s);\n", s, (hk?"true":"false"));
	fprintf(sf,"%s.reverse.key(%s);\n", s, (tk?"true":"false"));
@-
And save the contents of the bat in the backup ascii file
@c
	if( debug == 0 ){
		char sbackup[1000];
		sprintf(sbackup,"%s.export(\"%s%s.ascii\");", s, dir,s);
		Msend(qry,sbackup,0);
		if( Merror(qry) ) {
			Mexplain(qry,stdout);
		}
		fprintf(sf,"%s.import(\"%s%s.ascii\");\n", s, dir,s);
	}
}
@}
