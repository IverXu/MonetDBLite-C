@f atom
@a Niels Nes

@h
#ifndef _ATOM_H_
#define _ATOM_H_

#include "ops.h"
#include "list.h"
#include "type_arg.h"

class Atom : public Symbol {
    public:
	Atom( int t, char *n, int size = 0, 
	      int align = 0, Atom *parent = NULL,
	      Ops **cmds = NULL ); 
	Atom( int t, char *n, int size = 0, 
	      int align = 0, Arg *type = NULL,
	      Ops **cmds = NULL ); 

	int isFixed() const;
	int size() const;
	int align() const;
	Atom *parent() const;
	Atom *top_parent() const;
	Arg *type() const;
	Arg *top_type() const;
	Ops **cmds() const;

	virtual ostream &print( language *l, ostream &o ) const ;
    private:
	int _size;
	int _align;
	Atom *_parent;
	Arg *_type;
	Ops **_cmds;
};
#endif 

@C
#include "atom.h"
#include "language.h"

Atom::Atom( int t, char *n, int size, int align, Atom *parent, 
		Ops **cmds ) 
	: Symbol(t,n) {
	_size = size;
	_align = align;
	_parent = parent;
	_type = NULL;
	_cmds = cmds;
}

Atom::Atom( int t, char *n, int size, int align, Arg *type, 
		Ops **cmds ) 
	: Symbol(t,n) {
	_size = size;
	_align = align;
	_parent = NULL;
	_type = type;
	_cmds = cmds;
}

int Atom::isFixed() const {
	if (_parent)
		return _parent->isFixed();
	if (_type)
		return _type->isFixed();
	return _size>=0;
}

int Atom::size() const {
	if (_parent)
		return _parent->size();
	return _size;
}

int Atom::align() const {
	if (_parent)
		return _parent->align();
	return _align;
}

Atom *Atom::parent() const {
	return _parent;
}

Atom *Atom::top_parent() const {
	Atom *a = parent();
	while(a && a->parent())
		a = a->parent();
	return a;
}

Arg *Atom::type() const {
	return _type;
}

Arg *Atom::top_type() const {
   	Atom *a = top_parent();
	if (a)
	   	return a->type();
	return _type;
}

Ops **Atom::cmds() const {
	return _cmds;
}

ostream &Atom::print( language *l, ostream &o ) const {
	return l->gen_atom( o, *this );
}
