@f symtable
@a Niels Nes

@h
#ifndef _SYMTABLE_H_
#define _SYMTABLE_H_

#include "symbol.h"
#include <iostream.h>

class Symtable {
	
    public: 
	Symtable( size_t size );
	~Symtable( );
	void insert( const Symbol &s);
	const Symbol *find( int token, const char *name ) const;
	const Symbol *find( const char *name ) const;
	void traverse( language *l, ostream &s );
    private:
	int      _next;
	size_t   _size;
	const Symbol **_table;
};
#endif //_SYMTABLE_H_

@C
#include "symtable.h"
#include <string.h>

Symtable::Symtable( size_t size ){
	_next = 0;
	_size = size;
	_table = new const Symbol*[size];
}	

Symtable::~Symtable(){
	delete [] _table;
}

void Symtable::insert( const Symbol &s ){
	_table[_next++] = &s;
}

const Symbol *Symtable::find( int token, const char *name ) const {
	for (int i = 0; i < _next; i++){
		const Symbol *sym = _table[i];
		if (sym->Token() == token &&
		   strcmp(sym->Name(), name ) == 0 ){
			return sym;
		}
	} 
	return NULL;
}

const Symbol *Symtable::find( const char *name ) const {
	for (int i = 0; i < _next; i++){
		const Symbol *sym = _table[i];
		if (strcmp(sym->Name(), name ) == 0 ){
			return sym;
		}
	} 
	return NULL;
}

void Symtable::traverse( language *l, ostream &s ){
	for (int i = 0; i < _next; i++){
		const Symbol *sym = _table[i];
		sym->print(l,s);
	}
}
